{
  "ADDGRID": {
    "default_value": "ADDGRID = .FALSE.",
    "description": "ADDGRID determines whether an additional support grid is used for the evaluation of the augmentation charges.",
    "detailed_description": "When\nADDGRID\n=.TRUE. VASP uses an additional support grid for the evaluation of the augmentation charges. This grid contains 8 times more points than the standard \"fine\" grid (\nNGXF\n×\nNGYF\n×\nNGZF\n). Whenever terms involving augmentation charges are evaluated, this additional grid is used. For instance: The augmentation charge is evaluated first in real space on this additional grid, FFT-transformed to reciprocal space, and then added to the total charge density on the standard \"fine\" grid (\nNGXF\n×\nNGYF\n×\nNGZF\n). The additional grid often helps to reduce the noise in the forces. In some cases, it even allows to perform calculations with\nNGXF\n=\nNGX\n.\n\nCaveat:\nIf there is any contribution in the density or potential at the highest Fourier component\nG\n{\\displaystyle G}\nof\nthe conventional fine grid (given by\nNGXF\n×\nNGYF\n×\nNGZF\n), then Fourier interpolation to twice the grid density leads to\noscillations in real space. These oscillations correspond to the largest wave vector\nG\nc\nu\nt\n{\\displaystyle  G_{cut} }\ni.e.\ne\ni\nG\nc\nu\nt\nr\n{\\displaystyle e^{i G_{cut} r}}\n.\nIn real space, the charge density or potential will therefore alternate between positive and negative\nvalues on the ultra-fine grid, in particular, in regions where the density or potential are small.\nThe terminus techniques is \"termination wiggles\".\nAlthough this is a somewhat oversimplified presentation, it is fairly straightforward to derive more rigorous results in 1D. \nThe upshot is that Fourier-interpolation can lead to termination wiggles with oscillations\ne\ni\nG\nc\nu\nt\nr\n{\\displaystyle e^{i G_{cut} r}}\nin the interpolated potential   (where\nG\nc\nu\nt\n{\\displaystyle  G_{cut}}\ncorresponds to\nthe largest Fourier components on the fine grid). Fourier smoothing, which is in essence used for the augmentation densities, is generally less problematic, but it can also result in negative density in real space.\nTherefore, we recommend performing careful tests, on whether\nADDGRID\nworks as desired; please do not use this tag as default in all your calculations!",
    "related_tags": [
      "PREC",
      "NGX",
      "NGY",
      "NGZ",
      "NGXF",
      "NGYF",
      "NGZF",
      "ENCUT",
      "ENAUG",
      "ENMAX",
      "PRECFOCK"
    ]
  },
  "AEXX": {
    "default_value": "Default: AEXX = 0.25 if LHFCALC =.TRUE. | = 0 if LHFCALC =.FALSE.",
    "description": "AEXX specifies the fraction of exact exchange in a Hartree-Fock-type/hybrid-functional calculation.",
    "detailed_description": "Mind:\nFor versions of VASP prior to 6.4.0,\nALDAX\nwas constrained to be equal to 1.0-\nAEXX\n. This constraint is lifted since VASP.6.4.0.\nFor\nAEXX\n=1.0, VASP switches off correlation by default (\nALDAC\n=0.0,\nAGGAC\n=0.0, and\nAMGGAC\n=0.0) and thus runs a full Hartree-Fock calculation.",
    "related_tags": [
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "LHFCALC",
      "HFSCREEN",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "AGGAC": {
    "default_value": "Default: AGGAC = 1.0 if LHFCALC = {\\displaystyle =} .FALSE. or AEXX ≠ {\\displaystyle \\neq} 1.0 | = 0.0 if LHFCALC = {\\displaystyle =} .TRUE. and AEXX = {\\displaystyle =} 1.0",
    "description": "AGGAC is a parameter that multiplies the gradient correction in the GGA correlation functional.",
    "detailed_description": "AGGAC\ncan be used as the fraction of gradient correction in the GGA correlation in a Hartree-Fock/DFT hybrid functional.\n\nMind:\nAGGAC\nis implemented for all functionals listed at\nGGA\nexcept AM05.\nAGGAC\nis implemented for the functionals from Libxc (see\nLIBXC1\nfor details).",
    "related_tags": [
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AMGGAX",
      "AMGGAC",
      "LHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "AGGAX": {
    "default_value": "Default: AGGAX = 1.0- AEXX if LHFCALC =.TRUE. | = 1.0 if LHFCALC =.FALSE.",
    "description": "AGGAX is a parameter that multiplies the gradient correction in the GGA exchange functional.",
    "detailed_description": "AGGAX\ncan be used as the fraction of gradient correction in the GGA exchange in a Hartree-Fock/GGA hybrid functional.\n\nImportant:\nAGGAX\ncan be used only if\nLHFCALC\n=.TRUE.\n\nMind:\nAGGAX\nis implemented for all functionals listed at\nGGA\nexcept AM05.\nAGGAX\nis implemented for the functionals from Libxc (see\nLIBXC1\nfor details).",
    "related_tags": [
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "LHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "ALDAC": {
    "default_value": "Default: ALDAC = 1.0 if LHFCALC = {\\displaystyle =} .FALSE. or AEXX ≠ {\\displaystyle \\neq} 1.0 | = 0.0 if LHFCALC = {\\displaystyle =} .TRUE. and AEXX = {\\displaystyle =} 1.0",
    "description": "ALDAC is a parameter that multiplies the LDA correlation functional or the LDA part of the GGA correlation functional.",
    "detailed_description": "ALDAC\ncan be used as the fraction of LDA correlation in a Hartree-Fock/DFT hybrid functional.\n\nMind:\nALDAC\nis implemented for all functionals listed at\nGGA\nexcept AM05.\nALDAC\nis implemented for the functionals from Libxc (see\nLIBXC1\nfor details).",
    "related_tags": [
      "AEXX",
      "ALDAX",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "LHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "ALDAX": {
    "default_value": "Default: ALDAX = 1.0- AEXX if LHFCALC =.TRUE. | = 1.0 if LHFCALC =.FALSE.",
    "description": "ALDAX is a parameter that multiplies the LDA exchange functional or the LDA part of the GGA exchange functional.",
    "detailed_description": "ALDAX\ncan be used as the fraction of LDA exchange in a Hartree-Fock/DFT hybrid functional.\n\nImportant:\nALDAX\ncan be used only if\nLHFCALC\n=.TRUE.\n\nMind:\nFor versions of VASP prior to 6.4.0,\nALDAX\nwas constrained to be equal to 1.0-\nAEXX\n. This constraint is lifted since VASP.6.4.0.\nALDAX\nis implemented for all functionals listed at\nGGA\nexcept AM05.\nALDAX\nis implemented for the functionals from Libxc (see\nLIBXC1\nfor details).",
    "related_tags": [
      "AEXX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "LHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "ALGO": {
    "default_value": "ALGO = Normal",
    "description": "the ALGO tag is a convenient option to specify the electronic minimization algorithm (as of VASP.4.5) and/or to select the type of GW calculations .",
    "detailed_description": "ALGO\n=Normal selects\nIALGO\n=38 (\nblocked-Davidson-iteration scheme\n).\n\nALGO\n=VeryFast selects\nIALGO\n=48 (\nRMM-DIIS\n). This algorithm has been updated for vasp.6 to increase robustness. To select the version that was available in vasp.5, select \"Old VeryFast\".\nhybrid functionals\nare not supported for\nALGO\n=VeryFast. The algorithm can be combined with\nLDIAG\n=.FALSE. to conserve the initial orbital order (when orbitals are read from the\nWAVECAR\nfile).\n\nALGO\n=Old VeryFast (or \"ov\" or \"vo\") selects\nIALGO\n=48 (\nRMM-DIIS\n). This option is available in vasp.6 and selects the version of the\nRMM-DIIS\nalgorithm that was available in vasp.5.\n\nALGO\n=Fast selects a fairly robust mixture of the\nblocked-Davidson\nand\nRMM-DIIS\nalgorithms. In this case,\nblocked Davidson\n(\nIALGO\n=38) is used for the initial phase, and then VASP switches to\nRMM-DIIS\n(\nIALGO\n=48). Subsequently, for each ionic update, one\nIALGO\n=38 sweep is performed for each ionic step (except the first one).  This algorithm has been updated for vasp.6 to increase robustness. To select the version that was available in vasp.5, select \"Old Fast\".\n\nALGO\n=Old Fast (or \"of\" or \"fo\"). This option is available in vasp.6 and selects the\nALGO\n=Fast algorithm that was available in vasp.5.\n\nALGO\n=Conjugate or\nALGO\n=All selects an \"all band simultaneous update of orbitals\" (\nIALGO\n=58, both tags are synonymous). Recommended to be used with the improved line-search algorithm (\nISEARCH\n= 1).\n\nALGO\n=Damped selects a damped velocity friction algorithm (\nIALGO\n=53). The algorithm can be combined with\nLDIAG\n=.FALSE. to conserve the initial orbital order (when orbitals are read from the\nWAVECAR\nfile).\n\nALGO\n=Exact performs an exact diagonalization (\nIALGO\n=90).\n\nALGO\n=Subrot selects subspace rotation or diagonalization in the sub-space spanned by the orbitals (\nIALGO\n=4).\n\nALGO\n=Eigenval allows to recalculate one-electron energies, the density of state and perform selected postprocessing using the current orbitals (\nIALGO\n=3) e.g. read from the\nWAVECAR\nfile.\n\nALGO\n=None or\nALGO\n=Nothing allows to recalculate the density of states or perform selected postprocessing, using the current orbitals and one electron energies (\nIALGO\n=2) e.g. read from the\nWAVECAR\nfile.\n\nMore details can be found under the documentation for the tag\nIALGO\n.\n\nTip:\nExcept for 'None', 'Nothing', 'Exact' and 'Eigenval' (which must be spelled out), the first letter determines the applied algorithm.\n\nConjugate, Subrot, Eigenval, None and Nothing are only supported by vasp.5.2.9 and newer versions.\n\nWarning:\nFor fast convergence,\nLMAXMIX\nmust be set appropriately. E.g.\nLMAXMIX\n=6 for systems including f electrons.\n\nALGO for response functions and\nGW calculations\nand\nACFDT/RPA calculations\n\nThe following tags are available as of VASP.5.X.\n\nALGO\n=CHI calculates the response functions only.\n\nALGO\n=TDHF selects TDHF (or\nTDDFT\n) calculations using the VASP internal Cassida code see\nBSE calculations\n, (available as of VASP.5.2.12)\n\nALGO\n=BSE selects BSE calculations using the VASP internal Cassida code see\nBSE calculations\n, (available as of VASP.5.4.1)\n\nALGO\n=Timeev performs a delta-pulse in time and then performs\ntimepropagation\n\nALGO\n=ACFDT selects RPA total energy calculations see\nACFDT/RPA calculations\n\nALGO\n=RPA synonymous to ACFDT see\nACFDT/RPA calculations\n(available as of VASP.5.3.1)\n\nGW tags have been renamed in VASP as follows\n\n< 5.2.12\nscGW\nscGW0\nGW\nGW0\nN/A\nN/A\n>= 5.2.12, < 6\nQPGW\nQPGW0\nGW\nGW0\nN/A\nN/A\n>= 6\nQPGW\nQPGW0\nEVGW\nEVGW0\nGWR\nGW0R\n\nALGO\n=EVGW0 selects single-shot\nG\n0\nW\n0\ncalculations or partially self-consistent\nGW\ncalculations. The orbitals (wavefunctions) of the previous groundstate calculations are maintained, and\nG0W0 calculations\nare performed. If\nNELM\nis set, several iterations are performed, and the QP energies are updated in the calculation of\nG\n(for details, see\nEVGW0 calculations\n).\n\nALGO\n=EVGW selects single-shot\nG\n0\nW\n0\ncalculations or partially self-consistent\nGW\ncalculations. The orbitals of the previous groundstate calculations are maintained, and\nG0W0 calculations\nare performed. If\nNELM\nis set, several iterations are performed, and the QP energies are updated in the calculation of\nG\nAND\nW\n(for details, see\nself-consistent EVGW and QPGW calculations\n).\n\nALGO\n=QPGW0 selects self-consistent\nGW\ncalculations including off-diagonal components of the selfenergy. A full update of the QP energies AND one-electron orbitals is performed in the calculation of\nG\nonly (for details see\nQPGW0 calculations\n).\n\nALGO\n=QPGW selects self-consistent\nGW\ncalculations, including off-diagonal components of the selfenergy. A full update of the QP energies AND one-electron orbitals is performed in the calculations of\nG\nAND\nW\n(for details, see\nQPGW calculations\n).\n\nFollowing tags are available as of VASP.6\n\nALGO\n=RPAR selects low scaling RPA total energy calculations (for details see\nACFDT/RPA calculations\n)\n\nALGO\n=ACFDTR synonym for RPAR (for details see\nACFDT/RPA calculations\n)\n\nALGO\n=ACFDTRK in combination with LMP2LT = .TRUE. selects the low scaling MP2 total energy calculations (for details see the\nMP2 ground state Tutorial\n)\n\nALGO\n=GW0R selects self-consistent GW\n0\ncalculations, where only the Green's function\nG\nis updated from the corresponding Dyson. The screened potential\nW\nremains unchanged after the first iteration.\nNELM\niteration cycles are performed (see\nself-consistent GW calculations\n).\n\nALGO\n=GWR selects self-consistent GW calculations, where both,\nG\nand\nW\nare updated from the corresponding Dyson equation.\nNELM\niteration cycles are performed. (for details see\nself-consistent GW calculations\n).\n\nALGO\n=G0W0R selects single-shot GW calculations, non-interacting\nG\nand\nW\nare determined from Kohn-Sham system and\nNELM\ntag is ignored. Use this tag for single-shot QP energies and first-order corrections to the density matrix (for details, see\nsingle-shot GW calculations\n).\n\nImportant:\nChanges as of VASP.6.3:\n\nNELMGW\nreplaces\nNELM\nin\nself-consistent GW calculations\n.\n\nALGO\n=CRPA selects\nconstrained RPA alculations\n.\n\nImportant:\navailable as of VASP.6.4:\n\nALGO\n=EVGW0R selects the low-scaling analog of EVGW0, that is the low-scaling partially self-consistent GW calculations, where non-interacting\nG\nand\nW\nare determined from Kohn-Sham system and\nNELMGW\nspecifies the number of self-consistent loops for\nG\n.\nW\nis kept on the Kohn-Sham level.\n\nRelated tags and sections\n\nIALGO\n,\nLDIAG\n,\nElectronic minimization\n\nExamples that use this tag",
    "related_tags": []
  },
  "ALPHA_VDW": {
    "default_value": "Default: ALPHA_VDW = 0.94950 for IVDW_NL =3 or | = 0.28248 for IVDW_NL =4",
    "description": "Specify α {\\displaystyle \\alpha} in vdW-DF3-opt1/vdW-DF3-opt2.",
    "detailed_description": "The\nALPHA_VDW\ntag allows to specify the value of the parameter\nα\n{\\displaystyle \\alpha}\nin the kernel of the vdW-DF3-opt1/vdW-DF3-opt2 nonlocal van der Waals functionals.\n[1]",
    "related_tags": [
      "GAMMA_VDW",
      "PARAM1",
      "PARAM2",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "AMGGAC": {
    "default_value": "Default: AMGGAC = 1.0 if LHFCALC = {\\displaystyle =} .FALSE. or AEXX ≠ {\\displaystyle \\neq} 1.0 | = 0.0 if LHFCALC = {\\displaystyle =} .TRUE. and AEXX = {\\displaystyle =} 1.0",
    "description": "AMGGAC is a parameter that multiplies the meta-GGA correlation functional (available as of VASP.6.4.0).",
    "detailed_description": "AMGGAC\ncan be used as the fraction of  meta-GGA correlation in a Hartree-Fock/DFT hybrid functional.\n\nMind:\nNote the difference with respect to\nAGGAC\n:\nAMGGAC\nmultiplies the whole meta-GGA correlation functional, while\nAGGAC\nmultiplies only the gradient-correction term of a GGA correlation functional.",
    "related_tags": [
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "LHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "AMGGAX": {
    "default_value": "Default: AMGGAX = 1.0- AEXX if LHFCALC =.TRUE. | = 1.0 if LHFCALC =.FALSE.",
    "description": "AMGGAX is a parameter that multiplies the meta-GGA exchange functional (available as of VASP.6.4.0).",
    "detailed_description": "AMGGAX\ncan be used as the fraction of meta-GGA exchange in a Hartree-Fock/DFT hybrid functional (possible since VASP.6.4.0).\n\nImportant:\nAMGGAX\ncan be used only if\nLHFCALC\n=.TRUE.\n\nMind:\nNote the difference with respect to\nAGGAX\n:\nAMGGAX\nmultiplies the whole meta-GGA exchange functional, while\nAGGAX\nmultiplies only the gradient-correction term of a GGA exchange functional.\nAMGGAX\nis implemented for the functionals from Libxc (see\nLIBXC1\nfor details).",
    "related_tags": [
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAC",
      "LHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "AMIN": {
    "default_value": "AMIN = min(0.1, AMIX , AMIX_MAG )",
    "description": "AMIN specifies the minimal mixing parameter in Kerker's initial approximation [1] to the charge-dielectric function used in the Broyden [2] [3] /Pulay [4] mixing scheme ( IMIX =4, INIMIX =1).",
    "detailed_description": "Kerker's initial approximation\n[1]\nfor the charge-dielectric function is given by\n\nmax\n(\nA\nG\n2\nG\n2\n+\nB\n2\n,\nA\nm\ni\nn\n)\n,\n{\\displaystyle \\max\\left(\\frac{AG^2}{G^2+B^2},A_{\\rm min}\\right),}\n\nwhere\nA\n{\\displaystyle A}\n=\nAMIX\n,\nB\n{\\displaystyle B}\n=\nBMIX\n, and\nA\nm\ni\nn\n{\\displaystyle A_{\\rm min}}\n=\nAMIN\n.",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "MAXMIX",
      "AMIX",
      "BMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "MIXPRE",
      "WC"
    ]
  },
  "AMIX": {
    "default_value": "Default: AMIX = 0.8 if ISPIN =1 and one uses US-PPs | = 0.4 if ISPIN =2 and one uses US-PPs | = 0.4 if one uses PAW datasets",
    "description": "AMIX specifies the linear mixing parameter.",
    "detailed_description": "In VASP the eigenvalue spectrum of the charge dielectric matrix is calculated and written to the\nOUTCAR\nfile at each electronic step. This allows a rather easy optimization of the mixing parameters, if required. Search in the\nOUTCAR\nfile for\n\neigenvalues of (default mixing * dielectric matrix)\n\nThe parameters for the mixing are optimal if the mean eigenvalue Γ\nmean\n=1, and if the width of the eigenvalue spectrum is minimal. For an initial linear mixing (\nBMIX\n≈0) an optimal setting for\nAMIX\ncan be found easily by setting\nAMIX\noptimal\n=\nAMIX\ncurrent\n*Γ\nmean\n. For the Kerker scheme (\nIMIX\n=1) either\nAMIX\nor\nBMIX\ncan be optimized, but we recommend to change only\nBMIX\nand keep\nAMIX\nfixed (you must decrease\nBMIX\nif the mean eigenvalue is larger than one, and increase\nBMIX\nif the mean eigenvalue Γ\nmean\n<1).\nHowever, the optimal\nAMIX\ndepends very much on the system, for metals this parameter usually has to be rather small, e.g. AMIX= 0.02.",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "MAXMIX",
      "BMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC"
    ]
  },
  "AMIX_MAG": {
    "default_value": "AMIX_MAG = 1.6",
    "description": "Linear mixing parameter for the magnetization density.",
    "detailed_description": "The default mixing parameters for spinpolarized calculations are:\n\nIMIX\n=4,\nAMIX\n=0.4,\nAMIN\n=min(0.1,\nAMIX\n,\nAMIX_MAG\n),\nBMIX\n=1.0,\nAMIX_MAG\n=1.6, and\nBMIX_MAG\n=1.0.\n\nThese settings are consistent with an (initial) spin enhancement factor of 4, which is usually a reasonable approximation.\n\nThere are only a few other parameter combinations that can be tried if convergence turns out to be very slow. In particular, for slabs, magnetic systems, and insulating systems (e.g. molecules and clusters), an initial \"linear mixing\" can result in faster convergence than the Kerker model function.\n[1]\nOne can therefore try to use the following setting\n\nAMIX\n= 0.2\nBMIX\n= 0.0001 ! almost zero, but 0 will crash some versions\nAMIX_MAG = 0.8\nBMIX_MAG\n= 0.0001 ! almost zero, but 0 will crash some versions\n\nMind:\nFor spin-polarized calculations the defaults for the mixing parameters\nAMIX\nand\nBMIX\nare different than for the non-spin-polarized case.",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "MAXMIX",
      "AMIX",
      "BMIX",
      "BMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC",
      "↑",
      "G. P. Kerker, Efficient iteration scheme for self-consistent pseudopotential calculations , Phys. Rev. B 23 , 3082 (1981)."
    ]
  },
  "ANDERSEN_PROB": {
    "default_value": "ANDERSEN_PROB = 0",
    "description": "ANDERSEN_PROB sets the collision probability for the Anderson thermostat (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "In the approach proposed by Andersen\n[1]\nthe system is thermally coupled to a fictitious heat bath with the desired temperature. The coupling is represented by stochastic impulsive forces that act occasionally on randomly selected particles. The collision probability is defined as an average number of collisions per atom and time-step. This quantity can be controlled by the flag\nANDERSEN_PROB\n. The total number of collisions with the heat-bath is written in the file\nREPORT\nfor each MD step.\n\nTip:\nSetting\nANDERSEN_PROB\n=0,\ni.e.\n, no collisions with the heat-bath) generates the microcanonical (\nNVE\n) ensemble.",
    "related_tags": [
      "MDALGO"
    ]
  },
  "ANTIRES": {
    "default_value": "ANTIRES = 0",
    "description": "ANTIRES determines whether the Tamm-Dancoff approximation is used or not.",
    "detailed_description": "ANTIRES\n=0 Tamm-Dancoff approximation (TDA)\nANTIRES\n=1 yields exact results at ω=0 at roughly the same cost  as TDA\nANTIRES\n=2 beyond Tamm-Dancoff, coupling between positive and negative frequencies\n\nVASP uses the procedures outlined in reference\n[1]\nto include contributions beyond TDA. Beyond-TDA calculations increase the computational time and memory requirements by typically a factor of 2.",
    "related_tags": [
      "BSE calculations"
    ]
  },
  "APACO": {
    "default_value": "APACO = 10",
    "description": "APACO sets the maximum distance in the evaluation of the pair-correlation function (in Å).",
    "detailed_description": "VASP evaluates the pair-correlation function each\nNBLOCK\nsteps and writes it after\nNBLOCK\n×\nKBLOCK\nsteps to the\nPCDAT\nfile.",
    "related_tags": [
      "NPACO",
      "NBLOCK",
      "KBLOCK",
      "PCDAT"
    ]
  },
  "BANDGAP": {
    "default_value": "BANDGAP = COMPACT",
    "description": "BANDGAP determines the verbosity for reporting the bandgap to the OUTCAR file. Only the first character is significant.",
    "detailed_description": "For semiconductors, the direct and fundamental bandgap have a clear definition. For semimetals, the Fermi energy cuts through bands so depending on the method one defines either a zero or a negative fundamental bandgap. For metals, defining a bandgap is not meaningful.\n\nThe bandgap of the system separates the occupied valence bands from the unoccupied conduction bands.\nOf particular interest are the fundamental bandgap between valence band maximum (VBM) and conduction band minimum (CBM) and the direct bandgap at a single\nk\npoint.\n\nBANDGAP\ncontrols how VASP reports the bandgap information.\nThe following options exist:\n\nBANDGAP\n=COMPACT\n\nUses Fermi weights to decide what valence and conduction bands are. Reports the VBM, CBM, and fundamental gap to the OUTCAR file.\n\nBANDGAP\n=WEIGHT\n\nUses Fermi weights to decide what valence and conduction bands are. Provides a comprehensive report of all band extrema.\n\nBANDGAP\n=KPOINT\n\nConsiders each\nk\npoint individually to decide what valence and conduction bands are. Provides a comprehensive report of all band extrema.\n\nDifference between WEIGHT and KPOINT\n\nThe figure illustrates different possible properties of electronic band structures.\nFor semiconductors, the bandgap is well defined so that the choice of\nBANDGAP\nonly affects whether the output is compact or verbose.\nFor metals, there is no straightforward definition of a bandgap so the default of\nBANDGAP\n=COMPACT is sufficient.\nA semimetal shares properties with metals (Fermi energy crosses bands) and with semiconductors (visible bandgap in the band structure).\n\nBANDGAP\n=WEIGHT interprets systems like a metal; valence (conduction) states are more (less) than half-filled.\nIn this case, the bandgap of a semimetal converges to zero with an increasing number of\nk\npoints similar to a metal.\nFor N number of electrons, the number of valence states is not in general equal to N for all\nk\npoints.\nHence, the direct bandgap is not necessarily between the N-th and the (N + 1)-th state.\n\nBANDGAP\n=KPOINT considers systems like a semiconductor where every\nk\npoint may be treated individually.\nThe number of valence bands is equal to the number of electrons N for all\nk\npoints and the direct bandgap is equal to the smallest difference between the N-th and (N + 1)-th state.\nIn a semimetal, this approach produces a negative bandgap because the Fermi energy crosses the bands.\nFor collinear calculations (\nISPIN\n=2), this method will allow for a different number of up and down electrons at every\nk\npoint.\n\nMind:\nSetting\nBANDGAP\n=KPOINT only impacts the output of VASP. It is not considered when evaluating the occupations of different bands. If you want to enforce certain occupations, please consider the tags\nNUPDOWN\n,\nFERWE\n, and\nFERDO\n.\n\nExample of the verbose output\n\nBand structure\n--------------\n                       spin independent             spin component 1             spin component 2\nval. band max:               9.679953                     9.679953                     5.987917\ncond. band min:              9.148387                    10.409707                     9.148387\nfundamental gap:            -0.531566                     0.729754                     3.160470\nVBM @ kpoint:       0.2949   0.4423   0.1474     0.2949   0.4423   0.1474     0.0000  -0.0000   0.0000\nCBM @ kpoint:       0.5000   0.5000   0.0000     0.0000   0.0000   0.0000     0.5000   0.5000   0.0000\n\nlower band:                  8.126216                     7.283444                     5.087674\nupper band:                  9.386102                    10.916258                     9.148387\ndirect gap:                  1.259885                     3.632813                     4.060713\n@ kpoint:           0.3846   0.3846   0.0000     0.0641   0.0962   0.0321     0.5000   0.5000   0.0000\n\nThe column\nspin independent\nis always present and reports the bandgap ignoring the spin of the electron.\nThe other two columns are only visible for\nISPIN\n=2 and describe the bandgap for a given spin of the electron.\nThe first block of rows show the band edges of the fundamental bandgap and their corresponding\nk\n-point coordinates.\nThe second block reports analogous values for the direct gap.\nIn each case the energy difference of the band edges is computed and printed as fundamental and direct gap, respectively.",
    "related_tags": [
      "EFERMI",
      "ISMEAR",
      "SIGMA"
    ]
  },
  "BEXT": {
    "default_value": "Default: BEXT = 0.0 if ISPIN =2 | = 3*0.0 if LNONCOLLINEAR =.TRUE. | = N/A else",
    "description": "Specifies an external magnetic field in eV.",
    "detailed_description": "BEXT\ntag sets an external magnetic field that acts on the electrons in a Zeeman-like manner.\nAn additional potential of the following form carries this interaction:\n\nFor spin-polarized calculations (\nISPIN\n= 2):\n\nV\n↑\n=\nV\n↑\n+\nB\ne\nx\nt\n{\\displaystyle \nV^{\\uparrow} = V^{\\uparrow} + B_{\\rm ext}\n}\nV\n↓\n=\nV\n↓\n−\nB\ne\nx\nt\n{\\displaystyle \nV^{\\downarrow} = V^{\\downarrow} - B_{\\rm ext}\n}\nand\nB\ne\nx\nt\n{\\displaystyle B_{\\rm ext}}\n=\nBEXT\n(in eV).\n\nFor noncollinear calculations (\nLNONCOLLINEAR\n= .TRUE.):\n\nV\nα\nβ\n=\nV\nα\nβ\n+\nB\ne\nx\nt\n⋅\nσ\nα\nβ\n{\\displaystyle \nV_{\\alpha\\beta} = V_{\\alpha\\beta} + \\mathbf{B}_{\\rm ext} \\cdot \\mathbf{\\sigma}_{\\alpha \\beta}\n}\n\nwhere\nB\ne\nx\nt\n=\n(\nB\ne\nx\nt\n1\n,\nB\ne\nx\nt\n2\n,\nB\ne\nx\nt\n3\n)\nT\n{\\displaystyle \\mathbf{B}_{\\rm ext}=({B}^1_{\\rm ext}, {B}^2_{\\rm ext}, {B}^3_{\\rm ext})^T}\nis given by\n\nBEXT\n= B1 B2 B3 ! in eV\n\nand\nσ\n{\\displaystyle \\mathbf{\\sigma}}\nis the vector of Pauli matrices (\nSAXIS\n, default:\nσ\n1\n=\nx\n^\n{\\displaystyle \\sigma_1=\\hat x}\n,\nσ\n2\n=\ny\n^\n{\\displaystyle \\sigma_2 =\\hat y}\n,\nσ\n3\n=\nz\n^\n{\\displaystyle \\sigma_3 = \\hat z}\n).\n\nThe effect of the above is most easily understood for the collinear case (\nISPIN\n=2):\nThe eigenenergies of spin-up states are raised by\nB\ne\nx\nt\n{\\displaystyle B_{\\rm ext}}\neV, whereas the eigenenergies of spin-down states are lowered by the same amount. The total energy changes by:\n\nΔ\nE\n=\n(\nn\n↑\n−\nn\n↓\n)\nB\ne\nx\nt\n{\\displaystyle \\Delta E = (n^{\\uparrow} - n^{\\downarrow}) B_{\\rm ext}\n}\neV\n\nwhere\nn\n↑\n{\\displaystyle n^{\\uparrow}}\nand\nn\n↓\n{\\displaystyle n^{\\downarrow}}\nare the number of up- and down-spin electrons in the system.\n\nBEXT\nis applied during the self-consistent\nelectronic minimization\nand effectively shifts the eigenenergies of the spin-up and spin-down states w.r.t. each other at each step. Consequently, the electrons redistribute (changing the occupancies)\nand\nthe density changes. The change in the density (,e.g., charge density and magnetization) also affects the scf potential and KS orbitals. For a rigid-band Zeeman splitting, converge the charge density with\nBEXT\n=0 and restart with\nBEXT\n≠\n{\\displaystyle \\neq}\n0 and fixed charge density (\nICHARG\n=11).\n\nUnits\n\nFor an applied magnetic field\nB\n0\n{\\displaystyle B_0}\n, the energy difference between two Zeeman-splitted electronic states is given by:\n\nℏ\nω\n=\ng\ne\nμ\nB\nB\n0\n,\n{\\displaystyle \n\\hbar \\omega = g_e \\mu_B B_0,\n}\n\nwhere\nμ\nB\n{\\displaystyle \\mu_B}\nis the Bohr magneton and\ng\ne\n{\\displaystyle g_e}\nis the electron spin\ng\n-factor.\n\nFor\nISPIN\n=2, rigid-band Zeeman-splitted states imply:\n\nV\n↑\n−\nV\n↓\n=\n2\nB\ne\nx\nt\n{\\displaystyle \nV^{\\uparrow} - V^{\\downarrow}  = 2 B_{\\rm ext}\n}\n\nThis leads to the following relationship between our definition of\nB\ne\nx\nt\n{\\displaystyle B_{\\rm ext}}\n(in eV) and the magnetic field\nB\n0\n{\\displaystyle B_0}\n(in T):\n\nB\n0\n=\n2\nB\ne\nx\nt\ng\ne\nμ\nB\n{\\displaystyle \nB_0 = \\frac{2 B_{\\rm ext}}{g_e \\mu_B}\n}\n\nwhere\nμ\nB\n{\\displaystyle \\mu_B}\n= 5.788 381 8060 x 10\n-5\neV T\n-1\n, and\ng\ne\n{\\displaystyle g_e}\n= 2.002 319 304 362 56.",
    "related_tags": [
      "ISPIN",
      "LNONCOLLINEAR",
      "SAXIS"
    ]
  },
  "BMIX": {
    "default_value": "BMIX = 1.0",
    "description": "BMIX sets the cutoff wave vector for Kerker mixing scheme ( IMIX =1 and/or INIMIX =1).",
    "detailed_description": "The mixed density is given by\n\nρ\nm\ni\nx\n(\nG\n)\n=\nρ\ni\nn\n(\nG\n)\n+\nA\nG\n2\nG\n2\n+\nB\n2\n(\nρ\no\nu\nt\n(\nG\n)\n−\nρ\ni\nn\n(\nG\n)\n)\n{\\displaystyle \\rho_{\\rm mix}\\left(G\\right)=\\rho_{\\rm in}\\left(G\\right)+A \\frac{G^2}{G^2+B^2}\\Bigl(\\rho_{\\rm out}\\left(G\\right)-\\rho_{\\rm in}\\left(G\\right)\\Bigr)}\n\nwith\nA\n{\\displaystyle A}\n=\nAMIX\nand\nB\n{\\displaystyle B}\n=\nBMIX\n\nIn VASP the eigenvalue spectrum of the charge dielectric matrix is calculated and written to the\nOUTCAR\nfile at each electronic step. This allows a rather easy optimization of the mixing parameters, if required. Search in the\nOUTCAR\nfile for\n\neigenvalues of (default mixing * dielectric matrix)\n\nThe parameters for the mixing are optimal if the mean eigenvalue Γ\nmean\n=1, and if the width of the eigenvalue spectrum is minimal. For an initial linear mixing (\nBMIX\n≈0) an optimal setting for\nAMIX\ncan be found easily by setting\nAMIX\noptimal\n=\nAMIX\ncurrent\n*Γ\nmean\n. For the Kerker scheme (\nIMIX\n=1) either\nAMIX\nor\nBMIX\ncan be optimized, but we recommend to change only\nBMIX\nand keep\nAMIX\nfixed (you must decrease\nBMIX\nif the mean eigenvalue is larger than one, and increase\nBMIX\nif the mean eigenvalue Γ\nmean\n<1).",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "MAXMIX",
      "AMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC"
    ]
  },
  "BMIX_MAG": {
    "default_value": "BMIX_MAG = 1.0",
    "description": "Sets the cutoff wave vector for Kerker mixing scheme ( IMIX =1 and/or INIMIX =1) for the magnetization density [1] .",
    "detailed_description": "The default mixing parameters for spinpolarized calculations are:\n\nIMIX\n=4,\nAMIX\n=0.4,\nAMIN\n=min(0.1,\nAMIX\n,\nAMIX_MAG\n),\nBMIX\n=1.0,\nAMIX_MAG\n=1.6, and\nBMIX_MAG\n=1.0.\n\nThese settings are consistent with an (initial) spin enhancement factor of 4, which is usually a reasonable approximation.\n\nThere are only a few other parameter combinitions which can be tried, if convergence turns out to be very slow. In particular, for slabs, magnetic systems and insulating systems (e.g. molecules and clusters), an initial \"linear mixing\" can result in faster convergence than the Kerker model function\n[1]\n. One can therefore try to use the following setting\n\nAMIX\n= 0.2\nBMIX\n= 0.0001 ! almost zero, but 0 will crash some versions\nAMIX_MAG\n= 0.8\nBMIX_MAG\n= 0.0001 ! almost zero, but 0 will crash some versions\n\nMind\n: For spinpolarized calculations the defaults for the mixing parameters\nAMIX\nand\nBMIX\nare different than for the non-spinpolarized case.",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "MAXMIX",
      "AMIX",
      "BMIX",
      "AMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC"
    ]
  },
  "BPARAM": {
    "default_value": "BPARAM = 6.3",
    "description": "The tag BPARAM specifies the value of the parameter b {\\displaystyle b} in the kernel of the nonlocal rVV10 correlation functional.",
    "detailed_description": "BPARAM\nshould be set to 6.3, 15.7, 10, or 11.95 for the rVV10,\n[1]\nSCAN+rVV10,\n[2]\nPBE+rVV10L,\n[3]\nand r\n2\n{\\displaystyle ^2}\nSCAN+rVV10\n[4]\nfunctionals, respectively.",
    "related_tags": [
      "CPARAM",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "BSEELECTRON": {
    "default_value": "",
    "description": "BSEELECTRON sets the coordinates of the fixed electron of the exciton wavefunction",
    "detailed_description": "If\nBSEELECTRON\nis set in a BSE calculation, VASP computes exciton wavefunction for the first\nNBSEEIG\nstates.\nThe coordinates are provided in direct (fractional) coordinates.\n\nWhen fixing the position of the particle, ensure that it is not fixed exactly at the center of an atom or coincides with a node of the wavefunction. To avoid that, shift the fixed coordinate slightly away from the center of the atom. Furthermore, the wavefunction of the fixed particle is taken at the nearest\nG\n{\\displaystyle \\mathbf{G}}\n-vector, whose exact position is written in the\nOUTCAR\nfile\n\nhole position is fixed at:\n\nor\n\nelectron position is fixed at:\n\nRelated tags and sections\n\nBSEHOLE\n,\nNBSEEIG\n,\nBSE calculations\n,\nPlotting exciton wavefunction",
    "related_tags": []
  },
  "BSEHOLE": {
    "default_value": "",
    "description": "BSEHOLE sets the coordinates of the fixed hole of the exciton wavefunction",
    "detailed_description": "If\nBSEHOLE\nis set in a BSE calculation, VASP computes exciton wavefunction for the first\nNBSEEIG\nstates.\nThe coordinates are provided in direct (fractional) coordinates.\n\nWhen fixing the position of the particle, ensure that it is not fixed exactly at the center of an atom or coincides with a node of the wavefunction. To avoid that, shift the fixed coordinate slightly away from the center of the atom. Furthermore, the wavefunction of the fixed particle is taken at the nearest\nG\n{\\displaystyle \\mathbf{G}}\n-vector, whose exact position is written in the\nOUTCAR\nfile\n\nhole position is fixed at:\n\nor\n\nelectron position is fixed at:\n\nRelated tags and sections\n\nBSEELECTRON\n,\nNBSEEIG\n,\nBSE calculations\n,\nPlotting exciton wavefunction",
    "related_tags": []
  },
  "BSEPREC": {
    "default_value": "BSEPREC = Medium",
    "description": "BSEPREC determines the precision of the time-evolution algorithm for solving the Bethe-Salpeter or Casida equations, i.e., the timestep and the number of steps.",
    "detailed_description": "The timestep in the time-evolution calculation is inversely proportional to the maximum transition energy\nOMEGAMAX\nand the number of steps is inversely proportional to the broadening\nCSHIFT\n. Depending on the\nBSEPREC\nstable these parameters are scaled depending on the precision tag\nBSEPREC\n.\n\nBSEPREC\nOMEGAMAX\nCSHIFT\nAccurate (a)\n×\n4\n{\\displaystyle \\times 4}\n×\n1\n/\n10\n{\\displaystyle \\times 1/10}\nHigh (h)\n×\n3\n{\\displaystyle \\times 3}\n×\n1\n/\n7.5\n{\\displaystyle \\times 1/7.5}\nMedium (m)\n×\n2.5\n{\\displaystyle \\times 2.5}\n×\n1\n/\n6.25\n{\\displaystyle \\times1/6.25}\nLow (l)\n×\n2\n{\\displaystyle \\times 2}\n×\n1\n/\n5\n{\\displaystyle \\times1/5}\n\nFor example, the number of steps\nN\ns\nt\ne\np\ns\n{\\displaystyle N_{\\rm steps}}\nfor\nBSEPREC\n= Low can be found via\nN\ns\nt\ne\np\ns\n=\nO\nM\nE\nG\nA\nM\nA\nX\n×\n2\nC\nS\nH\nI\nF\nT\n/\n5\n{\\displaystyle N_{\\rm steps}=\\frac{{\\rm OMEGAMAX}\\times 2}{{\\rm CSHIFT}/5}}\n\nRelated tag and articles\n\nIBSE\n,\nNBANDSV\n,\nNBANDSO\n,\nCSHIFT\n,\nOMEGAMAX\n,\nBSE calculations\n,\nTime-dependent density-functional theory calculations\n,\nBethe-Salpeter equations",
    "related_tags": []
  },
  "CH_AMPLIFICATION": {
    "default_value": "CH_AMPLIFICATION = 1.0",
    "description": "This tag is used to scale (amplify) the calculated dielectric function within the supercell core-hole method and the BSE+GW method for core electrons.",
    "detailed_description": "",
    "related_tags": [
      "CH_LSPEC",
      "CH_NEDOS",
      "ICORELEVEL",
      "CLNT",
      "CLN",
      "CLL",
      "CLZ",
      "CH_SIGMA"
    ]
  },
  "CH_LSPEC": {
    "default_value": "CH_LSPEC = .FALSE.",
    "description": "This flag controls whether the dielecectric function using the supercell core-hole method is calculated or not.",
    "detailed_description": "How to calculate X-ray absorption spectra from the supercell core-hole method are is explained\nhere\n.\n\nThis tag should be used in combination with the following important tags for the core-hole approximation:\n\nICORELEVEL\n: To enable core-hole calculations in the final-state approximation with self-consistent field cycles (SCF) one has to set\nICORELEVEL\n=2. Core-hole calculations in the initial-state approximation (\nICORELEVEL\n=1) are also available, but they are physically less relevant and should be only used if especially needed.\nCLNT\n: This tag selects the species holding the core hole. This number corresponds to the species defined in the\nPOSCAR\nand\nPOTCAR\nfiles.\nCLN\n: Specifies the\nn\n{\\displaystyle n}\nquantum number of the excited electron.\nCLL\n: Specifies the\nl\n{\\displaystyle l}\nquantum number of the excited electron.\nCLZ\n: Specifies how much of a faction of the chosen electron should be excited. Usually one always sets\nCLZ\n=1.0, but in some cases values lesser than 1 can lead to better agreement with experiment. However, this should be handled with caution since the physics behind is very dubious.\n\nAnd following tags to control the calculation of the dieletric function:\n\nCH_SIGMA\n: The broadening of the spectrum is by default of Gaussian form and the broadening width in eV is set by\nCH_SIGMA\n. We recommend using a very small broadening\nCH_SIGMA\n≤\n{\\displaystyle \\le}\n0.001 in the calculations and to broaden the spectrum in post-processing. Also, the spectrum can be recalculated with different parameters without the need to redo the electronic self-consistent field cycle. For that one can use the converged\nWAVECAR\nfrom the previous calculation and set\nALGO\n=\nNone\ntogether with the new parameters for the spectrum \"CH_*\" in the\nINCAR\nfile.\nCH_NEDOS\n: Sets the number of grid points on the energy axis of the spectrum.\nCH_AMPLIFICATION\n: Scaling of the spectrum by the specified value. This tag is not important but can be useful sometimes if one needs to scale the spectrum a priori. Otherwise, it is recommended to scale the spectrum a posteriori.\n\nWarning:\nFor XAS calculations it is strongly recommended to use the available GW PAW potentials for the\nPOTCAR\nfiles, since many standard potentials don't have projectors with quantum numbers 2 or larger and the GW potentials are more exact for excited states than the standard potentials.",
    "related_tags": [
      "CH_SIGMA",
      "CH_NEDOS",
      "CH_AMPLIFICATION",
      "ICORELEVEL",
      "CLNT",
      "CLN",
      "CLL",
      "CLZ",
      "ISMEAR"
    ]
  },
  "CH_NEDOS": {
    "default_value": "CH_NEDOS = 1000",
    "description": "This tag specifies the number of frequency (energy) grid points on the x-axis in the calculation of the dielectric function in the supercell core-hole method.",
    "detailed_description": "",
    "related_tags": [
      "CH_LSPEC",
      "CH_SIGMA",
      "CH_AMPLIFICATION",
      "ICORELEVEL",
      "CLNT",
      "CLN",
      "CLL",
      "CLZ"
    ]
  },
  "CH_SIGMA": {
    "default_value": "CH_SIGMA = 0.3",
    "description": "This tag specifies the width of the Gaussian broadening in eV of the imaginary dielectric function within the supercell core-hole method.",
    "detailed_description": "At the moment only Gaussian broadening of the dielectric function is implemented within the supercell core-hole method.",
    "related_tags": [
      "CH_LSPEC",
      "CH_NEDOS",
      "CH_AMPLIFICATION",
      "ICORELEVEL",
      "CLNT",
      "CLN",
      "CLL",
      "CLZ"
    ]
  },
  "CLL": {
    "default_value": "Default: CLL = 0",
    "description": "CLL selects the angular quantum number l {\\displaystyle l} of the excited core electron when using ICORELEVEL >0.",
    "detailed_description": "Mind:\nCurrently the spin-orbit coupling is only supported in the valence and conduction states but not in the core states. Hence, the splitting of an absorption edge with the orbital quantum number L>0 is not captured. For example, the splitting to\nL2\nand\nL3\n-edges is not captured in the calculations and instead, a single\nL\n-edge is shown.",
    "related_tags": [
      "ICORELEVEL",
      "CLZ",
      "CLNT",
      "CLN",
      "CLL",
      "LADDER",
      "LHARTREE",
      "NBANDSV",
      "NBANDSO",
      "OMEGAMAX",
      "ANTIRES"
    ]
  },
  "CLN": {
    "default_value": "Default: CLN = 1",
    "description": "CLN selects the main quantum number n {\\displaystyle n} of the excited core electron when using ICORELEVEL >0.",
    "detailed_description": "Mind:\nCurrently the spin-orbit coupling is only supported in the valence and conduction states but not in the core states. Hence, the splitting of an absorption edge with the orbital quantum number L>0 is not captured. For example, the splitting to\nL2\nand\nL3\n-edges is not captured in the calculations and instead, a single\nL\n-edge is shown.",
    "related_tags": [
      "ICORELEVEL",
      "CLNT",
      "CLN",
      "CLL",
      "LADDER",
      "LHARTREE",
      "NBANDSV",
      "NBANDSO",
      "OMEGAMAX",
      "ANTIRES"
    ]
  },
  "CLNT": {
    "default_value": "Default: CLNT = 1",
    "description": "CLNT selects the type of the excited atoms in XAS calculations with ICORELEVEL >0.",
    "detailed_description": "All atoms of the selected type are excited in the XAS calculation with\nICORELEVEL\n=2. Hence, it is recommended that the  excited atom is separated into a dedicated type with a single atom. Exciting multiple atoms in the supercell core-hole approach causes the interaction between core holes in neighboring atoms and should be avoided. Exciting multiple atoms in BSE proportionately increases the number of core states included in the BSE Hamiltonian and, hence, increases the computational cost of the calculation.\n\nSee a detailed description on how to set this tag in the\nSCH\nand\nBSE\ncalculations.",
    "related_tags": [
      "ICORELEVEL",
      "CLN",
      "CLL",
      "CLZ"
    ]
  },
  "CLZ": {
    "default_value": "Default: CLZ = 0",
    "description": "CLZ selects a fractional or the full electron charge for the core hole in the core-excitation calculations with ICORELEVEL =2.",
    "detailed_description": "In\nSCH\nCLZ\ncan be used to introduce a fraction of the core hole. For example, a half-core hole can be created to simulate a transition state in the X-ray excitation process.",
    "related_tags": [
      "ICORELEVEL",
      "CLNT",
      "CLN",
      "CLL",
      "LADDER",
      "LHARTREE",
      "NBANDSV",
      "NBANDSO",
      "OMEGAMAX",
      "ANTIRES"
    ]
  },
  "CMBJ": {
    "default_value": "CMBJ = calculated self-consistently",
    "description": "defines the c {\\displaystyle c} parameter in the MBJ potential.",
    "detailed_description": "The\nCMBJ\ntag can be set in the following ways:\n\nSpecify a constant that is used at every point of space\nr\n{\\displaystyle \\mathbf{r}}\nCMBJ = c\n\nSpecify one entry per atomic type\nCMBJ = c_1 c_2 .. c_n\nwhere the order and number\nn\n{\\displaystyle n}\nis in accordance with atomic types in your\nPOSCAR\nfile. The MBJ exchange potential at a point\nr\n{\\displaystyle \\mathbf{r}}\nwill then be calculated using the parameter\nc\ni\n{\\displaystyle c_{i}}\nbelonging to the atomic species of the atomic site nearest to\nr\n{\\displaystyle \\mathbf{r}}\n.\n\nIf\nCMBJ\nis not set,\nc\n{\\displaystyle c}\nis calculated at each electronic step as the average of\n|\n∇\nn\n|\n/\nn\n{\\displaystyle \\left\\vert\\nabla n\\right\\vert/n}\nin the unit cell, as explained in the description of the\nMETAGGA\ntag.",
    "related_tags": [
      "METAGGA",
      "CMBJA",
      "CMBJB",
      "CMBJE",
      "SMBJ",
      "RSMBJ",
      "LASPH",
      "LMAXTAU",
      "LMIXTAU"
    ]
  },
  "CMBJA": {
    "default_value": "Default: CMBJA = −0.012 if METAGGA =MBJ | = 0.488 if METAGGA =LMBJ",
    "description": "sets the α {\\displaystyle \\alpha} parameter in the MBJ and LMBJ potentials.",
    "detailed_description": "See the description of the\nMETAGGA\ntag.",
    "related_tags": [
      "METAGGA",
      "CMBJ",
      "CMBJB",
      "CMBJE",
      "SMBJ",
      "RSMBJ",
      "LASPH",
      "LMAXTAU",
      "LMIXTAU"
    ]
  },
  "CMBJB": {
    "default_value": "Default: CMBJB = 1.023 if METAGGA =MBJ | = 0.5 if METAGGA =LMBJ",
    "description": "sets the β {\\displaystyle \\beta} parameter in the MBJ and LMBJ potentials.",
    "detailed_description": "See the description of the\nMETAGGA\ntag.",
    "related_tags": [
      "METAGGA",
      "CMBJ",
      "CMBJA",
      "CMBJE",
      "SMBJ",
      "RSMBJ",
      "LASPH",
      "LMAXTAU",
      "LMIXTAU"
    ]
  },
  "CMBJE": {
    "default_value": "CMBJE = 0.5",
    "description": "sets the e {\\displaystyle e} parameter in the MBJ and local MBJ potentials.",
    "detailed_description": "See the description of the\nMETAGGA\ntag.",
    "related_tags": [
      "METAGGA",
      "CMBJ",
      "CMBJA",
      "CMBJB",
      "SMBJ",
      "RSMBJ",
      "LASPH",
      "LMAXTAU",
      "LMIXTAU"
    ]
  },
  "CPARAM": {
    "default_value": "CPARAM = 0.0093",
    "description": "The tag CPARAM allows to specify the value of the parameter C {\\displaystyle C} in the kernel of the nonlocal rVV10 correlation functional. [1]",
    "detailed_description": "",
    "related_tags": [
      "BPARAM",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "CSHIFT": {
    "default_value": "Default: CSHIFT = 0.1 for LOPTICS | = OMEGAMAX *1.3 / max( NOMEGA ,40) for GW calculations | = 0.1 for BSE calculations / Casida TDDFT calculations | = 0.1 for Time Evolution TDDFT calculations",
    "description": "CSHIFT sets a Lorentzian broadening in eV of the dielectric tensor via the complex shift η in the Kramers-Kronig transformation of the response function.",
    "detailed_description": "The default\nCSHIFT\n=0.1 is perfectly acceptable for most calculations and causes a slight smoothing of the real part of the dielectric function. If the gap is very small (i.e. approaching two times\nCSHIFT\n), slight inaccuracies in the static dielectric constant are possible, which can be remedied by decreasing\nCSHIFT\n. If\nCSHIFT\nis further decreased, it is strongly recommended to increase the frequency grid by setting\nNEDOS\nto values around 2000.\n\nMind:\nFor the quartic-scaling GW algorithm, one should manually check that\nCSHIFT\nis at least as large as the grid spacing at low frequencies. If\nCSHIFT\nis smaller than the grid spacing, the QP energies might show erratic behavior (for instance large re-normalization factors Z).",
    "related_tags": [
      "OMEGAMIN",
      "OMEGAMAX",
      "LOPTICS"
    ]
  },
  "CUTOFF_MU": {
    "default_value": "Default: CUTOFF_MU = 0.8 * Fermi level of a system with NUM_WANN orbitals occupied",
    "description": "CUTOFF_MU specifies the energy cutoff μ {\\displaystyle \\mu} in eV for the function specified by CUTOFF_MU .",
    "detailed_description": "The value\nμ\n{\\displaystyle \\mu}\nof\nCUTOFF_MU\ncorresponds to the energy cutoff of the cutoff function used to obtain Wannier functions with the\none-shot method\n.\nThe meaning of\nμ\n{\\displaystyle \\mu}\ndepends on the\nCUTOFF_TYPE\ntag.\n\nFor spin-polarized calculations (\nISPIN\n= 2\n), two values can be specified for\nCUTOFF_MU\n, one for each spin channel.\nIf only a single value is specified, it will be used for both spin channels.\n\nThe default value is computed by first determining the Fermi level \nof the system if it had\nNUM_WANN\norbitals occupied and multiplying by 0.8. This gives reasonable freedom to determine the unitary transformation\nU\nm\nn\nk\n{\\displaystyle U_{mn\\mathbf{k}}}\nfrom Bloch states to Wannier functions.\n\nTip:\nCareful tuning of this parameter is required to obtain a good Wannierization.",
    "related_tags": [
      "CUTOFF_TYPE",
      "CUTOFF_SIGMA",
      "LSCDM",
      "LOCPROJ"
    ]
  },
  "CUTOFF_SIGMA": {
    "default_value": "Default: CUTOFF_SIGMA = 0.1",
    "description": "CUTOFF_SIGMA specifies the broadening σ {\\displaystyle \\sigma} in eV for the cutoff function specified by CUTOFF_TYPE .",
    "detailed_description": "Corresponds to a broadening of the cutoff function used in the\none-shot method\nto obtain Wannier functions.\nThe meaning of\nσ\n{\\displaystyle \\sigma}\ndepends on the\nCUTOFF_TYPE\ntag.\n\nFor spin-polarized calculations (\nISPIN\n= 2\n), two values can be specified for\nCUTOFF_SIGMA\n, one for each spin channel.\nIf only a single value is specified, it will be used for both spin channels.",
    "related_tags": [
      "CUTOFF_TYPE",
      "CUTOFF_MU",
      "LSCDM",
      "LOCPROJ"
    ]
  },
  "CUTOFF_TYPE": {
    "default_value": "Default: CUTOFF_TYPE = erfc",
    "description": "CUTOFF_TYPE chooses the type of cutoff function to be used before performing the singular-value decomposition (SVD) of the initial projections matrix.",
    "detailed_description": "This tag governs how much weight should be given in the SVD during the\none-shot Wannierization\nto a certain orbital with energy\nϵ\nn\nk\n{\\displaystyle \\epsilon_{n\\mathbf{k}}}\n.\nIf the weight is zero the orbital is not included in the fitting while if it is one it is included with the maximum importance.\nThis behavior is similar to the wannier90 disentanglement window.\n\nIn order to obtain a good Wannierization, a certain level of freedom should be given to the localized orbitals to adequately accommodate the Bloch states.\nApplying a smooth cutoff function from the following table can help achieve this goal by including more states beyond the relevant energy range.\nThis is particularly important for systems with entangled states.\n\nCUTOFF_TYPE\nFunction\nerfc\n1\n2\nerfc\n[\n(\nϵ\nn\nk\n−\nμ\n)\n/\nσ\n]\n{\\displaystyle \\frac{1}{2}\\text{erfc}\\left[(\\epsilon_{n\\mathbf{k}}-\\mu)/\\sigma\\right]}\ngaussian\ne\n−\n(\nϵ\nn\nk\n−\nμ\n)\n2\n/\nσ\n{\\displaystyle e^{-(\\epsilon_{n\\mathbf{k}}-\\mu)^2/\\sigma}}\nfermi\n1\ne\n(\nϵ\nn\nk\n−\nμ\n)\n/\nσ\n+\n1\n{\\displaystyle \\frac{1}{e^{(\\epsilon_{n\\mathbf{k}}-\\mu)/\\sigma}+1}}\n\nwith\nσ\n{\\displaystyle \\sigma}\nspecified by the\nCUTOFF_SIGMA\ntag and\nμ\n{\\displaystyle \\mu}\nby\nCUTOFF_MU\n.\n\nIn addition to the aforementioned cutoff functions, it is also possible to select\nCUTOFF_TYPE\n= num_wann\n.\nThis mode is identical to\nCUTOFF_TYPE\n= erfc\nwith the exception that\nμ\n{\\displaystyle \\mu}\nis set to\nϵ\nN\nk\n{\\displaystyle \\epsilon_{N \\mathbf{k}}}\nat each individual k-point, where\nN\n{\\displaystyle N}\nis the number of Wannier orbitals specified via\nNUM_WANN\n.\nIn this case,\nCUTOFF_MU\nis ignored.",
    "related_tags": [
      "CUTOFF_MU",
      "CUTOFF_SIGMA",
      "LSCDM",
      "LOCPROJ"
    ]
  },
  "Construction_LSCRPA": {
    "default_value": "",
    "description": "",
    "detailed_description": "",
    "related_tags": []
  },
  "DEPER": {
    "default_value": "DEPER = 0.3",
    "description": "DEPER specifies a relative stopping criterion for the optimization of an eigenvalue.",
    "detailed_description": "The tags\nDEPER\n,\nWEIMIN\n, and\nEBREAK\nallow fine tuning of the iterative matrix diagonalization, and are best not changed. They are optimized for a large variety of systems, and changing one of the parameters usually decreases performance or can even screw up the iterative matrix diagonalization totally.\nIn general, these tags control when the optimization of a single band is stopped within the iterative matrix diagonalization schemes:\n\nDEPER\nspecifies a relative break-criterion: the optimization of a band is stopped after the energy change becomes smaller than\nDEPER\nmultiplied with the energy change in the first iterative optimization step. The maximum number of optimization steps is always 4.",
    "related_tags": [
      "WEIMIN",
      "EBREAK"
    ]
  },
  "DIMER_DIST": {
    "default_value": "DIMER_DIST = 0.01",
    "description": "The flag DIMER_DIST defines the step size for the numerical differentiation (in Å {\\displaystyle \\AA} ) for the Improved Dimer Method .",
    "detailed_description": "",
    "related_tags": [
      "Improved Dimer Method"
    ]
  },
  "DIPOL": {
    "default_value": "",
    "description": "specifies the center of the cell in direct lattice coordinates with respect to which the total dipole-moment in the cell is calculated.",
    "detailed_description": "The center of the cell w.r.t. which the total dipole-moment in the cell is calculated is specified as\n\nDIPOL\n=\nR\nx\nR\ny\nR\nz\n\nwhere\nR\nx\n,\nR\ny\nand\nR\nz\nare given in direct lattice coordinates.\n\nCalculations using the dipole correction, i.e. using tags\nIDIPOL\nor\nLDIPOL\n, require a definition of the center of the cell. Results of the computed dipole moment might differ for different positions. The reason for this difference is that the definition of the dipole 'destroys' the translational symmetry, i.e., the dipole is defined as\n\n∫\n(\nr\n−\nR\nc\ne\nn\nt\ne\nr\n)\nρ\ni\no\nn\ns\n+\nv\na\nl\ne\nn\nc\ne\n(\nr\n)\nd\n3\nr\n.\n{\\displaystyle \n\\int ({\\mathbf r}-{\\mathbf R}_{\\rm center}) \\rho_{\\rm ions+valence}({\\mathbf r}) d^3 {\\mathbf r}.\n}\n\nThis measure will provide consistent values only if\nρ\ni\no\nn\ns\n+\nv\na\nl\ne\nn\nc\ne\n{\\displaystyle \\rho_{\\rm ions+valence}}\ndrops to zero at some distance from\nR\nc\ne\nn\nt\ne\nr\n{\\displaystyle \\mathbf R_{\\rm center}}\n. If this is \nnot the case, the values are extremely sensitive with respect to changes in\nR\nc\ne\nn\nt\ne\nr\n{\\displaystyle \\mathbf R_{\\rm center}}\n. In such cases, it might be beneficial to increase the size of the cell along the vacuum dimension (for surfaces) or for the entire cell (for isolated molecules). For practical purposes this means that for slab calculations or surfaces the position specified by\nDIPOL\nshould roughly correspond to the center of mass of the atoms in the cell, so that there is enough vacuum for the field to dissipate. See the\nElectrostatic corrections\npage for an example.\n\nMind:\nIf the flag is not set, VASP determines where the charge density averaged over one plane drops to a minimum and calculates the center of the charge distribution by adding half of the lattice vector perpendicular to the plane where the charge density has a minimum (this is a rather reliable approach for orthorhombic cells)\n\nTip:\nFor calculations of isolated molecules and surfaces with the dipole correction, use\nDIPOL\nas the center of mass of the atoms in your cell. Additionally, note that for surfaces, only the component normal to the surface is meaningful.",
    "related_tags": [
      "NELECT",
      "EPSILON",
      "IDIPOL",
      "LDIPOL",
      "LMONO",
      "EFIELD",
      "Monopole, Dipole and Quadrupole corrections",
      "Electrostatic corrections"
    ]
  },
  "DQ": {
    "default_value": "DQ = 0.001",
    "description": "step size for the finite difference k -space derivative in the linear response calculation of chemical shifts.",
    "detailed_description": "Typical values for\nDQ\nare in the range [0.001 - 0.003]. The default is often sufficient.",
    "related_tags": [
      "LCHIMAG",
      "ICHIBARE",
      "LNMR_SYM_RED",
      "NLSPLINE"
    ]
  },
  "EBREAK": {
    "default_value": "EBREAK = EDIFF / NBANDS /4",
    "description": "EBREAK specifies an absolute stopping criterion for the optimization of an eigenvalue.",
    "detailed_description": "The tags\nEBREAK\n,\nDEPER\n, and\nWEIMIN\nallow fine tuning of the iterative matrix diagonalization, and are best not changed. They are optimized for a large variety of systems, and changing one of the parameters usually decreases performance or can even screw up the iterative matrix diagonalization totally.\nIn general, these tags control when the optimization of a single band is stopped within the iterative matrix diagonalization schemes:\n\nEBREAK\ndetermines whether a band is fully converged or not. Optimization of an eigenvalue/eigenvectors pair is stopped if the change in the eigenenergy is smaller than\nEBREAK\n.",
    "related_tags": [
      "WEIMIN",
      "DEPER"
    ]
  },
  "EDIFF": {
    "default_value": "EDIFF = 10 − 4 {\\displaystyle 10^{-4}}",
    "description": "EDIFF specifies the global break condition for the electronic SC-loop. EDIFF is specified in units of eV.",
    "detailed_description": "The relaxation of the electronic degrees of freedom stops if the total (free) energy change and the band-structure-energy change ('change of eigenvalues') between two steps are both smaller than\nEDIFF\n(in eV). For\nEDIFF\n=0, strictly\nNELM\nelectronic self-consistency steps will be performed.\n\nIn most cases, the convergence speed is quadratic, so often the cost for the additional iterations is small. Hence, for well converged calculations, we strongly recommend to decrease\nEDIFF\nto 1E-6. For finite difference calculations (e.g. phonons), even\nEDIFF\n= 1E-7 might be required in order to obtain precise results. On the other hand, for large systems with many atoms and/or when using\nMETAGGA\nfunctionals, attaining an energy convergence of 1E-8 or even 1E-7 might be difficult. So, overall\nEDIFF\n= 1E-6 is likely the best compromise.",
    "related_tags": [
      "EDIFFG"
    ]
  },
  "EDIFFG": {
    "default_value": "EDIFFG = EDIFF ×10",
    "description": "EDIFFG defines the break condition for the ionic relaxation loop.",
    "detailed_description": "When\nEDIFFG\nis positive, the relaxation is stopped when the change of the total energy is smaller than\nEDIFFG\nbetween two ionic steps.\n\nWhen\nEDIFFG\nis negative, the relaxation is stopped when the norms of all the forces are smaller than |\nEDIFFG\n|. This is usually a more convenient setting.\n\nIf\nEDIFFG\n= 0, the ionic relaxation is stopped after\nNSW\nsteps.\n\nWarning:\nEDIFFG\ndoes not apply to\nmolecular-dynamics\nsimulations.",
    "related_tags": [
      "EDIFF"
    ]
  },
  "EFERMI": {
    "default_value": "EFERMI = LEGACY",
    "description": "Defines how the Fermi energy is calculated in VASP. It is recommended to use EFERMI = MIDGAP.",
    "detailed_description": "Fermi energy in semiconductors\n\nFor semiconducting materials, the Fermi energy is not uniquely defined in the bandgap of the material.\nAny value that produces the correct number of electrons (\nNELECT\n) is allowed.\nBy default, VASP places the Fermi energy at a somewhat arbitrary value within the bandgap.\nThe precise value depends on values chosen for the smearing (\nISMEAR\nand\nSIGMA\n) and the density of states (\nEMIN\n,\nEMAX\n, and\nNEDOS\n).\nTypically, this places the Fermi energy towards the bottom of the bandgap.\n\nYou can change this behavior by setting\nEFERMI\n= MIDGAP (recommended).\nVASP will then put the Fermi energy in the middle of the gap because this is the most consistent with increasing the smearing\nSIGMA\n.\nThis algorithm to determine the Fermi energy was introduced in VASP.6.4.\nThe value of the Fermi energy should not affect the outcome of the calculation.\n\nFermi energy in metals\n\nMIDGAP and LEGACY should yield the same value when your system does not have a gap.\nThe Fermi energy is placed precisely at the value so that underneath are enough states to accommodate\nNELECT\nelectrons. The evaluation of the Fermi energy involves an integral over the 1. BZ.\nTherefore, the Fermi energy in metals needs to be converged with respect to the\nKPOINTS\nmesh and smearing (\nISMEAR\n,\nSIGMA\n).\n\nTip:\nIf you are interested in the properties at the Fermi energy (e.g., for transport calculations), you should compute the Fermi energy with a very dense\nk\n-point mesh. To save computational time, you can fix the charge density (\nICHARG\n= 11) once the Kohn-Sham states have converged with respect to the\nk\n-point density and increase the number of\nk\n-point further to converge the value of the Fermi energy.\n\nFixed Fermi energy\n\nOccasionally, you want to compute systems with fixed Fermi energy for a given charge density.\nTo this end, set\nEFERMI\nto a numeric value and\nICHARG\n= 11.\nA possible use case is to set\nEFERMI\nto the converged Fermi energy in a band-structure calculation.\nYou may use this to introduce electron doping/depletion to a system.\n\nWarning:\nThe Fermi energy cannot be computed based on\nk\npoints along a path.\n\nThis is, in particular, important for band-structure calculation of metallic systems because for gaped systems the Fermi energy often still ends up at a valid value within the gap despite the inaccurate computation. Hence, to plot a band structure the band energies should be taken from the calculation with fixed charge density based on\nk\n-points along a path, but the Fermi energy should be taken from the calculation based on a\nk\nmesh (e.g., the scf calculation by which the charge density was obtained or a more precisely converged Fermi energy based on the same fixed charge density).\nEFERMI\ncan fix the Fermi energy to the proper value during the band-structure calculation.",
    "related_tags": [
      "ISMEAR",
      "SIGMA",
      "EMIN",
      "EMAX",
      "NEDOS"
    ]
  },
  "EFIELD": {
    "default_value": "",
    "description": "EFIELD controls the magnitude of the applied electric force field.",
    "detailed_description": "It is possible to apply an external electrostatic field in slab, or molecular calculations. Presently only a single value can be supplied and the field is applied in the direction selected by\nIDIPOL\n=1-4. The electric force field is supplied in units of eV/Å. Dipole corrections to the potential (\nLDIPOL\n=.TRUE.) can and should be turned on to avoid interactions between the periodically repeated images.\n\nMind:\nThe electric field is defined opposite to the common definition. So electrons will move along the direction of the electric field.",
    "related_tags": [
      "Monopole Dipole and Quadrupole corrections",
      "NELECT",
      "EPSILON",
      "IDIPOL",
      "DIPOL",
      "LMONO",
      "LDIPOL"
    ]
  },
  "EFIELD_PEAD": {
    "default_value": "Default: EFIELD_PEAD = 3*0.01 if LCALCEPS =.TRUE. | = 3*0.0 else",
    "description": "EFIELD_PEAD specifies the homogeneous electric force field in the electric enthalpy functional used to compute the self-consistent response to finite electric fields . EFIELD_PEAD is specified in units of eV/Å.",
    "detailed_description": "Mind:\nIf\nEFIELD_PEAD\nis used in combination with\nLCALCEPS\n=.TRUE., electric field values below 1E-5 will be reset to the default value.\n\nIf\n\nEFIELD_PEAD\n=\nε\nx\nε\ny\nε\nz\n\nis set, with |\nε\n|>0, VASP will first determine the zero-field groundstate of the system, and subsequently switch on the electric field and compute the field-polarized groundstate orbitals.\n\nAdditionally, from the change in the macroscopic electronic polarization due to the applied electric field, VASP calculates (part of) the components on the diagonal of the ion-clamped static dielectric tensor (ε\n∞\n), in accordance with:\n\nϵ\ni\ni\n∞\n=\n1\n+\n4\nπ\nϵ\n0\n∂\nP\ni\n∂\nE\ni\n,\ni\n=\nx\n,\ny\n,\nz\n{\\displaystyle \n\\epsilon^\\infty_{ii}=1+\n\\frac{4\\pi}{\\epsilon_0}\\frac{\\partial P_i}{\\partial \\mathcal{E}_i},\n\\qquad\n{i=x,y,z}\n}\n\nBeware: this option is only useful if one is interested in selected components on the diagonal of the ion-clamped dielectric tensor (for instance, in cubic systems). To calculate the full ion-clamped dielectric tensor of a system\n\nϵ\ni\nj\n∞\n=\nδ\ni\nj\n+\n4\nπ\nϵ\n0\n∂\nP\ni\n∂\nE\nj\n,\ni\n,\nj\n=\nx\n,\ny\n,\nz\n{\\displaystyle \n\\epsilon^\\infty_{ij}=\\delta_{ij}+\n\\frac{4\\pi}{\\epsilon_0}\\frac{\\partial P_i}{\\partial \\mathcal{E}_j},\n\\qquad\n{i,j=x,y,z}\n}\n\nfrom field-polarized calculations, use\nLCALCEPS\n=.TRUE..\n\nNote\n: One should be aware that when the electric field is chosen to be too large, the electric enthalpy functional will lose its minima, and VASP will not be able to find a stationary solution for the field-polarized orbitals.\nThis is discussed in some detail by Souza\net al.\n.\n[1]\nVASP will produce a warning if:\n\ne\n|\nE\n⋅\na\ni\n|\n>\n1\n10\nE\ng\na\np\n/\nN\ni\n,\n{\\displaystyle \ne|\\mathcal{E}\\cdot \\mathbf{a}_i|>\\frac{1}{10}E_{\\mathrm{gap}}/N_i,\n}\n\nwhere\nE\ngap\nis the bandgap,\na\ni\nare the lattice vectors, and\nN\ni\nis the number of\nk\n-points along the reciprocal lattice vector\ni\n, in the regular (\nN\n1\n×\nN\n2\n×\nN\n3\n)\nk\n-mesh. The factor 1/10 is chosen to be on the safe side. If one does not include unoccupied bands, VASP is obviously not able to determine the bandgap and can not check whether the electric field might be too large. This will also produce a warning message.\n\nAn example: ε\n∞\nin NaF\n\nUsing the following\nINCAR\nfile:\n\nPREC = Med\nEDIFF= 1E-6\n\nISMEAR = 0\n\nEFIELD_PEAD = 0.0 0.0 0.01\n\nThe computation of the static dielectric properties from the field-polarized groundstate orbitals requires a very tight convergence of the solutions. The\nEDIFF\n-tag specifies the usual convergence criterium for the zero-field solution. As a default VASP will try for an even tighter convergence of the field-polarized groundstate:\nEDIFF\n/100! Reaching this level of convergence may be very costly and in rare cases even impossible.\n\nKPOINTS\nfile:\n\n6x6x6\n 0\nGamma\n 6 6 6\n 0 0 0\n\nNote\n: The\nPEAD\nrelated routines only work for regular meshes of\nk\n-points that include the Γ-point, i.e.~either uneven meshes (not recommended) or Γ-centered meshes (like the one above).\n\nPOSCAR\nfile:\n\nNaF\n 4.5102\n 0.0 0.5 0.5\n 0.5 0.0 0.5\n 0.5 0.5 0.0\n1 1\nDirect\n  0.0000000000000000  0.0000000000000000  0.0000000000000000\n  0.5000000000000000  0.5000000000000000  0.5000000000000000\n\nand LDA Na_sv and F PAW datasets.\n\nWith the input above, running VASP should produce something akin to:\n\nentering main loop\n       N       E                     dE             d eps       ncg     rms          rms(c)\nDAV:   1    -0.121171874254E+03   -0.12117E+03   -0.11093E+04   392   0.169E+03\nDAV:   2    -0.290944564657E+03   -0.16977E+03   -0.15372E+03   412   0.454E+02\nDAV:   3    -0.296448270211E+03   -0.55037E+01   -0.54726E+01   516   0.857E+01\nDAV:   4    -0.296558918897E+03   -0.11065E+00   -0.11062E+00   432   0.122E+01\nDAV:   5    -0.296564115002E+03   -0.51961E-02   -0.51960E-02   568   0.177E+00    0.512E+00\n      ...         ...                ...\n      ...         ...                ...\nDAV:  11    -0.295718441201E+03    0.31316E-05   -0.40516E-06   436   0.471E-02    0.256E-03\nDAV:  12    -0.295718441337E+03   -0.13610E-06   -0.13352E-06   276   0.146E-02\n       N       E                     dE             d eps       ncg     rms          rms(c)\n gam= 0.000 g(H,U,f)=  0.142E-07 0.000E+00 0.322E-02 ort(H,U,f) = 0.000E+00 0.000E+00 0.000E+00\nSDA:   1    -0.295718441659E+03   -0.29572E+03   -0.12885E-02   360   0.322E-02 0.000E+00\n      ...         ...                ...\n gam= 0.382 g(H,U,f)=  0.220E-07 0.167E-07 0.186E-10 ort(H,U,f) =-0.260E-08-0.389E-08 0.523E-10\nDMP:   4    -0.295718441597E+03    0.43565E-09   -0.14510E-07   360   0.387E-07-0.644E-08\n gam= 0.382 g(H,U,f)=  0.232E-08 0.318E-09 0.166E-11 ort(H,U,f) =-0.471E-08-0.181E-08 0.590E-11\nDMP:   5    -0.295718441603E+03   -0.59431E-08   -0.61690E-10   360   0.264E-08-0.651E-08\n final diagonalization\n p_tot=(  0.875E-06  0.875E-06  0.875E-06 )\n       N       E                     dE             d eps       ncg     rms          rms(c)\n p_tot=(  0.875E-06  0.875E-06  0.875E-06 )\ndp_tot=(  0.000E+00  0.000E+00  0.000E+00 )  diag[e(oo)]=(    ---      ---    1.00000 )\n gam= 0.000 g(H,U,f)=  0.149E-04 0.000E+00 0.000E+00 ort(H,U,f) = 0.000E+00 0.000E+00 0.000E+00\nSDA:   1    -0.295718441612E+03   -0.14804E-07   -0.59582E-05   360   0.149E-04 0.000E+00\n      ...         ...                ...\n      ...         ...                ...\n gam= 0.519 g(H,U,f)=  0.392E-07 0.000E+00 0.000E+00 ort(H,U,f) = 0.919E-08 0.000E+00 0.000E+00\nDMP:   9    -0.295718447444E+03   -0.21085E-07   -0.17608E-07   360   0.392E-07 0.919E-08\n p_tot=(  0.868E-06  0.868E-06  0.116E-02 )\ndp_tot=( -0.721E-08 -0.723E-08  0.116E-02 )  diag[e(oo)]=(    ---      ---    1.91593 )\n gam= 0.519 g(H,U,f)=  0.210E-07 0.000E+00 0.000E+00 ort(H,U,f) =-0.164E-08 0.000E+00 0.000E+00\nDMP:  10    -0.295718447453E+03   -0.83301E-08   -0.80481E-08   360   0.210E-07-0.164E-08\n final diagonalization\n p_tot=(  0.860E-06  0.860E-06  0.118E-02 )\ndp_tot=( -0.154E-07 -0.155E-07  0.118E-02 )  diag[e(oo)]=(    ---      ---    1.92723 )\n   1 F= -.29571845E+03 E0= -.29571845E+03  d E =-.223452E-12\n\nwhere one can discern three distinct blocks of SCF iterations. The first one (steps marked with\nDAV\n) corresponds to the calculation of the zero-field groundstate. After this groundstate has been reached, the\nk\n-point mesh is regenerated using a set of symmetry operations, which takes into account that the symmetry of the system is possibly reduced by the applied electric field. In most cases the new set of\nk\n-points is larger than the original one. The orbitals at the additional\nk\n-points are generated from their symmetry equivalent counterparts in the zero-field case. This expanded set of orbitals is now reoptimized until convergence is better than\nEDIFF\n/100 (the second block, marked\nDMP\n), and the initial electronic polarization is computed.\n\nThen the electric field is switched on, and the field-polarized groundstate is calculated. This is the last block of steps marked with DMP. From the change in the electronic dipole moment due to the electric field VASP computes (part of) the components on the diagonal of the ion-clamped static dielectric tensor.\n\nThis information is found both in the\nOUTCAR\nfile and on\nstdout\n:\n\ndiag[e(oo)]=(       ----        ----      1.92723 )\n\nTo speed up the computation of the field-polarized groundstate one may set\nSKIP_EDOTP\n=.TRUE. to avoid the recalculation of the\nelectronic polarization\nat each iteration during the SCF procedure.\nHowever, the additional term in Hamiltonian (second term on the right-hand-side of\nthe electric enthalpy functional\n) has to be correctly included and can not be kept fixed.\nBasically this means one does not minimize the total energy but optimizes the orbitals until a stationary point is reached. A stationary point is considered to be reached as soon as the norm of the gradient on the orbitals is smaller than\nEDIFF\n/100, and the SCF procedure will stop.\nIn the case of the previous example this will lead to:\n\nN       E                     dE             d eps       ncg     rms          rms(c)\n gam= 0.000 g(H,U,f)=  0.149E-04 0.000E+00 0.000E+00 ort(H,U,f) = 0.000E+00 0.000E+00 0.000E+00\nSDA:   1    -0.295718441603E+03   -0.60750E-08   -0.59581E-05   360   0.149E-04 0.000E+00\n gam= 0.519 g(H,U,f)=  0.332E-05 0.000E+00 0.000E+00 ort(H,U,f) = 0.629E-05 0.000E+00 0.000E+00\n      ...         ...                ...\n      ...         ...                ...\n gam= 0.519 g(H,U,f)=  0.124E-07 0.000E+00 0.000E+00 ort(H,U,f) =-0.141E-08 0.000E+00 0.000E+00\nDMP:  11    -0.295718435607E+03    0.13956E-06   -0.46725E-08   360   0.124E-07-0.141E-08\n gam= 0.519 g(H,U,f)=  0.637E-08 0.000E+00 0.000E+00 ort(H,U,f) = 0.218E-10 0.000E+00 0.000E+00\nDMP:  12    -0.295718435599E+03    0.78403E-08   -0.25522E-08   360   0.637E-08 0.218E-10\n final diagonalization\n p_tot=(  0.844E-06  0.844E-06  0.117E-02 )\ndp_tot=( -0.313E-07 -0.313E-07  0.117E-02 )  diag[e(oo)]=(    ---      ---    1.92478 )\n   1 F= -.29571844E+03 E0= -.29571844E+03  d E =-.223448E-12",
    "related_tags": [
      "SKIP_EDOTP",
      "LCALCPOL",
      "LCALCEPS",
      "LPEAD",
      "IPEAD",
      "LBERRY",
      "IGPAR",
      "NPPSTR",
      "DIPOL",
      "Berry phases and finite electric fields"
    ]
  },
  "EFOR": {
    "default_value": "Default: EFOR = 3 * NIONS * 0.0",
    "description": "EFOR sets external forces in eV/ Å on each atom in the cartesian x-, y-, and z-directions. The order of the ions is equivalent to the order in the POSCAR file, and for each ion, x-, y-, and z-components have to be given.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe array of external forces will be added to the\nforces\ncomputed internally for each ionic step (\nionic minimization\nor\nmolecular dynamics\n).\nIf an\nionic minimization\nis performed with non-zero external forces, the converged structures will be only at a minimum accounting for the constraint of the external forces. Regardless of whether the\nconvergence criterion\nis set to minimize total forces, or converge the total energy.\n\nWarning:\nThe sum of all external forces set with\nEFOR\nmust be 0 to avoid drift.\n\nWhile the total sum of all external forces in all directions must be zero, it is possible to achieve this by putting balancing forces on an ion that is fixed by the\nselective dynamics\nfeature in the\nPOSCAR\nfile.\n\nFormat\n\nEFOR\ncan be a very long array, as 3 values need to be set for each ion in the system. The format is equivalent to setting the magnetic moments in the noncollinear case using\nMAGMOM\n, so it is possible to use an\nN*F\nsyntax to indicate that the next\nN\nentries in the array should be of value\nF\n. E.g.:\n\nEFOR\n= 2*0.0 1.0 188*0.0 -1.0\n\nIn this example, we have 64 ions, so we have to set 3*64=192 values in the array. Only the cartesian z components of the first and last ion should be non-zero, which enables a compact\nINCAR\nline.\n\nIf more force components are non-zero, readability is increased by utilizing the\nmulti-line option\nin the\nINCAR\nfile. This is achieved by using backslashes (\n\\\n) to negate line breaks or put the multi-line expression in quotes (\n\"\n). E.g. for a 32 atom system with forces in the x- and z-directions on the first and last 8 atoms:\n\nEFOR\n= \"2.0 0.0 1.0\n         2.0 0.0 1.0\n         2.0 0.0 1.0\n         2.0 0.0 1.0\n         0.0 0.0 1.0\n         0.0 0.0 1.0\n         0.0 0.0 1.0\n         0.0 0.0 1.0\n         48*0.0     \n        -1.0 0.0 -1.0\n        -1.0 0.0 -1.0\n        -1.0 0.0 -1.0\n        -1.0 0.0 -1.0\n        -1.0 0.0 -1.0\n        -1.0 0.0 -1.0\n        -1.0 0.0 -1.0\n        -1.0 0.0 -1.0\"\n\nSymmetry and periodic boundary conditions\n\nSymmetry considerations\n\nSetting external forces will, in most cases, break some symmetries of the system, resulting in more\nirreducible\nk\npoints\nand thus increased computational effort.\n\nIf any non-zero external forces are set, the symmetry reduction is reported in the OUTCAR after all other symmetry operations. E.g.:\n\nAnalysis of structural, dynamic, and magnetic symmetry & ext. forces:\n=====================================================================\n Subroutine PRICEL returns:\n Original cell was already a primitive cell.\n  \n  \n Routine SETGRP: Setting up the symmetry group for a \n hexagonal supercell.\n  \n   \n Subroutine GETGRP returns: Found  6 space group operations\n (whereof  6 operations were pure point group operations)\n out of a pool of 24 trial point group operations.\n  \n   \n The overall configuration with ext. forces has the point symmetry S_6 .\n Periodic boundary conditions apply in all VASP calculations.\n\nPeriodic boundary conditions\n\nAll VASP calculations are performed under periodic boundary conditions. When external forces are applied to bulk systems, this can lead to unexpected results. E.g. pushing an atom towards another atom in the same unit cell might pull it further away from the same atom in a neighboring unit cell. Thus external forces cannot be used to uniformly compress or strain a bulk system along a specific axis. This can however be achieved by lengthening or shortening the relevant lattice vector.\n\nOn the other hand, external forces should be used if strain needs to be applied to a slab, a molecule, or any other system in which a vacuum region is used. When e.g. a surface slab needs to be compressed in the direction normal to the surface plane, the lattice vector cannot be shortened because this would collapse the vacuum. External forces on the atoms at the surfaces can achieve the desired effect.\n\nTip:\nExternal forces are typically only used if there is a vacuum region in the simulation cell.\n\nExternal forces during on-the-fly learning\n\nExternal forces can be used during on-the-fly training for\nmachine-learned force fields\n. In that case, the external forces will be only used during the ionic updates but will be removed for the training. This ensures that only forces arising from interatomic interactions will contribute to the force field and the resulting force field can be used without, or with different external forces.\n\nOutput\n\nThe external forces are printed to the\nOUTCAR\nfile after the positions of ions. E.g.:\n\nexternal forces on ions in cartesian coordinates  (eV/Angst):\n  0.00000000  0.00000000  0.50000000\n  0.00000000  0.00000000  0.00000000\n  0.00000000  0.00000000  0.00000000\n  0.00000000  0.00000000 -0.50000000\n\nAfter each ionic step, the external forces are included in the reported TOTAL-FORCE array, but not separately listed, since they are not updated during a VASP run.:\n\nPOSITION                                       TOTAL-FORCE (eV/Angst)\n-----------------------------------------------------------------------------------\n    -0.00000     -0.00000     20.27571         0.000000      0.000000      0.001257\n     1.43189      0.82670     22.42983        -0.000000     -0.000000     -0.008077\n     2.86378      1.65341     24.58497         0.000000      0.000000      0.008077\n     0.00000      0.00000     26.73909        -0.000000     -0.000000     -0.001257\n-----------------------------------------------------------------------------------\n   total drift:                                0.000000     -0.000000     -0.000000\n\nExample\n\nAs an example, the compression of an Al(001) slab under 4 GPa of pressure is chosen. At ~39500 times the atmospheric pressure at sea level, this is considerable, but pressures in\ndiamond anvil cells\ncan be two orders of magnitude larger. The four-layer thick slab corresponding to the following\nPOSCAR\nis already relaxed without external forces:\n\nAl 001 slab\n  1.00000000000000     \n    4.0472922325000000    0.0000000000000000    0.0000000000000000\n    0.0000000000000000    4.0472922325000000    0.0000000000000000\n    0.0000000000000000    0.0000000000000000   16.0709387330000000\n  Al\n  8\n Selective dynamics\n Direct\n  0.0000000000000000  0.0000000000000000  0.0000000000000000   F   F   F\n  0.4999999999382325  0.4999999999382325  0.0000000000000000   F   F   F\n  0.0000000000000000  0.4999999999382325  0.1291914423155097   T   T   T\n  0.4999999999382325 -0.0000000000000000  0.1291914423155097   T   T   T\n  0.0000000000000000  0.0000000000000000  0.2574944356749768   T   T   T\n  0.4999999999382325  0.4999999999382325  0.2574944356749768   T   T   T\n  0.0000000000000000  0.4999999999382325  0.3864211449750742   T   T   T\n  0.4999999999382325  0.0000000000000000  0.3864211449750742   T   T   T\n\nThe pressure has to be converted into the correct units. Forces in VASP are given in eV/\nÅ\n, and an area in\nÅ\n2\n, thus GPa needs to be converted to (eV/\nÅ\n)/\nÅ\n2\n, or eV\nÅ\n-3\n:\n\nG\nP\na\n=\n10\n9\nP\na\n=\n10\n9\nN\nm\n2\n=\n10\n9\nN\nm\nm\n3\n=\n10\n9\n6.2415\n×\n10\n18\ne\nV\n10\n30\nÅ\n3\n=\n6.2415\n×\n10\n−\n3\ne\nV\n/\nÅ\nÅ\n2\n{\\displaystyle \n\\mathrm{GPa} = 10^9 \\mathrm{Pa} = 10^9 \\frac{\\mathrm{N}}{\\mathrm{m}^2} = 10^9 \\frac{\\mathrm{Nm}}{\\mathrm{m}^3} = 10^9 \\frac{6.2415 \\times 10^{18}\\mathrm{eV}}{10^{30} \\AA^3} = 6.2415 \\times 10^{-3} \\frac{\\mathrm{eV}/\\AA}{\\AA^2}\n}\n\nWith a lattice parameter of 4.047\nÅ\n, the surface area A of the slab is about 16.381\nÅ\n2\n. Thus the total force in eV/\nÅ\nwe have to put on the top layer to compress the slab with 4 GPa of pressure is:\n\n4\n×\nA\n×\n6.2415\n×\n10\n−\n3\n≃\n0.409\n,\n{\\displaystyle \n4 \\times A \\times 6.2415 \\times 10^{-3} \\simeq 0.409 \\quad ,\n}\n\nor 0.20448 eV/\nÅ\nper surface atom. The\nINCAR\nfile can now be written:\n\nENCUT = 250\n ISMEAR = 1\n SIGMA = 0.1\n NELMIN = 4\n NSW = 60\n ISIF = 2\n IBRION = 1\n POTIM = 0.75\n EDIFFG = -0.01\n EDIFF = 1E-6\n EFOR = 2*0 0.40896 17*0 -0.20448 2*0 -0.20448\n\nNote that the forces on the top atoms are balanced by putting the opposing force on one atom only. This is feasible since both atoms in the bottom layer are fixed by selective dynamics flags.\n\nUsing a 5x5x1 Γ-centered mesh in the\nKPOINTS\nfile, and the standard PBE Al\nPOTCAR\n, the calculation converges in less than 10 ionic steps.\n\nThe slab is compressed by less than 2%, from 6.21\nÅ\nto 6.10\nÅ\n. This relatively small compression at relatively high pressure is due to three factors:\n\n4 GPa corresponds to forces of ~0.2 eV/\nÅ\n, which is only 20 times the negligible force limit of 0.01 eV/\nÅ\nin this calculation.\nWe do not allow the material to\nexpand in the direction normal to the pressure\nby keeping the cell shape fixed with\nISIF\n= 2.\nIntra-atomic forces in perfect close-packed metallic crystals are powerful, and lattice imperfections usually mediate deformations in real materials.\n\nFor layered materials, molecules on surfaces, and other, less strongly-bound systems, similar forces will have larger effects, however.\n\nRelated Tags and Sections\n\nICONST\n\nExamples that use this tag",
    "related_tags": []
  },
  "EINT": {
    "default_value": "EINT = not set",
    "description": "EINT sets the energy interval for bands contributing to the calculation of the partial charge density in eV.",
    "detailed_description": "EINT\n= [real1] [real2]:\n\nIf two values are given, the energy interval between those values is used.\n\nEINT\n= [real1]:\n\nIf only one value is given, the Fermi energy\nϵ\nf\n{\\displaystyle \\epsilon_f}\nis used as the other limit [real2] of the interval.\n\nImportant:\nThe energies passed in\nEINT\nare used as set if\nNBMOD\n= -2, but will be added to the Fermi energy (\nϵ\nf\n{\\displaystyle \\epsilon_f}\n+ real1 and\nϵ\nf\n{\\displaystyle \\epsilon_f}\n+ real2) if\nNBMOD\n= -3.\n\nIf [real1] is larger than [real2], the two values will be flipped internally, so a meaningful energy interval is used.\n\nIf\nEINT\nis set, but\nNBMOD\nis not, it will be internally set to\nNBMOD\n= -2, and the input values of\nEINT\nwill be treated as absolute energies.\n\nEINT\ncan be conveniently used in combination with\nNBMOD\n= -3 to mimic the bias-voltage for\nsimulating a scanning-tunneling-microscope image\n.",
    "related_tags": [
      "LPARD",
      "NBMOD",
      "IBAND",
      "KPUSE",
      "LSEPB",
      "LSEPK",
      "LPARDH5",
      "PARCHG",
      "vaspout.h5",
      "Band-decomposed charge densities"
    ]
  },
  "ELPH_DECOMPOSE": {
    "default_value": "ELPH_DECOMPOSE = VDPR",
    "description": "Chooses which contributions to include in the computation of the electron-phonon matrix elements.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe electron-phonon matrix element can be formulated in the\nprojector-augmented-wave (PAW) method\nin terms of individual contributions\n[1]\n.\nEach contribution can be included by specifying the associated letter in\nELPH_DECOMPOSE\n.\nWe suggest two different combinations to define matrix elements:\n\nELPH_DECOMPOSE\n= VDPR\n- \"All-electron\" (AE) matrix element\n[1]\n[2]\nThis is the de-facto standard definition of the electron-phonon matrix element expressed in the language of the PAW method. The AE matrix element can be used in the framework of many-body perturbation theory without any further restrictions. It should also be used if one is not interested in the final observables, but in the values of the matrix elements themselves, for example, to study scattering channels.\nELPH_DECOMPOSE\n= VDQ\n- \"Pseudo\" (PS) matrix element\n[1]\n[3]\nThis matrix element arises naturally from the PAW formulation of the phonon-induced band-structure renormalization in the adiabatic Rayleigh-Schrödinger perturbation theory. It is only really well-defined in this particular context. However, when using this much smoother PS matrix element instead of the AE matrix element, the electron self-energy converges much faster with respect to the number of intermediate states. Despite its definition from an adiabatic theory, we recommend to use the PS matrix element also to compute the\nnon-adiabatic band-structure renormalization\n[1]\n. In our experience, the PS matrix element is furthermore well suited to perform\ntransport calculations\n, since the difference between AE and PS matrix elements is small for scattering processes close to the Fermi edge. In any case, it is always recommended to compare observables computed with the PS matrix elements against the same observables computed with the AE matrix elements.\n\nAvailable contributions\n\nV - Derivative of pseudopotential,\nv\n~\n{\\displaystyle \\tilde{v}}\ng\nm\nk\n′\n,\nn\nk\n,\na\n(\nV\n)\n≡\n⟨\nψ\n~\nm\nk\n′\n|\n∂\nv\n~\n∂\nu\na\n|\nψ\n~\nn\nk\n⟩\n{\\displaystyle \n    g^{(\\text{V})}_{m \\mathbf{k}', n \\mathbf{k}, a}\n    \\equiv\n    \\langle\n        \\tilde{\\psi}_{m \\mathbf{k}'} |\n        \\frac{\\partial \\tilde{v}}{\\partial u_{a}} |\n        \\tilde{\\psi}_{n \\mathbf{k}}\n    \\rangle\n}\nThis term is the pure plane-wave contribution to the total PAW matrix element. If the PAW augmentation region were vanishingly small, this would be the sole contribution.\nD - Derivative of PAW strength parameters,\nD\na\n,\ni\nj\n{\\displaystyle D_{a, ij}}\ng\nm\nk\n′\n,\nn\nk\n,\na\n(\nD\n)\n≡\n∑\nb\ni\nj\n⟨\nψ\n~\nm\nk\n′\n|\np\n~\nb\ni\n⟩\n∂\nD\nb\n,\ni\nj\n∂\nu\na\n⟨\np\n~\nb\nj\n|\nψ\n~\nn\nk\n⟩\n{\\displaystyle \n    g^{(\\text{D})}_{m \\mathbf{k}', n \\mathbf{k}, a}\n    \\equiv\n    \\sum_{bij}\n    \\langle\n        \\tilde{\\psi}_{m \\mathbf{k}'} |\n        \\tilde{p}_{b i}\n    \\rangle\n    \\frac{\\partial D_{b, ij}}{\\partial u_{a}}\n    \\langle\n        \\tilde{p}_{b j} |\n        \\tilde{\\psi}_{n \\mathbf{k}}\n    \\rangle\n}\nThis contribution stems from the PAW treatment of the electronic Hamiltonian. It is of the same nature as\ng\n(\nV\n)\n{\\displaystyle g^{(\\text{V})}}\nbut is treated in the local basis inside the augmentation region. For a detailed discussion of the PAW strength parameters, we refer to Ref.\n[4]\n.\nP - Derivative of PAW projectors,\n|\np\n~\na\ni\n⟩\n{\\displaystyle |\\tilde{p}_{ai}\\rangle}\ng\nm\nk\n′\n,\nn\nk\n,\na\n(\nP\n)\n≡\n∑\ni\nj\n⟨\nψ\n~\nm\nk\n′\n|\n∂\np\n~\na\ni\n∂\nu\na\n⟩\n(\nD\na\n,\ni\nj\n−\nε\nn\nk\nQ\na\n,\ni\nj\n)\n⟨\np\n~\na\nj\n|\nψ\n~\nn\nk\n⟩\n+\n∑\ni\nj\n⟨\nψ\n~\nm\nk\n′\n|\np\n~\na\ni\n⟩\n(\nD\na\n,\ni\nj\n−\nε\nm\nk\n′\nQ\na\n,\ni\nj\n)\n⟨\n∂\np\n~\na\nj\n∂\nu\na\n|\nψ\n~\nn\nk\n⟩\n{\\displaystyle \n    \\begin{split}\n        g^{(\\text{P})}_{m \\mathbf{k}', n \\mathbf{k}, a}\n        & \\equiv\n        \\sum_{ij}\n        \\langle\n            \\tilde{\\psi}_{m \\mathbf{k}'} |\n            \\frac{\\partial \\tilde{p}_{a i}}{\\partial u_{a}}\n        \\rangle\n        (\n            D_{a, ij} - \\varepsilon_{n \\mathbf{k}} Q_{a, ij}\n        )\n        \\langle\n            \\tilde{p}_{a j} |\n            \\tilde{\\psi}_{n \\mathbf{k}}\n        \\rangle\n        \\\\ & +\n        \\sum_{ij}\n        \\langle\n            \\tilde{\\psi}_{m \\mathbf{k}'} |\n            \\tilde{p}_{a i}\n        \\rangle\n        (\n            D_{a, ij} - \\varepsilon_{m \\mathbf{k}'} Q_{a, ij}\n        )\n        \\langle\n            \\frac{\\partial \\tilde{p}_{a j}}{\\partial u_{a}} |\n            \\tilde{\\psi}_{n \\mathbf{k}}\n        \\rangle\n    \\end{split}\n}\nR - Derivative of PAW partial waves,\n|\nϕ\na\ni\n⟩\n{\\displaystyle |\\phi_{ai}\\rangle}\nand\n|\nϕ\n~\na\ni\n⟩\n{\\displaystyle |\\tilde{\\phi}_{ai}\\rangle}\ng\nm\nk\n′\n,\nn\nk\n,\na\n(\nR\n)\n≡\n(\nε\nn\nk\n−\nε\nm\nk\n′\n)\n∑\ni\nj\n⟨\nψ\n~\nm\nk\n′\n|\np\n~\na\ni\n⟩\nR\na\n,\ni\nj\n⟨\np\n~\na\nj\n|\nψ\n~\nn\nk\n⟩\n{\\displaystyle \n    g^{(\\text{R})}_{m \\mathbf{k}', n \\mathbf{k}, a}\n    \\equiv\n    (\\varepsilon_{n \\mathbf{k}} - \\varepsilon_{m \\mathbf{k}'})\n    \\sum_{ij}\n    \\langle\n        \\tilde{\\psi}_{m \\mathbf{k}'} |\n        \\tilde{p}_{a i}\n    \\rangle\n    R_{a, ij}\n    \\langle\n        \\tilde{p}_{a j} |\n        \\tilde{\\psi}_{n \\mathbf{k}}\n    \\rangle\n}\nwith\nR\na\n,\ni\nj\n≡\n⟨\nϕ\na\ni\n|\n∂\nϕ\na\nj\n∂\nu\na\n⟩\n−\n⟨\nϕ\n~\na\ni\n|\n∂\nϕ\n~\na\nj\n∂\nu\na\n⟩\n{\\displaystyle \n\tR_{a, ij}\n\t\\equiv\n\t\\langle\n        \\phi_{a i} |\n        \\frac{\\partial \\phi_{a j}}{\\partial u_{a}}\n    \\rangle -\n\t\\langle\n        \\tilde{\\phi}_{a i} |\n        \\frac{\\partial \\tilde{\\phi}_{a j}}{\\partial u_{a}}\n    \\rangle\n}\nQ - Derivative of PAW projectors,\n|\np\n~\na\ni\n⟩\n{\\displaystyle |\\tilde{p}_{ai}\\rangle}\n(different eigenvalues)\ng\nm\nk\n′\n,\nn\nk\n,\na\n(\nQ\n)\n≡\n∑\ni\nj\n⟨\nψ\n~\nm\nk\n′\n|\n∂\np\n~\na\ni\n∂\nu\na\n⟩\n(\nD\na\n,\ni\nj\n−\nε\nn\nk\nQ\na\n,\ni\nj\n)\n⟨\np\n~\na\nj\n|\nψ\n~\nn\nk\n⟩\n+\n∑\ni\nj\n⟨\nψ\n~\nm\nk\n′\n|\np\n~\na\ni\n⟩\n(\nD\na\n,\ni\nj\n−\nε\nn\nk\nQ\na\n,\ni\nj\n)\n⟨\n∂\np\n~\na\nj\n∂\nu\na\n|\nψ\n~\nn\nk\n⟩\n{\\displaystyle \n    \\begin{split}\n        g^{(\\text{Q})}_{m \\mathbf{k}', n \\mathbf{k}, a}\n        & \\equiv\n        \\sum_{ij}\n        \\langle\n            \\tilde{\\psi}_{m \\mathbf{k}'} |\n            \\frac{\\partial \\tilde{p}_{a i}}{\\partial u_{a}}\n        \\rangle\n        (\n            D_{a, ij} - \\varepsilon_{n \\mathbf{k}} Q_{a, ij}\n        )\n        \\langle\n            \\tilde{p}_{a j} |\n            \\tilde{\\psi}_{n \\mathbf{k}}\n        \\rangle\n        \\\\ & +\n        \\sum_{ij}\n        \\langle\n            \\tilde{\\psi}_{m \\mathbf{k}'} |\n            \\tilde{p}_{a i}\n        \\rangle\n        (\n            D_{a, ij} - \\varepsilon_{n \\mathbf{k}} Q_{a, ij}\n        )\n        \\langle\n            \\frac{\\partial \\tilde{p}_{a j}}{\\partial u_{a}} |\n            \\tilde{\\psi}_{n \\mathbf{k}}\n        \\rangle\n    \\end{split}\n}\nThis contribution is very similar to\ng\n(\nP\n)\n{\\displaystyle g^{(\\text{P})}}\n. The only difference is in the Kohn-Sham eigenvalues. While\ng\n(\nP\n)\n{\\displaystyle g^{(\\text{P})}}\nuses the eigenvalues of both the initial and final state (so\nε\nn\nk\n{\\displaystyle \\varepsilon_{n \\mathbf{k}}}\nand\nε\nm\nk\n′\n{\\displaystyle \\varepsilon_{m \\mathbf{k}'}}\n),\ng\n(\nQ\n)\n{\\displaystyle g^{(\\text{Q})}}\nonly uses the eigenvalues of the initial state (\nε\nn\nk\n{\\displaystyle \\varepsilon_{n \\mathbf{k}}}\n).",
    "related_tags": [
      "Projector-augmented-wave formalism",
      "ELPH_RUN",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW"
    ]
  },
  "ELPH_DRIVER": {
    "default_value": "ELPH_DRIVER = el",
    "description": "Chooses which driver to use for electron-phonon calculations.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis is a high-level tag that chooses what to compute during an electron-phonon calculation.\nCurrently, the following drivers are supported:\n\nELPH_DRIVER\n= el\nComputes the phonon-induced electron self-energy.\nELPH_DRIVER\n= mels\nComputes the electron-phonon matrix elements and writes them to the\nvaspelph.h5\nfile.",
    "related_tags": [
      "ELPH_RUN",
      "ELPH_DECOMPOSE",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW"
    ]
  },
  "ELPH_IGNORE_IMAG_PHONONS": {
    "default_value": "ELPH_IGNORE_IMAG_PHONONS = .FALSE.",
    "description": "If enabled, VASP ignores imaginary phonon frequencies during electron-phonon calculations.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nImaginary phonon frequencies are often a sign that the system in question is not well-converged or not well-described by the simulation.\nIn this case, the system should first be properly converged until stable (real) phonons are obtained.\n\nMind:\nImaginary phonon frequencies can also appear at phase transitions or other lattice instabilities. However, for\nperturbative electron-phonon calculations\n, you should always choose a stable equilibrium structure.\n\nIf imaginary phonon frequencies are encountered during an electron-phonon calculation, VASP simply stops.\nIf\nELPH_IGNORE_IMAG_PHONONS\n= True\n, VASP instead skips the q-points at which the phonon frequencies are imaginary.\nThis can be useful since even a stable system can sometimes exhibit small imaginary phonon frequencies around the\nΓ\n{\\displaystyle \\Gamma}\n-point due to numerical inaccuracies.",
    "related_tags": [
      "ELPH_RUN",
      "IFC_ASR",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW"
    ]
  },
  "ELPH_ISMEAR": {
    "default_value": "ELPH_ISMEAR = 0",
    "description": "Chooses the smearing method to determine the fermi level and chemical potential before an electron-phonon calculation.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nELPH_ISMEAR\nis very similar to\nISMEAR\n.\nThe difference is that\nELPH_ISMEAR\nis used to determine the chemical potential in the context of electron-phonon calculation.\nThe Kohn-Sham states for which to calculate the chemical potential correspond to the\nk\n-point grid specified via the\nKPOINTS_ELPH\nfile.\n\nThe chemical potential is determined for the list of temperatures\nELPH_SELFEN_TEMPS\nand carrier concentrations specified by\nELPH_SELFEN_CARRIER_DEN\nor\nELPH_SELFEN_CARRIER_PER_CELL\n. Alternatively, one can specify the chemical potential and determine the carrier concentration using\nELPH_SELFEN_MU\n.\n\nTag options\n\nELPH_ISMEAR\n> 1\nMethod of Methfessel-Paxton of order\nELPH_ISMEAR\n(for details see\nISMEAR\n)\nELPH_ISMEAR\n= 0\nGaussian smearing (for details see\nISMEAR\n)\nELPH_ISMEAR\n= -1\nFermi-Dirac smearing (for details see\nISMEAR\n)\nELPH_ISMEAR\n= -4\nTetrahedron method (zero temperature) (for details see\nISMEAR\n)\nELPH_ISMEAR\n= -5\nTetrahedron method (zero temperature) with Blöchl corrections (for details see\nISMEAR\n)\nELPH_ISMEAR\n= -14\nTetrahedron method (finite temperature)\nELPH_ISMEAR\n= -15\nTetrahedron method (finite temperature) with Blöchl corrections",
    "related_tags": [
      "ISMEAR",
      "ELPH_SELFEN_MU",
      "KPOINTS_ELPH"
    ]
  },
  "ELPH_KSPACING": {
    "default_value": "ELPH_KSPACING = 0.5",
    "description": "The tag ELPH_KSPACING determines the k point mesh if the KPOINTS_ELPH file is not present.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nFor additional details of how the\nk\npoint mesh is generated, see the documentation of the\nKSPACING\ntag.",
    "related_tags": [
      "ELPH_RUN",
      "KPOINTS_ELPH",
      "KPOINTS_OPT_MODE"
    ]
  },
  "ELPH_LR": {
    "default_value": "ELPH_LR = 1",
    "description": "Controls the treatment of the long-range part of the electron-phonon potential.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis tag controls the treatment of the long-range electrostatic contributions to the electron-phonon coupling arising in polar dielectric materials.\n\nMind:\nIn this case, the required Born effective charges and dielectric tensor are read from the\nphelel_params.hdf5\nfile.\n\nModes\n\nELPH_LR\n≤ 0\nNo long-range correction scheme is applied to the electron-phonon coupling. This is most likely very inaccurate for semiconductors and insulators with non-vanishing Born effective charge.\nELPH_LR\n= 1\nDipole corrections are applied to the electron-phonon coupling\n[1]\n.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "IFC_LR"
    ]
  },
  "ELPH_MODE": {
    "default_value": "",
    "description": "Meta tag that selects reasonable defaults for electron-phonon calculations",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe required\nINCAR\nsettings for electron-phonon calculations depend on the type of calculation.\nFor example, computing the\nrenormalization of the electronic band structure\nrequires a different set of options than computing\ntransport properties\n.\nThe\nELPH_MODE\ntag can help you get started with electron-phonon calculations by selecting reasonable default values for other\nINCAR\ntags based on the type of calculation.\n\nThe individual tags that are set by\nELPH_MODE\ncan still be overwritten by specifying them explicitly in the\nINCAR\nfile.\n\nTag options\n\nELPH_MODE\n= renorm\n- Band-gap renormalization\n\nELPH_RUN\n= True\nELPH_SELFEN_FAN\n= True\nELPH_SELFEN_DW\n= True\nELPH_SELFEN_GAPS\n= True\nELPH_NBANDS\n= -2\nELPH_SELFEN_DELTA\n= 0.01\n\nELPH_MODE\n= transport\n- Transport calculation\n\nELPH_RUN\n= True\nELPH_TRANSPORT\n= True\nELPH_SELFEN_FAN\n= True\nELPH_SELFEN_DW\n= False\nELPH_SCATTERING_APPROX\n= serta mrta_lambda\nELPH_SELFEN_CARRIER_DEN\n= -1e21 -1e20 -1e19 -1e18 -1e17 -1e16 0 1e16 1e17 1e18 1e19 1e20 1e21\nELPH_SELFEN_DELTA\n= 0",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_TRANSPORT",
      "ELPH_DRIVER"
    ]
  },
  "ELPH_NBANDS": {
    "default_value": "ELPH_NBANDS = max( NELECT /2+NIONS/2, NELECT *0.6)",
    "description": "Number of bands to compute on the dense k point grid for the electron-phonon driver",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nFor\ntransport calculations\n, this value should be as little as possible while including all the states potentially participating in the transport calculation.\n\nIf\nELPH_NBANDS\n=-2 then the number of bands is set to the maximum number of plane waves. This setting is particularly useful for calculating the\nbandgap renormalization\n.\nIn this case, the final result converges slowly with the number of bands in the calculation, similar to\nRPA\n, and\nBSE\ncalculations.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_NBANDS_SUM",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW"
    ]
  },
  "ELPH_NBANDS_SUM": {
    "default_value": "ELPH_NBANDS_SUM = ELPH_NBANDS",
    "description": "Number of intermediate states to include in the computation of the phonon-induced electron self-energy.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe computation of the self-energy is achieved via a sum over intermediate states\n|\nΨ\nm\nk\n+\nq\n⟩\n{\\displaystyle |\\Psi_{m \\mathbf{k} + \\mathbf{q}}\\rangle}\n.\nELPH_NBANDS_SUM\nspecifies the maximum number of bands,\nN\nb\n{\\displaystyle N_{\\text{b}}}\n, such that\nm\n{\\displaystyle m}\nruns from\n1\n…\nN\nb\n{\\displaystyle 1 \\ldots N_{\\text{b}}}\n.\n\nMultiple values can be specified for\nELPH_NBANDS_SUM\n, in which case the self-energy is computed once for each value.\nThe results are reported in separate groups inside the\nvaspout.h5\nfile:\n\n/results/electron_phonon/electrons/self_energy_1\n/results/electron_phonon/electrons/self_energy_2\n/results/electron_phonon/electrons/self_energy_3\n...\n\nThis tag is useful for studying the convergence of the self-energy with respect to the number of intermediate states.\nAt a certain point, including more bands in the summation over states should no longer change the result.\n\nMind:\nWhen computing the renormalization of the electronic bandstructure, a large number of intermediate states may be necessary to reach convergence. If the self-energy still changes noticeably around\nELPH_NBANDS_SUM\n=\nELPH_NBANDS\n, then you may have to increase\nELPH_NBANDS\n.",
    "related_tags": [
      "Bandstructure renormalization",
      "ELPH_RUN",
      "ELPH_NBANDS",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW"
    ]
  },
  "ELPH_POT_FFT_MESH": {
    "default_value": "",
    "description": "Specifies the FFT mesh for mapping the electron-phonon potential to the primitive cell.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nOnce the electron-phonon potential\nhas been computed in the supercell\n, it needs to be mapped to the primitive cell.\nBy default, VASP chooses the primitive-cell FFT mesh to be consistent with the current\nENCUT\n.\nHowever, sometimes it might be necessary to specify the FFT grid dimensions manually via\nELPH_POT_FFT_MESH\n.\n\nThe chosen values must be the same as the desired\nNGX\n,\nNGY\nand\nNGZ\nof the electron-phonon calculation in the primitive cell.\n\nTip:\nIn order to find the FFT grid dimensions corresponding to the primitive cell, you can start a minimal VASP calculation in the primitive cell and extract the values for\nNGX\n,\nNGY\nand\nNGZ\nfrom the\nOUTCAR\nfile.",
    "related_tags": [
      "ELPH_POT_GENERATE",
      "ELPH_POT_LATTICE",
      "phelel_params.hdf5",
      "CONTCAR_ELPH",
      "Electron-phonon potential from supercells"
    ]
  },
  "ELPH_POT_GENERATE": {
    "default_value": "ELPH_POT_GENERATE = False",
    "description": "Calculates the electron-phonon potential from finite atomic displacements.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nPerforming electron-phonon calculations using\nmany-body perturbation theory\nrequires as input a\nphelel_params.hdf5\nfile.\nSetting\nELPH_POT_GENERATE\n= True\nprovides a way to generate the\nphelel_params.hdf5\nfile directly in VASP by\ncomputing the electron-phonon potential\n.\nThis is accomplished by using finite atomic displacements in a supercell.\nTherefore, in addition to setting\nELPH_POT_GENERATE\n= True\n, it is necessary to set\nIBRION\n= 6\nto activate the finite-difference routines.\n\nMind:\nWe currently do not support all symmetry operations when considering the atomic displacements for\nELPH_POT_GENERATE\n= True\n. Therefore, more atomic displacements are generated compared to typical finite-difference calculations using\nIBRION\n= 6\n.\n\nWhen\nELPH_POT_GENERATE\n= True\n, VASP will additionally produce the\nCONTCAR_ELPH\nfile.\nThis file contains the primitive-cell crystal structure in the\nPOSCAR\nformat and can directly be used as input for the subsequent electron-phonon calculation.\nThe primitive cell is automatically determined by VASP during the supercell calculation, but can optionally be specified via the\nELPH_POT_LATTICE\ntag.\n\nFinally, the electron-phonon potential in the\nphelel_params.hdf5\nfile is computed on a real-space FFT grid that has to match exactly the FFT grid dimensions (\nNGX\n,\nNGY\n,\nNGZ\n) of the primitive cell used in the subsequent electron-phonon calculation.\nThe dimensions of the FFT grid used to compute the electron-phonon potential can be chosen via the\nELPH_POT_FFT_MESH\ntag.\nIf one does not specify an FFT grid explicitly, VASP will determine the FFT grid dimensions automatically based on the current\nENCUT\n.\nThis should produce an FFT mesh for the electron-phonon potential that is compatible with the FFT mesh used in a primitive-cell calculation at the same\nENCUT\n.\n\nTip:\nThe\nPREC\nINCAR\ntag influences the size of the FFT mesh. Therefore, it is recommended to choose the same\nPREC\nfor both the supercell as well as the primitive-cell calculation.\n\nBasic information about the primitive-cell geometry and FFT grid is written to the\nOUTCAR\nfile in the following format:\n\nGeneration of phelel_params.hdf5\n ================================\n\nPrimitive cell \n   a1 =     1.78093078    1.78093078    0.00000000\n   a2 =     0.00000000    1.78093078    1.78093078\n   a3 =     1.78093078    0.00000000    1.78093078\n\nPrimitive FFT mesh =     18    18    18\n\nIt is also written to the machine-readable\nvaspout.h5\nfile at the following HDF5 paths:\n\nresults/elph_potential/primitive_positions\nresults/elph_potential/primitive_fft_mesh\n\nThis information is already contained within the generated\nphelel_params.hdf5\nfile.\nHowever, it is mirrored in the standard output to make it easier for users to check their calculations and to automate workflows.",
    "related_tags": [
      "ELPH_POT_LATTICE",
      "ELPH_POT_FFT_MESH",
      "IBRION",
      "Electron-phonon potential from supercells",
      "phelel_params.hdf5",
      "CONTCAR_ELPH"
    ]
  },
  "ELPH_POT_LATTICE": {
    "default_value": "",
    "description": "Allows specifying an alternative primitive cell for the mapping of the electron-phonon potential.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nOnce the electron-phonon potential\nhas been computed in the supercell\n, it needs to be mapped to the primitive cell.\nThis is done via\nELPH_POT_GENERATE\n= True\n.\nBy default, VASP performs the mapping for the primitive cell that is found by the symmetry routines and that is reported in the\nOUTCAR\nfile.\nIn cases where the primitive cell needs to be specified manually,\nELPH_POT_LATTICE\ncan be used.\n\nELPH_POT_LATTICE\n= a1x a1y a1z a2x a2y a2z a3x a3y a3z\nspecifies the three primitive lattice vectors\na\n1\n{\\displaystyle \\mathbf{a}_1}\n,\na\n2\n{\\displaystyle \\mathbf{a}_2}\nand\na\n3\n{\\displaystyle \\mathbf{a}_3}\nin Cartesian coordinates.\nThese lattice vectors are then used to construct the primitive-cell information in the\nphelel_params.hdf5\nfile.\n\nMind:\nThe supplied lattice vectors must span a valid primitive cell of the supercell or the code will exit with an error.\n\nTip:\nThe primitive cell used for mapping is also written to the\nCONTCAR_ELPH\nfile, which can conveniently be used as the\nPOSCAR\ninput for the subsequent electron-phonon calculation. This ensures that the primitive-cell calculation is consistent with the information in the\nphelel_params.hdf5\nfile.",
    "related_tags": [
      "ELPH_POT_GENERATE",
      "ELPH_POT_FFT_MESH",
      "phelel_params.hdf5",
      "CONTCAR_ELPH",
      "Electron-phonon potential from supercells"
    ]
  },
  "ELPH_PREPARE": {
    "default_value": "ELPH_PREPARE = .FALSE.",
    "description": "Writes the potential, the force-constants and other information related to electron-phonon interactions to the vaspout.h5 file.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nIn order to calculate electron-phonon interactions, one must first\nperform finite-difference calculations in the supercell\nand generate the\nphelel_params.hdf5\nfile.\nTo do this using\nphelel\n, it is necessary to provide additional supercell information to phelel.\nThis is accomplished by setting\nELPH_PREPARE\n= True\nin each involved supercell calculation.\nAfterwards, phelel can be used to calculate the required derivatives and produce the\nphelel_params.hdf5\nfile.\nFor further information on this workflow, please consult the online documentation of\nphelel\n.",
    "related_tags": [
      "Electron-phonon potential from supercells",
      "phelel_params.hdf5"
    ]
  },
  "ELPH_RUN": {
    "default_value": "ELPH_RUN = .false.",
    "description": "Select whether to run and electron-phonon calculation.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis flag determined whether an electron-phonon calculation should be performed.\nThe most fundamental quantity we compute are the electron-phonon matrix elements.\n\nThese can simply be written to file when\nELPH_DRIVER\n= MELS\nfor further post-processing.\nAdditionally, one can directly use these matrix elements to compute the electron self-energy due to electron-phonon coupling\nELPH_DRIVER\n= EL\n.\nThe self-energy can in turn be used to compute the\nrenormalization of the electronic bandstructure\nor\ntransport coefficients involving electron-phonon scattering\n.\n\nAdditionally, the tag\nELPH_MODE\nsets defaults for other\nINCAR\ntags depending on the quantities of interest.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_TRANSPORT",
      "ELPH_MODE",
      "ELPH_DRIVER"
    ]
  },
  "ELPH_SCATTERING_APPROX": {
    "default_value": "ELPH_SCATTERING_APPROX = SERTA MRTA_LAMBDA",
    "description": "Select which type of approximation is used to compute the electron scattering lifetimes due to electron-phonon coupling",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThere are different approximations to compute the electronic lifetimes due to electron-phonon scattering.\nEach of these can lead to significantly different transport coefficients.\nIt is possible to select more than one approximation in\nELPH_SCATTERING_APPROX\n.\nIn this case, additional\nelectron-phonon accumulators\nare created for each scattering approximation.\n\nOptions to select\n\nELPH_SCATTERING_APPROX\n= CRTA\n-\nC\nonstant\nR\nelaxation-\nT\nime\nA\npproximation\nThe relaxation time is assumed constant. It needs to be specified via\nTRANSPORT_RELAXATION_TIME\n. In this case, the computation of electron-phonon matrix elements is skipped entirely, which is a huge performance boost compared to the other relaxation-time approximations.\n\nWarning:\nWhile the CRTA can be a reasonable approximation for metals, it will generally fail for insulators.\n\nELPH_SCATTERING_APPROX\n= SERTA\n-\nS\nelf-\nE\nnergy\nR\nelaxation-\nT\nime\nA\npproximation\nComputes the relaxation time from the imaginary part of the Fan self-energy, evaluated on the electronic eigenenergy:\n1\nτ\nn\nk\nS\nE\nR\nT\nA\n=\n2\nπ\nℏ\n∑\nn\n′\nν\nk\n′\nw\nn\nk\n,\nn\n′\nk\n′\n|\ng\nn\nk\n,\nn\n′\nk\n′\nν\n|\n2\n[\n(\nn\nν\nq\n+\n1\n−\nf\nn\n′\nk\n′\n)\nδ\n(\nε\nn\nk\n−\nε\nn\n′\nk\n′\n−\nℏ\nω\nν\nq\n)\n+\n(\nn\nν\nq\n+\nf\nn\n′\nk\n′\n)\nδ\n(\nε\nn\nk\n−\nε\nn\n′\nk\n′\n+\nℏ\nω\nν\nq\n)\n]\n{\\displaystyle \n\\frac{1}{\\tau^{\\mathrm{SERTA}}_{n\\mathbf{k}}} = \\frac{2\\pi}{\\hbar} \\sum_{n'\\nu\\mathbf{k}'} w_{n\\mathbf{k},n'\\mathbf{k}'} \\, |g^{\\nu}_{n\\mathbf{k},n'\\mathbf{k}'}|^2 \\left[ (n_{\\nu\\mathbf{q}} + 1 - f_{n'\\mathbf{k}'}) \\, \\delta(\\varepsilon_{n\\mathbf{k}} - \\varepsilon_{n'\\mathbf{k}'} - \\hbar\\omega_{\\nu\\mathbf{q}}) + (n_{\\nu\\mathbf{q}} + f_{n'\\mathbf{k}'}) \\, \\delta(\\varepsilon_{n\\mathbf{k}} - \\varepsilon_{n'\\mathbf{k}'} + \\hbar\\omega_{\\nu\\mathbf{q}}) \\right]\n}\nHere, the scattering weight is:\nw\nn\nk\n,\nn\n′\nk\n′\n=\n1\n{\\displaystyle \nw_{n\\mathbf{k},n'\\mathbf{k}'} = 1\n}\n\nELPH_SCATTERING_APPROX\n= ERTA_LAMDBA\n-\nE\nnergy\nR\nelaxation-\nT\nime\nA\npproximation (mean-free path approximation)\nApplies an energy-projected weight scaled by mean-free path:\nw\nn\nk\n,\nn\n′\nk\n′\n=\n(\n1\n−\nv\nn\nk\n⋅\nv\nn\n′\nk\n′\n|\nv\nn\nk\n|\n|\nv\nn\n′\nk\n′\n|\n)\n|\nε\nn\n′\nk\n′\n−\nμ\nε\nn\nk\n−\nμ\n|\n{\\displaystyle \nw_{n\\mathbf{k},n'\\mathbf{k}'} = \\left(1 - \\frac{\\mathbf{v}_{n\\mathbf{k}} \\cdot \\mathbf{v}_{n'\\mathbf{k}'}}{|\\mathbf{v}_{n\\mathbf{k}}| |\\mathbf{v}_{n'\\mathbf{k}'}|}\\right) \\left| \\frac{\\varepsilon_{n'\\mathbf{k}'} - \\mu}{\\varepsilon_{n\\mathbf{k}} - \\mu} \\right|\n}\n\nWarning:\nAs of vasp 6.5.1 this approximation is wrongly implemented. It should be\nw\nn\nk\n,\nn\n′\nk\n′\n=\n(\n1\n−\nv\nn\nk\n⋅\nv\nn\n′\nk\n′\n|\nv\nn\nk\n|\n|\nv\nn\n′\nk\n′\n|\n|\nε\nn\n′\nk\n′\n−\nμ\nε\nn\nk\n−\nμ\n|\n)\n{\\displaystyle \nw_{n\\mathbf{k},n'\\mathbf{k}'} = \\left(1 - \\frac{\\mathbf{v}_{n\\mathbf{k}} \\cdot \\mathbf{v}_{n'\\mathbf{k}'}}{|\\mathbf{v}_{n\\mathbf{k}}| |\\mathbf{v}_{n'\\mathbf{k}'}|} \\left| \\frac{\\varepsilon_{n'\\mathbf{k}'} - \\mu}{\\varepsilon_{n\\mathbf{k}} - \\mu} \\right|\\right)\n}\n\nELPH_SCATTERING_APPROX\n= ERTA_TAU\n-\nE\nnergy\nR\nelaxation-\nT\nime\nA\npproximation (lifetime approximation)\nw\nn\nk\n,\nn\n′\nk\n′\n=\n(\n1\n−\nv\nn\nk\n⋅\nv\nn\n′\nk\n′\n|\nv\nn\nk\n|\n2\n)\n|\nε\nn\n′\nk\n′\n−\nμ\nε\nn\nk\n−\nμ\n|\n{\\displaystyle \nw_{n\\mathbf{k},n'\\mathbf{k}'} = \\left(1 - \\frac{\\mathbf{v}_{n\\mathbf{k}} \\cdot \\mathbf{v}_{n'\\mathbf{k}'}}{|\\mathbf{v}_{n\\mathbf{k}}|^2}\\right) \\left| \\frac{\\varepsilon_{n'\\mathbf{k}'} - \\mu}{\\varepsilon_{n\\mathbf{k}} - \\mu} \\right|\n}\n\nWarning:\nAs of vasp 6.5.1 this approximation is wrongly implemented. It should be\nw\nn\nk\n,\nn\n′\nk\n′\n=\n(\n1\n−\nv\nn\nk\n⋅\nv\nn\n′\nk\n′\n|\nv\nn\nk\n|\n2\n|\nε\nn\n′\nk\n′\n−\nμ\nε\nn\nk\n−\nμ\n|\n)\n{\\displaystyle \nw_{n\\mathbf{k},n'\\mathbf{k}'} = \\left(1 - \\frac{\\mathbf{v}_{n\\mathbf{k}} \\cdot \\mathbf{v}_{n'\\mathbf{k}'}}{|\\mathbf{v}_{n\\mathbf{k}}|^2} \\left| \\frac{\\varepsilon_{n'\\mathbf{k}'} - \\mu}{\\varepsilon_{n\\mathbf{k}} - \\mu} \\right|\\right)\n}\n\nELPH_SCATTERING_APPROX\n= MRTA_LAMDBA\n-\nM\nomentum\nR\nelaxation-\nT\nime\nA\npproximation (mean-free path approximation)\nw\nn\nk\n,\nn\n′\nk\n′\n=\n(\n1\n−\nv\nn\nk\n⋅\nv\nn\n′\nk\n′\n|\nv\nn\nk\n|\n|\nv\nn\n′\nk\n′\n|\n)\n{\\displaystyle \nw_{n\\mathbf{k},n'\\mathbf{k}'} = \\left(1 - \\frac{\\mathbf{v}_{n\\mathbf{k}} \\cdot \\mathbf{v}_{n'\\mathbf{k}'}}{|\\mathbf{v}_{n\\mathbf{k}}|  |\\mathbf{v}_{n'\\mathbf{k}'}|}\\right)\n}\n\nELPH_SCATTERING_APPROX\n= MRTA_TAU\n-\nM\nomentum\nR\nelaxation-\nT\nime\nA\npproximation (lifetime approximation)\nw\nn\nk\n,\nn\n′\nk\n′\n=\n(\n1\n−\nv\nn\nk\n⋅\nv\nn\n′\nk\n′\n|\nv\nn\nk\n|\n2\n)\n{\\displaystyle \nw_{n\\mathbf{k},n'\\mathbf{k}'} = \\left(1 - \\frac{\\mathbf{v}_{n\\mathbf{k}} \\cdot \\mathbf{v}_{n'\\mathbf{k}'}}{|\\mathbf{v}_{n\\mathbf{k}}|^2}\\right)\n}",
    "related_tags": [
      "Transport calculations",
      "Electron-phonon accumulators",
      "ELPH_RUN",
      "TRANSPORT_RELAXATION_TIME"
    ]
  },
  "ELPH_SELFEN_BAND_START": {
    "default_value": "ELPH_SELFEN_BAND_START = 1",
    "description": "Compute the electron self-energy due to electron-phonon coupling only for bands with indices starting from ELPH_SELFEN_BAND_START .",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis tag can be used in combination with\nELPH_SELFEN_KPTS\n,\nELPH_SELFEN_IKPT\nor\nELPH_SELFEN_BAND_STOP\nto limit the calculation of the electron-phonon self-energy to a particular set of\nk\n-points and bands.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_SELFEN_GAPS",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_KPTS",
      "ELPH_SELFEN_IKPT",
      "ELPH_SELFEN_BAND_STOP"
    ]
  },
  "ELPH_SELFEN_BAND_STOP": {
    "default_value": "ELPH_SELFEN_BAND_STOP = ELPH_NBANDS",
    "description": "Compute the electron self-energy due to electron-phonon coupling only for bands with indices until ELPH_SELFEN_BAND_STOP .",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis tag can be used in combination with\nELPH_SELFEN_KPTS\n,\nELPH_SELFEN_IKPT\nor\nELPH_SELFEN_BAND_START\nto limit the calculation of the electron-phonon self-energy to a particular set of\nk\n-points and bands.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_SELFEN_GAPS",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_KPTS",
      "ELPH_SELFEN_IKPT",
      "ELPH_SELFEN_BAND_START"
    ]
  },
  "ELPH_SELFEN_CARRIER_DEN": {
    "default_value": "ELPH_SELFEN_CARRIER_DEN = 0.0",
    "description": "List of additional carrier densities in units of c m − 3 {\\displaystyle cm^{-3}} at which to compute the phonon-mediated electron self-energy and transport coefficients.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nFrom each carrier density specified in the array, a positive (electron doping) or negative (hole doping) number of electrons is added to the value of\nNELECT\nand the chemical potential computed for the list of temperatures specified by\nELPH_SELFEN_TEMPS\n.\n\nFor example, if\nELPH_SELFEN_CARRIER_DEN\n= 1e+16 1e+17 1e+18\nthe\nChemical potential\nsection in the\nOUTCAR\nfile might show something like\n\nNumber of electrons per cell\n                  ----------------------------\nT=      0.00000000    18.00000048    18.00000477    18.00004770\nT=    100.00000000    18.00000048    18.00000477    18.00004770\nT=    200.00000000    18.00000048    18.00000477    18.00004770\nT=    300.00000000    18.00000048    18.00000477    18.00004770\nT=    400.00000000    18.00000048    18.00000477    18.00004770\nT=    500.00000000    18.00000048    18.00000477    18.00004770\n                  ----------------------------\n                      Chemical potential\n                  ----------------------------\nT=      0.00000000     3.59844447     3.63257112     3.70609450\nT=    100.00000000     3.59030071     3.62874001     3.70431410\nT=    200.00000000     3.56867975     3.61741491     3.69897926\nT=    300.00000000     3.56382644     3.60063388     3.69013925\nT=    400.00000000     3.57552043     3.59226062     3.67812706\nT=    500.00000000     3.58994519     3.59815865     3.66491104\n                  ----------------------------\n\nIn the above tables, the number of elements in\nELPH_SELFEN_CARRIER_DEN\ndetermines the number of columns, while the number of elements in\nELPH_SELFEN_TEMPS\ndetermines the number of rows.\nSpecifying more than one carrier density in\nELPH_SELFEN_CARRIER_DEN\ncreates additional\nelectron-phonon accumulators\n.\n\nInstead of specifying a carrier density, it is possible to explicitly specify the additional number of electrons to be added by using the\nELPH_SELFEN_CARRIER_PER_CELL\ntag. Alternatively, one can specify the chemical potential directly and determine the carrier concentration using\nELPH_SELFEN_MU\n.\n\nThe information related to the chemical potential calculation can be found under the\nChemical potential calculation\nsection in the\nOUTCAR\n.",
    "related_tags": [
      "Transport calculations",
      "Electron-phonon accumulators",
      "ELPH_RUN",
      "ELPH_SELFEN_CARRIER_PER_CELL",
      "ELPH_SELFEN_MU",
      "ELPH_SELFEN_TEMPS",
      "NELECT"
    ]
  },
  "ELPH_SELFEN_CARRIER_PER_CELL": {
    "default_value": "ELPH_SELFEN_CARRIER_PER_CELL = 0.0",
    "description": "List of additional number of carriers for which to compute the phonon-mediated electron self-energy and transport coefficients.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nEach number of carriers specified in the array is added to the value of\nNELECT\nand the chemical potential computed for the list of temperatures specified by\nELPH_SELFEN_TEMPS\n.\nA positive number adds electrons (electron doping), while a negative one removes (hole doping).\n\nFor example,\nELPH_SELFEN_CARRIER_PER_CELL\n= 0.001 0.01 0.1\nmeans that the number of electrons per cell\nNELECT\n= 18\nwill be increased by the specified values which will produce the following table in the\nChemical potential calculation\nsection in the\nOUTCAR\nfile\n\nNumber of electrons per cell\n                  ----------------------------\nT=      0.00000000    18.00100000    18.01000000    18.10000000\nT=    100.00000000    18.00100000    18.01000000    18.10000000\nT=    200.00000000    18.00100000    18.01000000    18.10000000\nT=    300.00000000    18.00100000    18.01000000    18.10000000\nT=    400.00000000    18.00100000    18.01000000    18.10000000\nT=    500.00000000    18.00100000    18.01000000    18.10000000\n                  ----------------------------\n                      Chemical potential\n                  ----------------------------\nT=      0.00000000     3.94721622     4.38382135     4.91829386\nT=    100.00000000     3.94656996     4.38304274     4.91799255\nT=    200.00000000     3.94463398     4.38100398     4.91688588\nT=    300.00000000     3.94140548     4.37778815     4.91488514\nT=    400.00000000     3.93688727     4.37341919     4.91204101\nT=    500.00000000     3.93108216     4.36792102     4.90841405\n                  ----------------------------\n\nThe number of elements in\nELPH_SELFEN_CARRIER_PER_CELL\ndetermines the number of columns in the tables above, while\nELPH_SELFEN_TEMPS\ndetermines the number of rows.\nSpecifying more than one carrier density in\nELPH_SELFEN_CARRIER_PER_CELL\ncreates additional\nelectron-phonon accumulators\n.\n\nInstead of specifying the number of carriers, it is possible to specify an additional carrier density in units of\nm\n−\n3\n{\\displaystyle {m^{-3}}}\nvia the\nELPH_SELFEN_CARRIER_DEN\ntag. Alternatively, one can specify the chemical potential and determine the carrier concentration using\nELPH_SELFEN_MU\n.",
    "related_tags": [
      "Transport calculations",
      "Electron-phonon accumulators",
      "ELPH_RUN",
      "ELPH_SELFEN_CARRIER_DEN",
      "ELPH_SELFEN_MU",
      "ELPH_SELFEN_TEMPS",
      "NELECT"
    ]
  },
  "ELPH_SELFEN_DELTA": {
    "default_value": "ELPH_SELFEN_DELTA = 0.01",
    "description": "Complex imaginary shift to use when computing the self-energy due to electron-phonon coupling.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nIf the value is set to 0.0 then the tetrahedron method is used to perform the Brillouin zone integrals and evaluate only the imaginary part of the electron self-energy. This is the recommended option for\ntransport calculations\n.\n\nFor\nbandgap renormalization\nsince one is mainly interested in the real part of the self-energy due to electron-phonon coupling, a small finite value should be used and a dense\nk\npoint mesh used.\n\nIf more than one value is specified, the number of self-energy accumulators is increased such that one exists for each value in this array.\nIt is possible to compute the self-energy using the tetrahedron method and a finite complex shift in the same run.",
    "related_tags": [
      "Bandstructure renormalization",
      "ELPH_RUN",
      "ELPH_SELFEN_GAPS",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_STATIC"
    ]
  },
  "ELPH_SELFEN_DW": {
    "default_value": "ELPH_SELFEN_DW = .FALSE.",
    "description": "Controls whether the Debye-Waller contribution is included in the calculation of the phonon-induced electron self-energy.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe phonon-induced electron self-energy has two contributions at second order in perturbation theory, the Fan-Migdal self-energy and the real-valued Debye-Waller self-energy.\nELPH_SELFEN_DW\ncontrols the computation of the latter, while the former can be computed via\nELPH_SELFEN_FAN\n.\n\nThe result is reported individually for each self-energy accumulator in the\nvaspout.h5\nfile as\n\n/results/electron_phonon/electrons/self_energy_1/selfen_dw\n\nMind:\nThe Debye-Waller self-energy is computed using the rigid-ion approximation\n[1]\n.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_SELFEN_GAPS",
      "ELPH_SELFEN_FAN"
    ]
  },
  "ELPH_SELFEN_FAN": {
    "default_value": "ELPH_SELFEN_FAN = .FALSE.",
    "description": "Controls whether the Fan-Migdal contribution is included in the calculation of the phonon-induced electron self-energy.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe phonon-induced electron self-energy has two contributions at second order in perturbation theory, the Fan-Migdal self-energy and the real-valued Debye-Waller self-energy.\nELPH_SELFEN_FAN\ncontrols the computation of the former, while the latter can be computed via\nELPH_SELFEN_DW\n.\n\nThe result is reported individually for each self-energy accumulator in the\nvaspout.h5\nfile as\n\n/results/electron_phonon/electrons/self_energy_1/selfen_fan",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_SELFEN_DW",
      "ELPH_SELFEN_STATIC"
    ]
  },
  "ELPH_SELFEN_GAPS": {
    "default_value": "ELPH_SELFEN_GAPS = .false.",
    "description": "Find the direct and indirect gaps and the valence and conduction Kohn-Sham states that form it and select to compute their self-energy due to electron-phonon coupling.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis tag additionally activates the reporting of the value of the band-gap renormalization to the standard output, the\nOUTCAR\nfile\n\n$ grep -A7 'KS-QP gap (meV)' OUTCAR\n\nand the\nvaspout.h5\nfile under\n\n$ h5ls -r vaspout.h5 | grep gap_renorm\n /results/electron_phonon/electrons/self_energy_1/direct_gap_renorm\n /results/electron_phonon/electrons/self_energy_1/fundamental_gap_renorm`\n\nThis output is reported once for each\nelectron-phonon accumulator\n.\n\nIf instead, the computation of the self-energy for a particular set of states is desired, those can be manually specified using a combination of\nELPH_SELFEN_KPTS\n,\nELPH_SELFEN_IKPT\n,\nELPH_SELFEN_BAND_START\nand\nELPH_SELFEN_BAND_STOP\n.",
    "related_tags": [
      "Bandstructure renormalization",
      "Electron-phonon accumulators",
      "ELPH_RUN",
      "ELPH_SELFEN_BAND_START",
      "ELPH_SELFEN_BAND_STOP"
    ]
  },
  "ELPH_SELFEN_IKPT": {
    "default_value": "ELPH_SELFEN_IKPT = All k-points",
    "description": "Compute the electron self-energy due to electron-phonon for a list of k-points specified by their index in the irreducible Brillouin zone generated from KPOINTS_ELPH .",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nFor example, to select to compute for 4 different\nk\npoints we specify their index in the\nINCAR\nfile\n\nELPH_SELFEN_IKPT\n= 1 3 6 8\n\nThis tag can be used in combination with\nELPH_SELFEN_BAND_START\nand\nELPH_SELFEN_BAND_STOP\nto select the calculation of the electron-phonon self-energy for a particular set of\nk\npoints and bands.\nInstead of specifying the indexes of the\nk\npoints in the irreducible Brillouin zone, one can specify their reduced coordinates with\nELPH_SELFEN_KPTS\n.\n\nInstead of specifying the index of the\nk\npoint appearing the in irreducible Brillouin zone, one can specify the reduced coordinates of the desired k-points using\nELPH_SELFEN_KPTS\n.",
    "related_tags": [
      "ELPH_RUN",
      "KPOINTS_ELPH",
      "ELPH_SELFEN_GAPS",
      "ELPH_SELFEN_BAND_START",
      "ELPH_SELFEN_BAND_STOP",
      "ELPH_SELFEN_KPTS"
    ]
  },
  "ELPH_SELFEN_KPTS": {
    "default_value": "ELPH_SELFEN_KPTS = All k-points",
    "description": "Computes the electron self-energy due to electron-phonon for a list of k-points specified by their fractional coordinates.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nFor example, to select 4 different\nk\n-points we specify their coordinates in the\nINCAR\nfile\n\nELPH_SELFEN_KPTS\n= \\\n  0.0  0.0  0.0 \\\n  0.5  0.5  0.0 \\\n  0.5  0.5  0.0 \\\n  0.5  0.75 0.25\n\nThe matching of the user input coordinates with the ones generated from the\nKPOINTS_ELPH\nfile in VASP is done by looking at the closest point in the full Brillouin zone, which is then mapped to the point in the irreducible Brillouin zone.\nThe user should always check whether the matching found and reported in the\nOUTCAR\nis correct.\n\nThis tag can be used in combination with\nELPH_SELFEN_BAND_START\nand\nELPH_SELFEN_BAND_STOP\nto select the calculation of the electron-phonon self-energy for a particular set of\nk\npoints and bands.\n\nInstead of specifying the reduced coordinates, one can specify the index of the\nk\npoint appearing the in irreducible Brillouin zone list using\nELPH_SELFEN_IKPT\n.",
    "related_tags": [
      "ELPH_RUN",
      "KPOINTS_ELPH",
      "ELPH_SELFEN_GAPS",
      "ELPH_SELFEN_BAND_START",
      "ELPH_SELFEN_BAND_STOP",
      "ELPH_SELFEN_IKPT"
    ]
  },
  "ELPH_SELFEN_MU": {
    "default_value": "ELPH_SELFEN_MU = 0.0",
    "description": "List of chemical potentials at which to compute the phonon-mediated electron self-energy and transport coefficients.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nEach chemical potential specified in the list will be added to the Fermi energy determined for the\nk\npoint grid\nKPOINTS_ELPH\n.\nThis Fermi energy might be different from the one determined in the self-consistent calculation if the\nk\npoint meshes or\nELPH_ISMEAR\nis different from\nISMEAR\n.\nThe Fermi energy from the self-consistent and non-self-consistent calculations can be read from the\nOUTCAR\nfile. For example\n\n$ grep \"Fermi energy\" OUTCAR\n Fermi energy:         3.5134142202\n Fermi energy:         3.5314189274 eV (dense k-point grid)\n\nIn this example,\nELPH_SELFEN_MU\n= 0.1\nmeans that the chemical potential will be set to 3.5314189274+0.1 eV.\nThis can be verified\nChemical potential calculation\nsection of the\nOUTCAR\nfile.\n\nNumber of electrons per cell\n                  ----------------------------\nT=      0.00000000    18.00000452\nT=    100.00000000    18.00000536\nT=    200.00000000    18.00000792\nT=    300.00000000    18.00001223\nT=    400.00000000    18.00001792\nT=    500.00000000    18.00002315\n\n                  ----------------------------\n                      Chemical potential\n                  ----------------------------\nT=      0.00000000     3.63141893\nT=    100.00000000     3.63141893\nT=    200.00000000     3.63141893\nT=    300.00000000     3.63141893\nT=    400.00000000     3.63141893\nT=    500.00000000     3.63141893\n                  ----------------------------\n\nFor each of these chemical potentials and temperatures, the number of electrons per cell is computed and reported.\nThese, in turn, can be converted to a carrier density by dividing be the volume of the unit cell.\nIf more than one value is present in\nELPH_SELFEN_MU\n, more columns are added to the list of chemical potentials above and more instances of the electron self-energy\naccumulators\nare created.\nThe number of rows is set by the list of temperatures in\nELPH_SELFEN_TEMPS\n.\n\nAlternatively, one can specify the carrier density in units of\nm\n−\n3\n{\\displaystyle {m^{-3}}}\nby using the\nELPH_SELFEN_CARRIER_DEN\ntag.",
    "related_tags": [
      "Transport calculations",
      "Electron-phonon accumulators",
      "ELPH_RUN",
      "ELPH_SELFEN_CARRIER_DEN",
      "ELPH_SELFEN_CARRIER_PER_CELL",
      "ELPH_SELFEN_TEMPS",
      "NELECT"
    ]
  },
  "ELPH_SELFEN_NW": {
    "default_value": "ELPH_SELFEN_NW = 1",
    "description": "Number of energies to use when computing the phonon-induced electron self-energy.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe electron self-energy,\nΣ\nn\nk\n(\nω\n)\n{\\displaystyle \\Sigma_{n \\mathbf{k}}(\\omega)}\n, depends on the frequency\nω\n{\\displaystyle \\omega}\n(or energy\nℏ\nω\n{\\displaystyle \\hbar \\omega}\n).\nELPH_SELFEN_NW\ncontrols the number and location of frequencies when computing the self-energy in the following way:\n\nELPH_SELFEN_NW\n> 0\nThe self-energy is computed at\nELPH_SELFEN_NW\nequally spaced energies between\nε\nn\nk\n−\n1\n2\nE\nW\n{\\displaystyle \\varepsilon_{n \\mathbf{k}} - \\frac{1}{2} E^{\\text{W}}}\nand\nε\nn\nk\n+\n1\n2\nE\nW\n{\\displaystyle \\varepsilon_{n \\mathbf{k}} + \\frac{1}{2} E^{\\text{W}}}\n. The interval is centered around each Kohn-Sham eigenvalue,\nε\nn\nk\n{\\displaystyle \\varepsilon_{n \\mathbf{k}}}\n, and its width,\nE\nW\n{\\displaystyle E^{\\text{W}}}\n, is controlled via\nELPH_SELFEN_WRANGE\n. If\nELPH_SELFEN_NW\nis an even number, it is automatically increased by one so that the center-most energy in each interval always coincides with the corresponding Kohn-Sham eigenvalue.\nELPH_SELFEN_NW\n< 0\nThe self-energy is computed at |\nELPH_SELFEN_NW\n| equally spaced energies between\nε\nk\nmin\n−\n1\n2\nE\nW\n{\\displaystyle \\varepsilon^{\\text{min}}_{\\mathbf{k}} - \\frac{1}{2} E^{\\text{W}}}\nand\nε\nk\nmax\n+\n1\n2\nE\nW\n{\\displaystyle \\varepsilon^{\\text{max}}_{\\mathbf{k}} + \\frac{1}{2} E^{\\text{W}}}\n, where\nε\nk\nmin\n{\\displaystyle \\varepsilon^{\\text{min}}_{\\mathbf{k}}}\nand\nε\nk\nmax\n{\\displaystyle \\varepsilon^{\\text{max}}_{\\mathbf{k}}}\nare the minimum and maximum Kohn-Sham eigenvalues of the calculation, respectively. Once again,\nE\nW\n{\\displaystyle E^{\\text{W}}}\nis controlled via\nELPH_SELFEN_WRANGE\nand allows to extend the interval in both directions.",
    "related_tags": [
      "ELPH_RUN",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW",
      "ELPH_SELFEN_WRANGE"
    ]
  },
  "ELPH_SELFEN_STATIC": {
    "default_value": "ELPH_SELFEN_STATIC = .FALSE.",
    "description": "Activates the adiabatic approximation for the phonon-induced electron self-energy.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe adiabatic approximation assumes that the electron dynamics are much faster than the phonon dynamics.\nIn other words, there is no energy exchange between the electronic and the phononic subsystems.\nMathematically, this is equivalent to setting the phonon frequencies in the denominator of the Fan-Migdal self-energy to zero.\n\nWarning:\nThe adiabatic approximation is ill-suited for polar materials where it may introduce large errors\n[1]\n.",
    "related_tags": [
      "ELPH_RUN",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DELTA"
    ]
  },
  "ELPH_SELFEN_TEMPS": {
    "default_value": "ELPH_SELFEN_TEMPS = 0 100 200 300 400 500",
    "description": "List of temperatures for which to compute the electron self-energy due to electron-phonon coupling.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis list of temperatures is used to determine the chemical potential, the occupation factors entering the electron self-energy due to electron-phonon coupling as well as the transport coefficients in the context of a\ntransport calculation\n.\n\nThe chemical potential is determined for the list of temperatures\nELPH_SELFEN_TEMPS\nand carrier concentrations specified by\nELPH_SELFEN_CARRIER_DEN\nor\nELPH_SELFEN_CARRIER_PER_CELL\n. Alternatively, one can specify the chemical potential and determine the carrier concentration using\nELPH_SELFEN_MU\n.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW"
    ]
  },
  "ELPH_SELFEN_WRANGE": {
    "default_value": "ELPH_SELFEN_WRANGE = 0",
    "description": "Together with ELPH_SELFEN_NW specifies the energy window in which to evaluate the phonon-induced electron self-energy.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe electron self-energy,\nΣ\nn\nk\n(\nω\n)\n{\\displaystyle \\Sigma_{n \\mathbf{k}}(\\omega)}\n, depends on the frequency\nω\n{\\displaystyle \\omega}\n(or energy\nℏ\nω\n{\\displaystyle \\hbar \\omega}\n).\nThe tag\nELPH_SELFEN_WRANGE\ndetermines the width of the energy window in which to evaluate the self-energy.\nHowever, the location and width of the energy window is also influenced by the sign of\nELPH_SELFEN_NW\n.\nFor more information, we refer to the documentation of\nELPH_SELFEN_NW\n.",
    "related_tags": [
      "ELPH_RUN",
      "ELPH_SELFEN_FAN",
      "ELPH_SELFEN_DW",
      "ELPH_SELFEN_NW"
    ]
  },
  "ELPH_TRANSPORT": {
    "default_value": "ELPH_TRANSPORT = .FALSE.",
    "description": "Activates transport calculation involving electron-phonon coupling",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nWhen\nELPH_TRANSPORT\n= True\n, VASP calculates the transport coefficients from the linearized Boltzmann transport equation.\nIn this framework, the transport coefficients are calculated from various relaxation-time approximations selectable via\nELPH_SCATTERING_APPROX\n.\nA convenient way to start transport calculations is to set\nELPH_MODE\n= transport\n, which automatically provides reasonable default values for the required\nINCAR\ntags.\n\nFor more information, visit the how-to page on\ntransport calculations\n.",
    "related_tags": [
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_MODE",
      "ELPH_SCATTERING_APPROX"
    ]
  },
  "ELPH_TRANSPORT_DFERMI_TOL": {
    "default_value": "ELPH_TRANSPORT_DFERMI_TOL = 1e-6",
    "description": "choose the percentage of the integral of the derivative of the Fermi-dirac distribution with respect to the energy that is excluded from the integral that yields the Onsager coefficients.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nUsing this parameter, the values of\nELPH_TRANSPORT_EMIN\nand\nELPH_TRANSPORT_EMAX\nare automatically computed based on the list of chemical potential and the integral of the derivative of the Fermi-dirac distribution.\nThis allows having a material independent parameter that is used to determine the energy window for which the electronic lifetimes must be computed.\n\nA small value means that only the tails of the derivative of the Fermi-dirac distribution are excluded from the integral.\nA large value means that only a small energy window around the chemical potential is used.\n\nThe number of energy points is determined by\nTRANSPORT_NEDOS\n.",
    "related_tags": [
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_TRANSPORT",
      "ELPH_TRANSPORT_EMIN",
      "ELPH_TRANSPORT_EMAX",
      "TRANSPORT_NEDOS"
    ]
  },
  "ELPH_TRANSPORT_DRIVER": {
    "default_value": "ELPH_TRANSPORT_DRIVER = ELPH_TRANSPORT_DRIVER",
    "description": "choose method to compute the Onsager coefficients, which are then used to compute the transport coefficients.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe transport coefficients can be computed using either of the options bellow, each with its own advantages and disadvantages.\n\nELPH_TRANSPORT_DRIVER\n= 1\nUse a linear grid of energies with\nTRANSPORT_NEDOS\nin the interval determined by\nELPH_TRANSPORT_DFERMI_TOL\nor\nELPH_TRANSPORT_EMIN\nand\nELPH_TRANSPORT_EMAX\nand the Simpson integration rule to evaluate the Onsager coefficients.\n\nELPH_TRANSPORT_DRIVER\n= 2\nUse Gauss-Legendre integration to evaluate the Onsager coefficients. The convergence of the integral can be checked by performing a convergence study with respect to\nTRANSPORT_NEDOS\nalone.",
    "related_tags": [
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_TRANSPORT",
      "TRANSPORT_NEDOS",
      "ELPH_TRANSPORT_DFERMI_TOL",
      "ELPH_TRANSPORT_EMIN",
      "ELPH_TRANSPORT_EMAX"
    ]
  },
  "ELPH_TRANSPORT_EMAX": {
    "default_value": "",
    "description": "Upper bound of the energy window in which states are considered for transport calculations.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nIn transport calculations, only a small amount of electronic states around the chemical potential have a sizeable contribution.\nTherefore, in order to improve performance, only states inside an energy window centered around the chemical potential are considered during the calculation.\nBy default, the location and width of the energy window are determined automatically by VASP.\nBy setting\nELPH_TRANSPORT_EMIN\nand\nELPH_TRANSPORT_EMAX\n, one can control the energy window manually.",
    "related_tags": [
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_TRANSPORT",
      "ELPH_TRANSPORT_EMIN"
    ]
  },
  "ELPH_TRANSPORT_EMIN": {
    "default_value": "",
    "description": "Lower bound of the energy window in which states are considered for transport calculations.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nIn transport calculations, only a small amount of electronic states around the chemical potential have a sizeable contribution.\nTherefore, in order to improve performance, only states inside an energy window centered around the chemical potential are considered during the calculation.\nBy default, the location and width of the energy window are determined automatically by VASP.\nBy setting\nELPH_TRANSPORT_EMIN\nand\nELPH_TRANSPORT_EMAX\n, one can control the energy window manually.",
    "related_tags": [
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_TRANSPORT",
      "ELPH_TRANSPORT_EMAX"
    ]
  },
  "ELPH_USEBLAS": {
    "default_value": "ELPH_USEBLAS = .TRUE.",
    "description": "Toggles the use of BLAS routines for computing electron-phonon matrix elements.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis is a performance setting that can offer a significant performance boost.\nIf\nELPH_USEBLAS\n= True\n, then VASP uses\nBLAS\nroutines when computing the electron-phonon matrix elements.\nOtherwise, VASP-internal routines are used.",
    "related_tags": [
      "ELPH_RUN",
      "ELPH_DECOMPOSE"
    ]
  },
  "EMAX": {
    "default_value": "Default: EMAX = highest KS eigenvalue + Δ {\\displaystyle \\Delta}",
    "description": "EMAX specifies the upper boundary of the energy range for the evaluation of the electronic density of states (DOS).",
    "detailed_description": "The DOS is evaluated each\nNBLOCK\nsteps,\nDOSCAR\nis updated each\nNBLOCK\n*\nKBLOCK\nsteps.",
    "related_tags": [
      "EMIN",
      "NEDOS",
      "DOSCAR"
    ]
  },
  "EMIN": {
    "default_value": "Default: EMIN = lowest KS eigenvalue - Δ {\\displaystyle \\Delta}",
    "description": "EMIN specifies the lower boundary of the energy range for the evaluation of the electronic density of states (DOS).",
    "detailed_description": "The DOS is evaluated each\nNBLOCK\nsteps,\nDOSCAR\nis updated each\nNBLOCK\n*\nKBLOCK\nsteps.\n\nTip:\nSet\nEMIN\nto a value larger than\nEMAX\n, if you are not sure where the region of interest lies.",
    "related_tags": [
      "EMAX",
      "NEDOS",
      "DOSCAR"
    ]
  },
  "ENAUG": {
    "default_value": "ENAUG = largest EAUG read from the POTCAR file",
    "description": "Specifies the cutoff energy of the plane-wave representation of the augmentation charges in eV.",
    "detailed_description": "ENAUG\ndetermines\nNGXF\n,\nNGYF\n, and\nNGZF\nin accordance with the\nPREC\ntag.\n\nDeprecated:\nENAUG\nis considered as deprecated and should not be used anymore.\n\nWarning:\nSetting\nENAUG\nhas an effect only if\nPREC\nis set to one of the old settings (Low, Medium or High), otherwise it is ignored.",
    "related_tags": [
      "NGXF",
      "NGYF",
      "NGZF",
      "ENCUT",
      "PREC",
      "PRECFOCK"
    ]
  },
  "ENCUT": {
    "default_value": "Default: ENCUT = largest ENMAX in the POTCAR file",
    "description": "ENCUT specifies the energy cutoff for the plane-wave basis set in eV.",
    "detailed_description": "All plane waves with a kinetic energy smaller than\nE\nc\nu\nt\n{\\displaystyle E_{\\mathrm{cut}}}\nare included in the basis set, i.e.,\n\n|\nG\n+\nk\n|\n<\nG\nc\nu\nt\n{\\displaystyle  | \\mathbf{G} + \\mathbf{k} | < G_{\\mathrm{cut}} }\nwith\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\nG\nc\nu\nt\n2\n{\\displaystyle  E_{\\mathrm{cut}} = \\frac{\\hbar^2}{2m} G^2_{\\mathrm{cut}} }\n\nWith this energy cutoff, the number of plane waves included in the basis set depends on the\nk\n-point, leading to a superior behavior. For instance, for energy-volume calculations the total number of plane waves changes fairly smoothly according to the volume, while the criterion\n|\nG\n|\n<\nG\nc\nu\nt\n{\\displaystyle | \\mathbf{G} | < G_{\\mathrm{cut}} }\n(i.e. same number of plane waves for all\nk\n-points) would lead to a very rough energy-volume curve and, generally, to a slower energy convergence with respect to the basis set size.\n\nThe\nPOTCAR\nfiles contain a default\nENMAX\n(and\nENMIN\n). Therefore, it is, in principle, not necessary to specify\nENCUT\nin the\nINCAR\nfile.\nFor calculations with more than one species, the maximum cutoff\nENMAX\n(or\nENMIN\n) value is used for the calculation (see\nPREC\n).\n\nImportant:\nThe convergence of the quantity of interest with respect to the energy cutoff\nENCUT\nshould always be checked.\nWe strongly recommend specifying the energy cutoff\nENCUT\nalways manually in the\nINCAR\nfile to ensure the same accuracy between calculations. Otherwise, the default\nENCUT\nmay differ among the different calculations (e.g., for the calculation of the cohesive energy), with the consequence that the total energies, for instance, can not be compared.",
    "related_tags": [
      "ENMAX",
      "ENMIN",
      "ENINI",
      "ENAUG",
      "PREC",
      "NGX",
      "NGY",
      "NGZ",
      "NGXF",
      "NGYF",
      "NGZF",
      "POTCAR"
    ]
  },
  "ENCUTFOCK": {
    "default_value": "none",
    "description": "The ENCUTFOCK tag sets the energy cutoff that determines the FFT grids used by the Hartree-Fock routines.",
    "detailed_description": "The flag\nENCUTFOCK\nis no longer supported in VASP.5.2.4 and newer versions.\nPlease use\nPRECFOCK\ninstead.\n\nThe only sensible value for\nENCUTFOCK\nis\nENCUTFOCK\n=0.\nThis implies that the smallest possible FFT grid, which just encloses the cutoff sphere\ncorresponding to the plane wave cutoff, is used. \nThis accelerates the calculations by roughly a factor two to three,\nbut causes slight changes in the total energies and  some noise in the calculated forces.\nThe FFT grid used internally in the exact exchange (Hartree-Fock) routines\nis written to the\nOUTCAR\nfile. Simply search for lines starting with\n\nFFT grid for exact exchange (Hartree Fock)\n\nIn many cases, a sensible approach is to determine the electronic and ionic groundstate \nusing\nENCUTFOCK\n=0, and to make one final total energy calculation\nwithout the flag\nENCUTFOCK\n.",
    "related_tags": [
      "PRECFOCK",
      "PREC",
      "ENCUT",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "ENCUTGW": {
    "default_value": "ENCUTGW = 2/3 ENCUT",
    "description": "The tag ENCUTGW sets the energy cutoff for the response function. It controls the basis set for the response functions in exactly the same manner as ENCUT does for the orbitals.",
    "detailed_description": "In GW and random-phase-approximation (RPA) calculations,  storing and manipulating the response function dominates the computational work load:\n\nχ\nq\n0\n(\nG\n,\nG\n′\n,\nω\n)\n=\n1\nΩ\n∑\nn\n,\nn\n′\n,\nk\n2\nw\nk\n(\nf\nn\n′\nk\n+\nq\n−\nf\nn\nk\n)\n×\n⟨\nψ\nn\nk\n|\ne\n−\ni\n(\nq\n+\nG\n)\nr\n|\nψ\nn\n′\nk\n+\nq\n⟩\n⟨\nψ\nn\n′\nk\n+\nq\n|\ne\ni\n(\nq\n+\nG\n′\n)\nr\n′\n|\nψ\nn\nk\n⟩\nϵ\nn\n′\nk\n+\nq\n−\nϵ\nn\nk\n−\nω\n−\ni\nη\n.\n{\\displaystyle \\chi_{{\\mathbf{q}}}^0 ({\\mathbf{G}}, {\\mathbf{G}}', \\omega)=\\frac{1}{\\Omega} \\sum_{n,n',{\\mathbf{k}}}2 w_{{\\mathbf{k}}}\n (f_{n'{\\mathbf{k}}+{\\mathbf{q}}} - f_{n{\\mathbf{k}}})  \n\\times  \\frac{\\langle \\psi_{n{\\mathbf{k}}}| e^{-i ({\\mathbf{q}}+{\\mathbf{G}}){\\mathbf{r}}} | \\psi_{n'{\\mathbf{k}}+{\\mathbf{q}}}\\rangle\n\\langle \\psi_{n'{\\mathbf{k}}+{\\mathbf{q}}}| e^{i ({\\mathbf{q}}+{\\mathbf{G}}'){\\mathbf{r'}}} | \\psi_{n{\\mathbf{k}}}\\rangle}\n { \\epsilon_{n'{\\mathbf{k}}+{\\mathbf{q}}}-\\epsilon_{n{\\mathbf{k}}} -  \\omega - i \\eta }. }\n\nENCUTGW\ncontrols how many\nG\n{\\displaystyle \\mathbf{G}}\nvectors are included in the \nthe response function\nχ\nq\n0\n(\nG\n,\nG\n′\n,\nω\n)\n{\\displaystyle \\chi_{{\\mathbf{q}}}^0 ({\\mathbf{G}}, {\\mathbf{G}}', \\omega)}\n.\n\nOur experience suggests that choosing\nENCUTGW\n= 2/3\nENCUT\nyields reasonable results at fairly modest computational cost, although, the response function contains contributions up to twice the plane wave cutoff\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n, see\nALGO\ntag. Furthermore, RPA correlation energies are reported using an internal extrapolation of the correlation energy by varying the value of\nENCUTGW\ninside VASP between the largest value given in the\nINCAR\nfile and smaller values\n[1]\n. Mind: The extrapolated value is only reliable, if\nENCUTGW\nis smaller then\nENCUT\n. The cutoff extrapolation with respect to\nENCUTGW\nwould be precise if the plane wave basis for the orbitals were infinite. Again, the VASP defaults yield very reasonable values for the extrapolated correlation energy. In fact, it is unwise to increase\nENCUTGW\nonly, without increasing\nENCUT\n. To converge RPA correlation energies, simply increase\nENCUT\nand the number of orbitals, and use the VASP default for\nENCUTGW\n.\n\nMind:\nMore details on how the infinite basis set limit is extrapolated in RPA/ACFDT can be found\nhere\n.\n\nFor quasiparticle (QP) bandgaps, it is sometimes possible to set\nENCUTGW\nto values between 150 to 200 eV, and even 100 eV can yield\ngaps that are accurate to within a few tens of an eV for main group elements. Be aware, however, that the absolute values of the QP energies depend inverse proportionally on the number of plane waves. Thus, the convergence of absolute QP energies is very slow, although QP gaps might seem converged.\n\nThe recommended procedure to obtain accurate QP energies is discussed in the reference below. Specifically,  for reference type calculations we recommend the following procedure:\n\nUse the default for\nENCUTGW\n, or even decrease\nENCUTGW\nto half the value of\nENCUT\n.\nCalculate all orbitals that the plane-wave basis set allows to calculate. This number can be determined by searching for \"maximum number of plane-waves\" in the ground-state DFT\nOUTCAR\nfile, and setting\nNBANDS\nto this value.\nIncrease\nENCUT\nsystematically and plot the QP energies versus the number of plane-wave coefficients, which equals the number of orbitals. This means\nENCUTGW\nand\nNBANDS\nincrease as\nENCUT\nincreases.\n\nThis procedure can be carried out using few k points. Other commonly applied methods can yield less accurate results and are not considered to be reliable.\n\nFFT grid and\nPRECFOCK\n\nThe\nPRECFOCK\ntag determines the fast Fourier transformation (FFT) grid in all GW (and Hartree-Fock) related routines. For small systems, the computational time is often dominated by FFT operations. Therefore, the\nPRECFOCK\ntag can have a significant impact on the compute time for QP calculations. For large systems, the FFT's usually do not dominate the computational workload, and savings are expected to be small for\nPRECFOCK\n=\nfast\n. \nQP shifts are usually not very sensitive to the setting of\nPRECFOCK\nand therefore there is no harm in setting\nPRECFOCK\n=\nfast\n), whereas for RPA calculations we recommend to set\nPRECFOCK\n=\nnormal\nto avoid numerical errors.",
    "related_tags": [
      "PRECFOCK",
      "ENCUT",
      "ENCUTGWSOFT",
      "GW calculations",
      "Basis set convergence"
    ]
  },
  "ENCUTGWSOFT": {
    "default_value": "Default: ENCUTGWSOFT = ENCUTGW × 0.8 {\\displaystyle \\times 0.8} for ALGO = ACFDT | = ENCUTGW × 0.8 {\\displaystyle \\times 0.8} as of VASP.6.3 | = ENCUTGW else",
    "description": "",
    "detailed_description": "",
    "related_tags": [
      "PRECFOCK",
      "ENCUT",
      "ENCUTGW",
      "GW calculations",
      "LSCK",
      "RPA/ACFDT basis set convergence",
      "↑",
      "J. Harl and G. Kresse, Phys. Rev. B 77 , 045136 (2008).",
      "J. Harl, L. Schimka, and G. Kresse, Phys. Rev. B 81 , 115126 (2010).",
      "J. Klimeš, M. Kaltak, and G. Kresse, Phys. Rev. B 90 , 075125 (2014).",
      "S. Riemelmoser, M. Kaltak, and G. Kresse, JCP 152(13) , 134103 (2020)."
    ]
  },
  "ENCUTLR": {
    "default_value": "ENCUTLR = 50 eV",
    "description": "Reciprocal space cutoff for the treatment of the long-range contribution.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nSimilar to the\ntreatment of the long-range part of the force-constants\n, the potential and the PAW strengths also require a special treatment\n[1]\nin polar materials.\nThe correction scheme involves an Ewald summation over reciprocal lattice vectors that converges rapidly in reciprocal space.\nENCUTLR\ncontrols the number of G-vectors included in the Ewald sum in the same way as\nENCUT\ncontrols the number of G-vectors (plane-wave components) of the electronic Kohn-Sham orbitals.",
    "related_tags": [
      "IFC_LR",
      "ELPH_LR",
      "PHON_G_CUTOFF"
    ]
  },
  "ENINI": {
    "default_value": "ENINI = ENCUT",
    "description": "ENINI controls the cutoff during the initial (steepest descent) phase for IALGO =48.",
    "detailed_description": "",
    "related_tags": [
      "ENCUT",
      "IALGO"
    ]
  },
  "EPSILON": {
    "default_value": "EPSILON = 1",
    "description": "EPSILON sets the dielectric constant of the medium.",
    "detailed_description": "VASP uses this flag only to scale the calculated\nmonopole and dipole corrections\n.\nEPSILON\ndefaults to 1, which is the proper value for isolated atoms and molecules. For solids, the screening properties can and should be determined using the linear response routines of VASP (see\nLEPSILON\nand/or\nLCALCEPS\n). Ionic contributions to the dielectric tensor should be included, if the ions are allowed to relax. Ionic contributions to the dielectric tensor can be calculated using\nIBRION\n=8.",
    "related_tags": [
      "Monopole Dipole and Quadrupole corrections",
      "NELECT",
      "DIPOL",
      "IDIPOL",
      "LDIPOL",
      "LMONO",
      "EFIELD"
    ]
  },
  "ESTOP": {
    "default_value": "Default: ESTOP = 0.05",
    "description": "ESTOP specifies the stop condition for stochastic MP2.",
    "detailed_description": "ESTOP\ndefines the energy accuracy in units of eV for each individual tau-point of the two individual MP2 energy contributions (direct MP2 term + exchange MP2 term). Since the statistical errors of each contribution is independent, the standard deviation of the MP2 energy can be estimated as\n\nσ\n=\nESTOP\n∗\n2\n⋅\nNOMEGA\n.\n{\\displaystyle \n\\sigma = \\texttt{ESTOP} * \\sqrt{2 \\cdot \\texttt{NOMEGA}} \\;.\n}\n\nAccording to our experience, the error of the resulting MP2 energy can then be safely estimated by\n±\n2\nσ\n{\\displaystyle \\pm 2 \\sigma}\n.\n\nThus, if you require an MP2 energy with a maximum error of\nΔ\n{\\displaystyle \\Delta}\n, you should set\n\nESTOP\n=\nΔ\n2\n⋅\n2\n⋅\nNOMEGA\n.\n{\\displaystyle \n\\texttt{ESTOP} = \\frac{\\Delta}{2 \\cdot \\sqrt{2 \\cdot  \\texttt{NOMEGA}}} \\;.\n}\n\nSee\nthis tutorial\nfor more Information about Laplace transformed MP2.",
    "related_tags": [
      "ALGO",
      "LMP2LT",
      "LSMP2LT",
      "NOMEGA",
      "NSTORB"
    ]
  },
  "EVENONLY": {
    "default_value": "EVENONLY = .FALSE.",
    "description": "EVENONLY =.TRUE. selects a subset of k -points for the representation of the Fock exchange potential, with C 1 = C 2 = C 3 =1, and n 1 + n 2 + n 3 even.",
    "detailed_description": "One may restrict the sum over\nq\nin the\nFock exchange potential\n(or one of its short range counterparts) to a subset, {\nq\nk\n}, of the full (\nN\n1\n×\nN\n2\n×\nN\n3\n)\nk\n-point set, {\nk\n}, for which the following holds\n\nq\nk\n=\nb\n1\nn\n1\nC\n1\nN\n1\n+\nb\n2\nn\n2\nC\n2\nN\n2\n+\nb\n3\nn\n3\nC\n3\nN\n3\n,\n(\nn\ni\n=\n0\n,\n.\n.\n,\nN\ni\n−\n1\n)\n{\\displaystyle \n\\mathbf{q_k} = \\mathbf{b}_1 \\frac{n_1 C_1}{N_1} + \\mathbf{b}_2 \\frac{n_2 C_2}{N_2}\n+ \\mathbf{b}_3 \\frac{n_3 C_3}{N_3},\\quad(n_i=0,..,N_i-1)\n}\n\nwhere\nb\n1,2,3\nare the reciprocal lattice vectors of the primitive cell,\nand\nC\ni\nis the integer grid reduction factor along reciprocal lattice direction\nb\ni\n.\n\nEVENONLY\n=.TRUE. selects a subset of\nk\n-points with\nC\n1\n=\nC\n2\n=\nC\n3\n=1, and\nn\n1\n+\nn\n2\n+\nn\n3\neven. It reduces the computational work load for HF type calculations by a factor two, but is only sensible for high symmetry cases (such as sc, fcc or bcc cells).\n\nWarning:\nthere are circumstances under which\nNKRED\nand\nNKREDX\n,\nY\n,\nZ\nshould not be used!",
    "related_tags": [
      "NKRED",
      "NKREDX",
      "NKREDY",
      "NKREDZ",
      "ODDONLY",
      "downsampling"
    ]
  },
  "EVENONLYGW": {
    "default_value": "EVENONLYGW = .FALSE.",
    "description": "EVENONLYGW allows to restrict the k-points in the evaluation of response functions (in GW calculations ) to even values.",
    "detailed_description": "EVENONLYGW\n=\n.TRUE.\nis only of limited use and restricts the summation to k-points with\nn\n1\n+\nn\n2\n+\nn\n3\n{\\displaystyle n_{1}+n_{2}+n_{3}}\nbeing even (\nΓ\n{\\displaystyle \\Gamma}\npoint and from there on every second k-point included).",
    "related_tags": [
      "ODDONLYGW",
      "GW calculations"
    ]
  },
  "FBIAS_A": {
    "default_value": "",
    "description": "Defines the step height for the bias potential in e V {\\displaystyle eV} .",
    "detailed_description": "FBIAS_A\ndefines the height of the step (\nA\nμ\n{\\displaystyle A_{\\mu}}\n) in the Fermi-like step-shaped bias potential of the following form:\n\nV\n~\n(\nξ\n1\n,\n…\n,\nξ\nM\n4\n)\n=\n∑\nμ\n=\n1\nM\n4\nA\nμ\n1\n+\nexp\n[\n−\nD\nμ\n(\nξ\n(\nq\n)\nξ\n0\nμ\n−\n1\n)\n]\n,\n{\\displaystyle \n\\tilde{V}(\\xi_1,\\dots,\\xi_{M_4}) = \\sum_{\\mu=1}^{M_4}\\frac{A_{\\mu}}{1+\\text{exp}\\left [-D_{\\mu}(\\frac{\\xi(q)}{\\xi_{0\\mu}} -1) \\right ]}, \\;\n}\n\nwhere the sum runs over all (\nM\n4\n{\\displaystyle M_4}\n) coordinates the potential acts upon, which are defined in the\nICONST\nfile by setting the\nstatus\nto 4.\nThe units of\nA\nμ\n{\\displaystyle A_{\\mu}}\nare\ne\nV\n{\\displaystyle eV}\n.\nThe number of items defined via\nFBIAS_A\nmust be equal to\nM\n4\n{\\displaystyle M_4}\n, otherwise the calculation terminates with an error message.",
    "related_tags": [
      "FBIAS_R0",
      "FBIAS_D",
      "ICONST",
      "Biased molecular dynamics"
    ]
  },
  "FBIAS_D": {
    "default_value": "",
    "description": "Sets the slope of the bias potential.",
    "detailed_description": "FBIAS_D\ndefines the parameter\nD\nμ\n{\\displaystyle D_{\\mu}}\n, which controls the slope of the central part of the Fermi-like step-shaped bias potential of the following form:\n\nV\n~\n(\nξ\n1\n,\n…\n,\nξ\nM\n4\n)\n=\n∑\nμ\n=\n1\nM\n4\nA\nμ\n1\n+\nexp\n[\n−\nD\nμ\n(\nξ\n(\nq\n)\nξ\n0\nμ\n−\n1\n)\n]\n,\n{\\displaystyle \n\\tilde{V}(\\xi_1,\\dots,\\xi_{M_4}) = \\sum_{\\mu=1}^{M_4}\\frac{A_{\\mu}}{1+\\text{exp}\\left [-D_{\\mu}(\\frac{\\xi(q)}{\\xi_{0\\mu}} -1) \\right ]}, \\;\n}\n\nwhere the sum runs over all (\nM\n4\n{\\displaystyle M_4}\n) coordinates the potential acts upon, which are defined in the\nICONST\n-file by setting the\nstatus\nto 4.\nThe parameters\nD\nμ\n{\\displaystyle D_{\\mu}}\nare dimensionless.\nThe number of items defined via\nFBIAS_D\nmust equal to\nM\n4\n{\\displaystyle M_4}\n, otherwise the calculation terminates with an error message.",
    "related_tags": [
      "FBIAS_R0",
      "FBIAS_A",
      "ICONST",
      "Biased molecular dynamics"
    ]
  },
  "FBIAS_R0": {
    "default_value": "",
    "description": "Defines the half-step position for the bias potential.",
    "detailed_description": "FBIAS_R0\ndefines the half-step position (\nξ\n0\nμ\n{\\displaystyle \\xi_{0\\mu}}\n) for the Fermi-like step-shaped bias potential of the following form:\n\nV\n~\n(\nξ\n1\n,\n…\n,\nξ\nM\n4\n)\n=\n∑\nμ\n=\n1\nM\n4\nA\nμ\n1\n+\nexp\n[\n−\nD\nμ\n(\nξ\n(\nq\n)\nξ\n0\nμ\n−\n1\n)\n]\n,\n{\\displaystyle \n\\tilde{V}(\\xi_1,\\dots,\\xi_{M_4}) = \\sum_{\\mu=1}^{M_4}\\frac{A_{\\mu}}{1+\\text{exp}\\left [-D_{\\mu}(\\frac{\\xi(q)}{\\xi_{0\\mu}} -1) \\right ]}, \\;\n}\n\nwhere the sum runs over all (\nM\n4\n{\\displaystyle M_4}\n) coordinates the potential acts upon, which are defined in the\nICONST\nfile by setting the\nstatus\nto 4.\nThe units of\nξ\n0\nμ\n{\\displaystyle \\xi_{0\\mu}}\ncorrespond to units of the coordinate the potential acts upon (e.g.,\nÅ\n{\\displaystyle {\\AA}}\nfor coordinates with\nflag\nR,\nr\na\nd\n.\n{\\displaystyle rad.}\nfor coordinates with\nflag\nA, dimensionless for coordinates with\nflag\nW, etc...).\nThe number of items defined via\nFBIAS_R0\nmust be equal to\nM\n4\n{\\displaystyle M_4}\n. Otherwise, the calculation terminates with an error message.",
    "related_tags": [
      "FBIAS_A",
      "FBIAS_D",
      "ICONST"
    ]
  },
  "FERDO": {
    "default_value": "",
    "description": "FERDO sets the occupancies of the states in the down-spin channel for ISMEAR =-2 and ISPIN =2.",
    "detailed_description": "To set the occupancies, specify\n\nFERDO\n= f(1) f(2) f(3) ... f(\nNBANDS\n×N\nk\n)\n\nThe occupancies must be specified for all bands and k points. The band-index runs fastest. The occupancies must be between 0 and 1.\nFERDO\nhas the same format as\nFERWE\n, please consider the notes on that page when setting\nFERDO\n.",
    "related_tags": [
      "FERWE",
      "ISMEAR"
    ]
  },
  "FERWE": {
    "default_value": "",
    "description": "FERWE sets the occupancies of the states for ISMEAR =-2.",
    "detailed_description": "To set the occupancies, specify\n\nFERWE\n= f(1) f(2) f(3) ... f(\nNBANDS\n×N\nk\n)\n\nThe occupancies must be specified for all bands and k points. \nThe band index runs fastest. \nThe occupancies must be between 0 and 1.\nIn the case of spin-polarized calculations (\nISPIN\n= 2\n),\nFERWE\nsets the occupancies of the states in the up-spin channel. \nSpecify the occupancies of the states in the down-spin channel by means of the\nFERDO\ntag.\n\nNote that the partial occupancies are also written to the\nOUTCAR\nfile\n\nk-point     8 :       0.3750    0.0000    0.0000\n band No.  band energies     occupation\n     1      -2.0636      2.00000\n     2       0.1506      2.00000\n     3       6.0155      1.99808\n     4       6.0188      1.99432\n     5       7.3309      1.71014\n     6       7.3311      1.54777\n     7       8.0841      0.28501\n     8       8.0894      0.18039\n     9       9.5834      0.00086\n    10       9.5880      0.00071\n    11      13.0368      0.00000\n    12      14.3253      0.00000\n\nKeep in mind that for systems without spin-polarization the occupations are twice as large in the\nOUTCAR\nfile than what you should provide for\nFERWE\nbecause of spin degeneracy.\n\nMind:\nVASP changes the number of bands\nNBANDS\nto accommodate your parallel setup. If\nNBANDS\nis inconsistent with the number of elements you provide with\nFERWE\nVASP will exit with an error message. The used\nNBANDS\nis indicated in the error message. Adjust the occupancies provided to\nFERWE\nto this new value. Alternatively, you can choose an\nNBANDS\nas the common factor of all your parallel setups to avoid changes in the number of bands (see\nhere\n).\n\nYou can use\nFERWE\nto keep occupancies fixed during ionic relaxations or molecular dynamics simulations. \nHowever, keeping the orbital occupancies fixed, requires that the orbital order does not change during the self-consistency cycle or during the optimization of the orbitals. \nImagine, for instance, that the eigenenergy of the 65th orbital moves below the orbital energy of the 64th orbital.\nBy default, VASP will order the eigenenergies so that enforcing\nFERWE\nwill move the electrons to the originally unoccupied 65th orbital because it has now the lower energy.\nThis problem can be often circumvented by specifying\nLDIAG\n= .FALSE.\nin the\nINCAR\nfile.",
    "related_tags": [
      "FERDO",
      "ISMEAR",
      "NBANDS",
      "LDIAG"
    ]
  },
  "FINDIFF": {
    "default_value": "FINDIFF = 1",
    "description": "Defines whether a forward ( FINDIFF =1) or a central ( FINDIFF =2) difference formula for the numerical differentiation to compute the curvature along the dimer direction is used in the improved dimer method .",
    "detailed_description": "",
    "related_tags": [
      "Improved dimer method"
    ]
  },
  "FMP_ACTIVE": {
    "default_value": "Default: FMP_ACTIVE = NIONS * False",
    "description": "Select which atom types in the POSCAR -file participate in swapping within the Müller-Plathe method .",
    "detailed_description": "FMP_ACTIVE\nspecifies whether or not (.TRUE. or .FALSE., respectively) an atomic type allowed for swapping within the\nMüller-Plathe method\n. One item for each of the atomic types defined in\nPOSCAR\nmust be supplied.\n\nMind:\nThis tag will only be available from VASP 6.4.4",
    "related_tags": [
      "Müller-Plathe method",
      "FMP_DIRECTION",
      "FMP_SNUMBER",
      "FMP_SWAPNUM",
      "FMP_PERIOD"
    ]
  },
  "FMP_DIRECTION": {
    "default_value": "FMP_DIRECTION = 3",
    "description": "Index of the lattice vector a i {\\displaystyle \\mathbf{a}_i} along which the temperature gradient is created in the ( Müller-Plathe method ).",
    "detailed_description": "FMP_DIRECTION\ndefines the index of the lattice vector\na\ni\n{\\displaystyle \\mathbf{a}_i}\nalong which the gradient\n∂\nT\n/\n∂\na\ni\n{\\displaystyle \\partial T/\\partial \\mathbf{a}_i }\nis created during the reverse nonequilibrium molecular-dynamics run using the\nMüller-Plathe method\n.\n\nMind:\nThis tag will only be available from VASP 6.4.4",
    "related_tags": [
      "Müller-Plathe method",
      "FMP_ACTIVE",
      "FMP_SNUMBER",
      "FMP_SWAPNUM",
      "FMP_PERIOD"
    ]
  },
  "FMP_PERIOD": {
    "default_value": "FMP_PERIOD = 10",
    "description": "Number of time steps between two swapping events in the Müller-Plathe method .",
    "detailed_description": "This tag defines how many MD steps are done between two consecutive velocity-swapping events. The period is counted in MD steps and not in simulation time.\n\nMind:\nThis tag will only be available from VASP 6.4.4",
    "related_tags": [
      "Müller-Plathe method",
      "FMP_ACTIVE",
      "FMP_DIRECTION",
      "FMP_SNUMBER",
      "FMP_SWAPNUM"
    ]
  },
  "FMP_SNUMBER": {
    "default_value": "FMP_SNUMBER = 10",
    "description": "Number of slabs perpendicular to the temperature gradient in the Müller-Plathe method .",
    "detailed_description": "FMP_SNUMBER\ndefines the number of slabs perpendicular to the lattice vector\na\ni\n{\\displaystyle \\mathbf{a}_i}\nalong which the gradient\n∂\nT\n/\n∂\na\ni\n{\\displaystyle \\partial T/\\partial \\mathbf{a}_i }\nis created during the reverse nonequilibrium molecular dynamics run using the\nMüller-Plathe method\n.\n\nMind:\nThis tag will only be available from VASP 6.4.4",
    "related_tags": [
      "Müller-Plathe method",
      "FMP_ACTIVE",
      "FMP_DIRECTION",
      "FMP_SWAPNUM",
      "FMP_PERIOD"
    ]
  },
  "FMP_SWAPNUM": {
    "default_value": "FMP_SWAPNUM = 1",
    "description": "Number of pairs that are exchanged in a single swapping event in the Müller-Plathe method .",
    "detailed_description": "FMP_SWAPNUM\ndefines the number of pairs of particles exchanged in a single swapping event of the reverse nonequilibrium molecular dynamics run using the\nMüller-Plathe method\n. Only the particles of the same type are selected.\n\nMind:\nThis tag will only be available from VASP 6.4.4",
    "related_tags": [
      "Müller-Plathe method",
      "FMP_DIRECTION",
      "FMP_ACTIVE",
      "FMP_SNUMBER",
      "FMP_PERIOD"
    ]
  },
  "FOCKCORR": {
    "default_value": "Default: FOCKCORR = 2 if LMAXFOCKAE >0 | = 1 else",
    "description": "The tag FOCKCORR determines how the Coulomb convergence corrections are applied.",
    "detailed_description": "The Coulomb potential in reciprocal space\n\nV\n(\nG\n)\n=\n4\nπ\ne\n2\nG\n2\n{\\displaystyle V(G)=\\frac{4\\pi e^2}{G^2}}\n\ndiverges for small G vectors.\nTo alleviate this issue and improve the convergence of the exact exchange integral with respect to supercell size (or k-point mesh density) different methods have been proposed: the auxiliary function methods\n[1]\n, probe-charge Ewald\n[2]\n(\nHFALPHA\n), and Coulomb truncation methods\n[3]\n(\nHFRCUT\n).\nThese mostly involve modifying the Coulomb Kernel in a way that yields the same result as the unmodified kernel within the limit of large supercell sizes.\n\nThese corrections are implemented in VASP either by changing the\nG\n=\n0\n{\\displaystyle \\mathbf{G}=0}\ncomponent of the Coulomb kernel when\nFOCKCORR\n=1\n\nΦ\n(\nG\n)\n=\n{\n4\nπ\ne\n2\nΩ\n1\nG\n2\nG\n≠\n0\nχ\nG\n=\n0\n{\\displaystyle \n\\Phi(\\mathbf{G}) = \n\\left\\{\n    \\begin{array}{lr}\n        \\frac{4\\pi e^2}{\\Omega} \\frac{1}{G^2} & \\mathbf{G} \\neq 0\\\\\n        \\chi                              & \\mathbf{G} = 0\n    \\end{array} \n\\right.\n}\n\nwith\nχ\n{\\displaystyle \\chi}\nbeing the value of the correction and depends on whether\nHFALPHA\nor\nHFRCUT\nare set,\nor by including the original orbital scaled by the convergence correction when\nFOCKCORR\n=2\n\n⟨\nk\n+\nG\n′\n|\nV\nx\nHF\n|\nk\n+\nG\n⟩\n=\n−\n∑\nm\nq\nf\nm\nq\n∑\nG\n″\nC\nm\nq\n∗\n(\nG\n′\n−\nG\n″\n)\nΦ\n(\nk\n−\nq\n+\nG\n″\n)\nC\nm\nq\n(\nG\n−\nG\n″\n)\n{\\displaystyle \n\\langle \\mathbf{k}+\\mathbf{G}' | V^\\text{HF}_\\text{x} | \\mathbf{k}+\\mathbf{G} \\rangle = \n- \\sum_{m\\mathbf{q}}f_{m\\mathbf{q}}\\sum_{\\mathbf{G}''}\nC^*_{m\\mathbf{q}}(\\mathbf{G}'-\\mathbf{G}'') \\Phi(\\mathbf{k}-\\mathbf{q}+\\mathbf{G}'') C_{m\\mathbf{q}}(\\mathbf{G}-\\mathbf{G}'')\n}\n\n⟨\nk\n+\nG\n′\n|\nV\n^\nx\nHF\n|\nψ\nk\nn\n⟩\n=\n−\n∑\nm\nq\nf\nm\nq\n∑\nG\n″\nC\nm\nq\n∗\n(\nG\n′\n−\nG\n″\n)\nΦ\n(\nk\n−\nq\n+\nG\n″\n)\nC\nm\nq\n(\nG\n−\nG\n″\n)\nC\nn\nk\n(\nG\n)\n=\n−\nχ\n∑\nm\nq\nf\nm\nq\nC\nm\nq\n(\nG\n)\n{\\displaystyle \n\\begin{aligned}\n\\langle \\mathbf{k}+\\mathbf{G}' |\\hat{V}^\\text{HF}_{\\text{x}} | \\psi_{\\mathbf{k}n} \\rangle\n&= \n- \\sum_{m\\mathbf{q}}f_{m\\mathbf{q}}\\sum_{\\mathbf{G}''}\nC^*_{m\\mathbf{q}}(\\mathbf{G}'-\\mathbf{G}'') \\Phi(\\mathbf{k}-\\mathbf{q}+\\mathbf{G}'') C_{m\\mathbf{q}}(\\mathbf{G}-\\mathbf{G}'')\nC_{n\\mathbf{k}}(\\mathbf{G})\\\\\n&=\n-  \\chi\\sum_{m\\mathbf{q}}f_{m\\mathbf{q}}\n C_{m\\mathbf{q}}(\\mathbf{G})\n\\end{aligned}\n}\n\nFor Hartree-Fock or hybrid functional calculations, either\nFOCKCORR\n=1 or\nFOCKCORR\n=2 can be used and should yield the same results when\nLMAXFOCKAE\n=-1 and there are no aliasing errors in the exact exchange (see\nPRECFOCK\nfor more details).\nFor post-DFT methods such as ACDFT, GW, and BSE the\nFOCKCORR\n=2 should be used because the overlap densities are reconstructed in the plane-wave grid (see\nLMAXFOCKAE\ntag).\n\nNote that in the case\nFOCKCORR\n=2 the corrections are only applied to orbitals in the\nq\n{\\displaystyle \\mathbf{q}}\nregular grid used to describe the exact exchange potential so this method cannot be used to compute band structures where this potential is applied to orbitals\nn\nk\n{\\displaystyle n\\mathbf{k}}\nnot in the\nm\nq\n{\\displaystyle m\\mathbf{q}}\nset.\n\nWarning:\nFOCKCORR\n=2 should\nnot\nbe used when computing the band structure along a path with the\n0-weight scheme\nor\nKPOINTS_OPT\n\nIn previous versions of VASP,\nFOCKCORR\n=1 was used when\nALGO\n=Normal;\nLFOCKACE\n=.FALSE. and\nFOCKCORR\n=2 when\nALGO\n=All or\nALGO\n=Normal;\nLFOCKACE\n=.TRUE. .\n\nMind:\nOnly available as of VASP 6.3.1.",
    "related_tags": [
      "HFRCUT",
      "HFALPHA",
      "↑",
      "F. Gygi and A. Baldereschi, Phys. Rev. B 34 , 4405(R) (1986).",
      "S. Massidda, M. Posternak, and A. Baldereschi, Phys. Rev. B 48 , 5058 (1993).",
      "J. Spencer and A. Alavi, Phys. Phys. Rev. B 77 , 193110 (2008)."
    ]
  },
  "FORCE_AND_STRESS": {
    "default_value": "PLUGINS/FORCE_AND_STRESS = .False.",
    "description": "PLUGINS/FORCE_AND_STRESS calls the Python plugin for the force and stress interface for each ionic relaxation step",
    "detailed_description": "When\nPLUGINS/FORCE_AND_STRESS\n=.TRUE., VASP calls the\nforce_and_stress\nPython function at the end of each ionic relaxation step. \nYou can use this tag to modify forces and the stress tensor to be consistent with modifications to the potential performed with\nPLUGINS/LOCAL_POTENTIAL\n.\nFurthermore, you could implement new force corrections like van-der-Waals functionals.\n\nExpected inputs\n\nThe\nforce_and_stress\nPython function expects the following inputs,\n\ndef\nforce_and_stress\n(\nconstants\n,\nadditions\n):\n\nwhere\nconstants\nand\nadditions\nand\nPython dataclasses\n.\nThe\nconstants\ndataclass consists of the following inputs, listed here with their associated\ndatatypes\n\n@dataclass\n(\nfrozen\n=\nTrue\n)\nclass\nConstantsForceAndStress\n:\nENCUT\n:\nfloat\nNELECT\n:\nfloat\nshape_grid\n:\nIntArray\nnumber_ions\n:\nint\nnumber_ion_types\n:\nint\nion_types\n:\nIndexArray\natomic_numbers\n:\nIntArray\nlattice_vectors\n:\nDoubleArray\npositions\n:\nDoubleArray\nZVAL\n:\nDoubleArray\nPOMASS\n:\nDoubleArray\nforces\n:\nDoubleArray\nstress\n:\nDoubleArray\ncharge_density\n:\nOptional\n[\nDoubleArray\n]\n=\nNone\n\nNote that the\nINCAR\ntags are capitalized.\nshape_grid\nis a three dimensional integer array which stores the shape of the real space grid,\nNGXF\n,\nNGYF\nand\nNGZF\n,\nnumber_ions\nis the total number of ions listed in the\nPOSCAR\nfile,\nnumber_ion_types\nis the number of ion corresponding to each ion type in the convention of the\nPOSCAR\nfile,\nion_types\nstores the total number of ion types,\natomic_numbers\ncontains the atomic number for each atom type,\nlattice_vectors\nand\npositions\ncontain the lattice vectors and positions of the current SCF step\nforces\nand\nstress\nare the computed forces and stress tensor and\ncharge_density\ncontains the charge density on the real space grid.\n\nThe\nadditions\ndataclass consists of the following modifiable outputs\n\n@dataclass\nclass\nAdditionsForceAndStress\n:\ntotal_energy\n:\nfloat\nforces\n:\nDoubleArray\nstress\n:\nDoubleArray\n\nModifying quantities\n\nModify the quantities listed in additions by adding to them. For example, if you wanted to add one to the forces\n\nimport\nnumpy\nas\nnp\ndef\nforce_and_stress\n(\nconstants\n,\nadditions\n)\nadditions\n.\nforces\n+=\nnp\n.\nones\n((\nconstants\n.\nnumber_ions\n,\n3\n))\n\nWarning:\nYou should not make modifications to quantities in\nconstants\n. We implemented some safeguards to prevent accidental modifications. Intentional changes will lead to erratic behavior because we may change the VASP code assuming these quantities are constant.",
    "related_tags": [
      "Plugins",
      "PLUGINS/LOCAL_POTENTIAL",
      "PLUGINS/MACHINE_LEARNING",
      "PLUGINS/OCCUPANCIES",
      "PLUGINS/STRUCTURE"
    ]
  },
  "GAMMA_VDW": {
    "default_value": "Default: GAMMA_VDW = 1.12 for IVDW_NL =3 or | = 1.29 for IVDW_NL =4",
    "description": "Specify γ {\\displaystyle \\gamma} in vdW-DF3-opt1/vdW-DF3-opt2.",
    "detailed_description": "The\nGAMMA_VDW\ntag allows to specify the value of the parameter\nγ\n{\\displaystyle \\gamma}\nin the kernel of the vdW-DF3-opt1/vdW-DF3-opt2 nonlocal van der Waals functionals.\n[1]",
    "related_tags": [
      "ALPHA_VDW",
      "PARAM1",
      "PARAM2",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "GGA": {
    "default_value": "The functional specified by LEXCH in the POTCAR if METAGGA and XC are also not specified.",
    "description": "Selects a LDA or GGA exchange-correlation functional .",
    "detailed_description": "Important:\nVASP recalculates the exchange-correlation energy inside the PAW sphere and corrects the atomic energies given by the\nPOTCAR\nfile. For this to work, the original LEXCH tag must not be modified in the\nPOTCAR\nfile.\n\nMind:\nWhen the OR, BO, MK, ML or CX GGA is used in combination with the nonlocal vdW-DF functional of Dion\net al.\n[1]\n, the GGA component of the correlation should in principle be turned off with\nAGGAC\n=0 (see\nnonlocal vdW-DF functionals\n).\nThe\nXC\ntag, available since VASP.6.4.3, can be used to specify any linear combination of LDA,\nGGA\nand\nMETAGGA\nexchange-correlation functionals.\n\nAvailable functionals\n\nThis table lists the LDA and GGA functionals available in VASP. The names of functionals which end with \"_X\" and \"_C\" correspond to exchange-only and correlation functionals, respectively.\n\nGGA=\nType\nDescription\nLIBXC (or LI)\nLDA/GGA\nAny LDA or GGA from the external library Libxc.\n[2]\n[3]\n[4]\nIt is necessary to have\nLibxc >= 5.2.0 installed\nand VASP.6.3.0 or higher compiled with\nprecompiler options\n. The\nLIBXC1\nand\nLIBXC2\ntags (where examples are shown) are also required.\nCA (or PZ)\n(1)\nLDA\nSlater exchange\n[5]\n+ Perdew-Zunger parametrization of Ceperley-Alder Monte Carlo correlation data.\n[6]\n[7]\nPW92\n(1)\nLDA\nSlater exchange\n[5]\n+ Perdew-Wang parametrization of Ceperley-Alder Monte Carlo correlation data.\n[6]\n[8]\nAvailable since VASP.6.5.0.\nSL\n(1)\nLDA\nSlater exchange only.\n[5]\nAvailable since VASP.6.4.3.\nCA_C (or PZ_C)\nLDA\nCorrelation-only Perdew-Zunger parametrization of Ceperley-Alder Monte Carlo correlation data.\n[6]\n[7]\nAvailable since VASP.6.4.3.\nPW92_C\nLDA\nCorrelation-only Perdew-Wang parametrization of Ceperley-Alder Monte Carlo correlation data.\n[6]\n[8]\nAvailable since VASP.6.5.0.\nVW\n(1)\nLDA\nSlater exchange\n[5]\n+ Vosko-Wilk-Nusair correlation (VWN5).\n[9]\nHL\n(1)\nLDA\nSlater exchange\n[5]\n+ Hedin-Lundqvist correlation.\n[10]\nWI\n(1)\nLDA\nSlater exchange\n[5]\n+ Wigner correlation\n[11]\n(Eq. (3.2) in Ref.\n[12]\n).\nPE\nGGA\nPerdew-Burke-Ernzerhof (PBE).\n[13]\nPBE_X\nGGA\nExchange-only Perdew-Burke-Ernzerhof.\n[13]\nAvailable since VASP.6.4.3.\nPBE_C\nGGA\nCorrelation-only Perdew-Burke-Ernzerhof.\n[13]\nAvailable since VASP.6.4.3.\nRE\nGGA\nRevised PBE from Zhang and Yang (revPBE).\n[14]\nRP\nGGA\nRevised PBE from Hammer\net al\n. (RPBE).\n[15]\nPS\nGGA\nRevised PBE for solids (PBEsol).\n[16]\nAM\nGGA\nArmiento-Mattsson (AM05).\n[17]\n[18]\n[19]\n91\n(1)\nGGA\nPerdew-Wang (PW91).\n[20]\nB3\n(1)\nGGA\nB3LYP\n[21]\nwith VWN3\n[9]\nfor LDA correlation.\nB5\n(1)\nGGA\nB3LYP\n[21]\nwith VWN5\n[9]\nfor LDA correlation.\nOR\n(2)\nGGA\noptPBE exchange\n[22]\n+ PBE correlation.\n[13]\nBO\n(2)\nGGA\noptB88 exchange\n[22]\n+ PBE correlation.\n[13]\nPARAM1\n=0.1833333333 for\nβ\n{\\displaystyle \\beta}\nand\nPARAM2\n=0.22 for\nμ\n{\\displaystyle \\mu}\nalso need to be specified.\nMK\n(2)\nGGA\noptB86b exchange\n[23]\n+ PBE correlation.\n[13]\nThe\nPARAM1\nand\nPARAM2\ntags can be used to modify the parameters\nμ\n{\\displaystyle \\mu}\nand\nκ\n{\\displaystyle \\kappa}\n, respectively.\nML\n(2)\nGGA\nPW86R exchange\n[24]\n+ PBE correlation.\n[13]\nCX\n(2)\nGGA\nCX (LV-PW86r) exchange\n[25]\n+ PBE correlation.\n[13]\nBF\nGGA\nBEEF (requires VASP compiled with\n-Dlibbeef\n).\n[26]\n\n(1)\nThe Slater LDA exchange includes relativistic effects.\n[27]\n\n(2)\nThe exchange component was designed in particular to be used as the exchange component of\nNonlocal vdW-DF functionals\nand with\nAGGAC\n=0 such that only LDA is used for the local correlation, see\nlist of nonlocal vdW-DF functionals\n.",
    "related_tags": [
      "LIBXC1",
      "LIBXC2",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "METAGGA",
      "XC"
    ]
  },
  "GGA_COMPAT": {
    "default_value": "GGA_COMPAT = .TRUE.",
    "description": "If set to GGA_COMPAT = . FALSE ., this tag restores the full lattice symmetry for gradient-corrected functionals.",
    "detailed_description": "GGA\nand\nMETAGGA\nfunctionals might break the symmetry of\nthe Bravais lattice slightly for cells that are not primitive cubic cells.\nThe origin of this problem is subtle and relates to the fact that the gradient field breaks the lattice symmetry for noncubic lattices. This can be fixed by setting\n\nGGA_COMPAT = .FALSE.\n\nto apply a spherical cutoff to the gradient field. In other words, the gradient field, as well as the charge density are set to zero for all reciprocal lattice vectors\nG\n{\\displaystyle \\bold{G}}\nthat exceed a certain cutoff length\nG\nc\nu\nt\n{\\displaystyle \\bold{G}_{cut}}\nbefore calculating the exchange-correlation energy and potential. \nThe cutoff\nG\nc\nu\nt\n{\\displaystyle \\bold{G}_{cut}}\nis determined automatically so that the cutoff sphere is fully inscribed in the parallelepiped defined by the FFT grid in reciprocal space.\n\nMind:\nFor compatibility reasons with older versions of VASP, the default is\nGGA_COMPAT\n=\n.TRUE.\nHowever, setting the tag usually changes the energy only in the sub-meV energy range (0.1 meV), and for most results the setting of\nGGA_COMPAT\nis insignificant. The most important exception is for the calculation of magnetic anisotropy, for which we strongly recommend\nGGA_COMPAT\n=.\nFALSE\n.",
    "related_tags": [
      "GGA",
      "METAGGA"
    ]
  },
  "HFALPHA": {
    "default_value": "Default: HFALPHA = 6/sqrt( ENMAX )/(2π) if HFRCUT is 0",
    "description": "HFALPHA sets the decay constant used in the method of Massida, Posternak, and Baldereschi, which is activated by HFRCUT =0.",
    "detailed_description": "HFALPHA\nsets the decay constant in the error-function-like charge distribution for the method of Massida, Posternak, and Baldereschi\n[1]\n. The error-function-like charge distribution is used to calculate the difference between the isolated probe charge and the periodically repeated probe charge in a homogenous background. The default for\nHFALPHA\nis 6/sqrt(\nENMAX\n)/(2π) in atomic units. This usually yields robust and accurate results in the range of meV compared to the Ewald summation used for a regular k-mesh. This is the default approach used to implement the convergence corrections of the\nCoulomb singularity\nin Hartree-Fock calculations. This does not work correctly for bandstructure calculations using the\n0-weight scheme\nor\nKPOINTS_OPT\nbecause the correction is only applied for points in the regular grid. To overcome this problem we recommend using the Coulomb truncation methods using\nHFRCUT\n.",
    "related_tags": [
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "LHFCALC",
      "HFRCUT",
      "LTHOMAS",
      "List of hybrid functionals",
      "Hybrid functionals: formalism",
      "Coulomb singularity"
    ]
  },
  "HFLMAX": {
    "default_value": "HFLMAX = 4",
    "description": "To be compatible w.r.t. old releases, VASP also reads the flag HFLMAX to the same effect as LMAXFOCK .",
    "detailed_description": "",
    "related_tags": [
      "LMAXFOCK",
      "LMAXFOCKAE"
    ]
  },
  "HFRCUT": {
    "default_value": "HFRCUT = 0",
    "description": "HFRCUT specifies how the Coulomb kernel is approximated at G=0 when the Fock energy and the exchange potential are evaluated.",
    "detailed_description": "In systems with periodic boundary conditions, the Coulomb energy and the Coulomb potential are usually evaluated under the assumption of a compensating background by introducing a compensation charge density. This is well-justified for the Hartree energy, where the compensation charge density stems from the ions. Yet, this assumption is not valid for the Fock exchange, which causes an error. For the Fock exchange potential and energy, one can correct the resulting error by assuming that the density matrix is local. The leading order correction is given by the difference between the electrostatic energy of a localized model charge density in a homogeneous background periodically repeated and the same model charge density in isolation. For details we refer to J. Paier\net al.,\n[1]\nSection II. D. 4.\n\nHFRCUT\n= 0: Ewald summation\nor\nmethod of Massida, Posternak, and Baldereschi depending on k-mesh\n[2]\n[3]\n\nIf a regular automatic k-mesh and the standard 1/r Coulomb kernel are used, the correction is computed using Ewald summations. If the k-mesh is\nnot\nregular (e.g., if the k-points are explicitly listed in the\nKPOINTS\nfile) or if kernels different from the bare Coulomb kernel are used (e.g., HSE functional), the method of Massida, Posternak, and Baldereschi\n[2]\n[3]\nis used. This approach assumes that the model charge density is an error-function-like charge distribution in real space in order to handle the long-range nature of the potential in reciprocal space. It requires setting a decay constant for the error function, see\nHFALPHA\n. Both methods, the Ewald summation and the method of Massida, Posternak, and Baldereschi, are strictly equivalent for regular k-mesh.\n\nHFRCUT\n= -1: Automated cutoff radius\n[4]\n\nAn alternative recipe is to replace the 1/r Coulomb kernel with a truncated Coulomb kernel that is strictly zero beyond a certain cutoff radius. If\nHFRCUT\nis set to -1, the radial cutoff is chosen to be equivalent to the radius of the sphere with a volume of the unit cell times the total number of k-points in the full Brillouin zone. For instance, for a  4x4x4 k-point grid, that yields 64 times the volume of the unit cell.\n\nHFRCUT\n= [cutoff radius]: Manually set cutoff radius in Ångström.\n\nIn the limit of many k-points, both methods (\nHFRCUT\n=-1 and\nHFRCUT\n=0) should yield identical results. In our experience, the\nHFRCUT\n=-1 converges more rapidly for systems with a gap, as well as molecules and atoms, whereas\nHFRCUT\n=0 converges faster for metallic systems. It is expedient to first converge the energies with respect to the number of k-points for both methods and then select for subsequent calculations the method that converges more rapidly. A detailed comparison of the convergence of the different methods for metallic and gapped materials was made by Sundararaman and Arias\n[5]\n.",
    "related_tags": [
      "AEXX",
      "AGGAX",
      "AGGAC",
      "ALDAC",
      "HFALPHA",
      "LTHOMAS",
      "List of hybrid functionals",
      "Hybrid functionals: formalism",
      "Coulomb singularity"
    ]
  },
  "HFSCREEN": {
    "default_value": "HFSCREEN = 0 (none)",
    "description": "HFSCREEN (in Å -1 ) specifies the range-separation parameter in range-separated hybrid functionals .",
    "detailed_description": "In case\nLHFCALC\n=.TRUE., in combination with PBE potentials (or\nGGA\n=PE), attributing a value to\nHFSCREEN\nwill switch from the PBE0 functional to, e.g., the closely related\nHSE03\n(\nHFSCREEN\n=0.3) or\nHSE06\n(\nHFSCREEN\n=0.2) functionals. It also needs to be set for dielectric-dependent hybrid functionals (DDH) and doubly screened hybrid (DSH) functionals, see\nLMODELHF\n.",
    "related_tags": [
      "LMODELHF",
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "LTHOMAS",
      "LRHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "HILLS_BIN": {
    "default_value": "HILLS_BIN = NSW",
    "description": "HILLS_BIN sets the number of steps after which the bias potential is updated in a metadynamics run (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "In\nmetadynamics\n(\nMDALGO\n=11 | 21), the bias potential is given as\n\nV\n~\n(\nt\n,\nξ\n)\n=\nh\n∑\ni\n=\n1\n⌊\nt\n/\nt\nG\n⌋\nexp\n⁡\n{\n−\n|\nξ\n(\nt\n)\n−\nξ\n(\ni\n⋅\nt\nG\n)\n|\n2\n2\nw\n2\n}\n.\n{\\displaystyle \n\\tilde{V}(t,\\xi) = h \\sum_{i=1}^{\\lfloor t/t_G \\rfloor} \\exp{\\left\\{ -\\frac{|\\xi^{(t)}-\\xi^{(i \\cdot t_G)}|^2}{2\nw^2} \\right\\}}.\n}\n\nThre parameters (\nHILLS_H\n,\nHILLS_W\n, and\nHILLS_BIN\n) must be provided by the user.\n\nThe number of steps after which the bias potential is updated is set by\nHILLS_BIN\n.",
    "related_tags": [
      "Metadynamics",
      "HILLS_H",
      "HILLS_W",
      "HILLSPOT",
      "MDALGO"
    ]
  },
  "HILLS_H": {
    "default_value": "HILLS_H = 10 − 3 {\\displaystyle 10^{-3}}",
    "description": "HILLS_H specifies the height of the Gaussian hill (in eV) used in metadynamics (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "In\nmetadynamics\n(\nMDALGO\n=11 | 21), the bias potential is given as\n\nV\n~\n(\nt\n,\nξ\n)\n=\nh\n∑\ni\n=\n1\n⌊\nt\n/\nt\nG\n⌋\nexp\n⁡\n{\n−\n|\nξ\n(\nt\n)\n−\nξ\n(\ni\n⋅\nt\nG\n)\n|\n2\n2\nw\n2\n}\n.\n{\\displaystyle \n\\tilde{V}(t,\\xi) = h \\sum_{i=1}^{\\lfloor t/t_G \\rfloor} \\exp{\\left\\{ -\\frac{|\\xi^{(t)}-\\xi^{(i \\cdot t_G)}|^2}{2\nw^2} \\right\\}}.\n}\n\nThre parameters (\nHILLS_H\n,\nHILLS_W\n, and\nHILLS_BIN\n) must be provided by the user.\n\nThe height of the Gaussian hills\nh\n{\\displaystyle h}\n(in eV) is set by\nHILLS_H\n.",
    "related_tags": [
      "Metadynamics",
      "HILLS_W",
      "HILLS_BIN",
      "HILLSPOT",
      "MDALGO"
    ]
  },
  "HILLS_W": {
    "default_value": "HILLS_W = 10 − 3 {\\displaystyle 10^{-3}}",
    "description": "HILLS_W specifies the width of the Gaussian hill (in units of the corresponding collective variable) used in metadynamics (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "In\nmetadynamics\n(\nMDALGO\n=11 | 21), the bias potential is given as\n\nV\n~\n(\nt\n,\nξ\n)\n=\nh\n∑\ni\n=\n1\n⌊\nt\n/\nt\nG\n⌋\nexp\n⁡\n{\n−\n|\nξ\n(\nt\n)\n−\nξ\n(\ni\n⋅\nt\nG\n)\n|\n2\n2\nw\n2\n}\n.\n{\\displaystyle \n\\tilde{V}(t,\\xi) = h \\sum_{i=1}^{\\lfloor t/t_G \\rfloor} \\exp{\\left\\{ -\\frac{|\\xi^{(t)}-\\xi^{(i \\cdot t_G)}|^2}{2\nw^2} \\right\\}}.\n}\n\nThre parameters (\nHILLS_H\n,\nHILLS_W\n, and\nHILLS_BIN\n) must be provided by the user.\n\nThe width of the Gaussian hills\nw\n{\\displaystyle w}\n(in units of the corresponding collective variable) is set by\nHILLS_W\n.",
    "related_tags": [
      "Metadynamics",
      "HILLS_H",
      "HILLS_BIN",
      "HILLSPOT",
      "MDALGO"
    ]
  },
  "HITOLER": {
    "default_value": "HITOLER = 5 × 10 − 5 {\\displaystyle 5\\times10^{-5}}",
    "description": "HITOLER specifies the convergence parameter for the iterative Hirschfeld partitioning in the Tkatchenko-Scheffler method.",
    "detailed_description": "",
    "related_tags": [
      "IVDW",
      "DFT-D2",
      "DFT-D3",
      "Tkatchenko-Scheffler method",
      "Tkatchenko-Scheffler method with iterative Hirshfeld partitioning",
      "Many-body dispersion energy",
      "dDsC dispersion correction"
    ]
  },
  "IALGO": {
    "default_value": "Default: IALGO = 8 for VASP.4.4 and older | = 38 else (if ALGO is not set)",
    "description": "IALGO selects the algorithm to optimize the orbitals.",
    "detailed_description": "Warning:\nWe suggest selecting the algorithms via\nALGO\ninstead of\nIALGO\n. Algorithms other than those available via\nALGO\nare subject to instabilities.\n\nConjugate gradient algorithms\n\nThe band-by-band conjugate gradient algorithms are no longer maintained or supported.\n\nIALGO\n=5-8: Conjugate gradient algorithms\n\nDeprecated:\nNot supported since vasp.5.\n\nOptimize each band iteratively using a conjugate gradient algorithm. Subspace-diagonalization before conjugate gradient algorithm. The conjugate gradient algorithm is used to optimize the eigenvalue of each band.\nIALGO\n=5\tsteepest descent\nIALGO\n=6\tconjugated gradient\nIALGO\n=7\tpreconditioned steepest descent\nIALGO\n=8\tpreconditioned conjugated gradient\nIALGO\n=8 is always fastest, whereas\nIALGO\n=5-7 are only implemented for test purposes.\nPlease mind, that\nIALGO\n=8 is not supported as of VASP.4.5, since M. Teter, Corning and M. Payne hold a patent on this algorithm. The algorithms have been replaced by faster and more efficient Davidson-like algorithms.\n\nIALGO\n=15-18: Conjugate gradient algorithms\n\nDeprecated:\nNot supported since vasp.5.\n\nSubspace-diagonalization after iterative refinement of the eigenvectors using the conjugate gradient algorithm. These switches are retained for compatibility reasons only and should not be used any longer. Generally\nIALGO\n=5-8 is preferable. Sub-switches as above.\n\nIALGO\n=28: Conjugate gradient algorithm\n\nDeprecated:\nNot supported since vasp.5.\n\nSubspace-diagonalization before conjugate gradient algorithm. No explicit orthonormalization of the gradients to the trial orbitals is done. This setting saves time, but does fail in most cases (mainly included for test purposes). Try\nIALGO\n=4X (RMM-DIIS) instead.\n\nThe blocked-Davidson scheme\n\nIALGO\n=38: Blocked-Davidson algorithm (\nALGO\n=N).\n\nKosugi algorithm (special blocked-Davidson iteration scheme). This algorithm is the default in VASP.4.6 and VASP.5.X. It optimizes a subset of\nNSIM\nbands simultaneously. The optimized bands are kept orthogonal to all other bands. If problems are encountered with the algorithm, try to decrease\nNSIM\n. Such problems are encountered, if linear dependencies develop in the search space. By reducing\nNSIM\nthe rank of the search space is decreased.\n\nRMM-DIIS\n\nIALGO\n=44-48: Residual minimization method direct inversion in the iterative subspace (\nALGO\n= F).\nIALGO\n=44-48 does not support hybrid functionals.\n\nThe RMM-DIIS algorithm\n[1]\n[2]\nreduces the number of orthonormalization steps (\nO\n(\nN\n3\n)\n{\\displaystyle O(N^3)}\n) considerably and is therefore much faster than\nIALGO\n=8 and\nIALGO\n=38, at least for large systems and for workstations with a small memory band width. For optimal performance, we recommend to use this switch together with\nLREAL\n=Auto). The algorithm works in a blocked mode in which several bands are optimized at the same time. This can improve the performance even further on systems with a low memory band width (default is presently\nNSIM\n=4).\n\nThe following sub-switches exist:\nIALGO\n=44 steepest descent eigenvalue minimization\nIALGO\n=46 residuum-minimization + preconditioning\nIALGO\n=48 preconditioned residuum-minimization (\nALGO\n=F)\n\nIALGO\n=48 is usually most reliable (\nIALGO\n=44 and 46 are mainly for test purposes).\n\nFor\nIALGO\n=4X, a subspace-diagonalization is performed before the residual vector minimization, and a Gram-Schmidt orthogonalization is employed after the RMM-DIIS step. In the RMM-DIIS step, each band is optimized individually (without the orthogonality constraint); a maximum of\nNRMM\niterative steps per band are performed for each band. The default is\nNRMM\n=4, and we recommend leaving this value unchanged.\n\nPlease mind, that the RMM-DIIS algorithm can fail in rare cases, whereas\nIALGO\n=38 did not fail for any system tested up to date. Therefore, if you have problems with\nIALGO\n=48 try first to switch to\nIALGO\n=38.\n\nHowever, in some cases the performance gains due to\nIALGO\n=48 are so significant that\nIALGO\n=38 might not be a feasible option. In the following we try to explain what to do if\nIALGO\n=48 does not work reliably:\n\nIn general two major problems can be encountered when using\nIALGO\n=48: First, the optimization of unoccupied bands might fail for molecular dynamics and relaxations. This is because our implementation of the RMM-DIIS algorithm treats unoccupied bands more \"sloppy\" then occupied bands during MD's. The problem can be solved rather easily by specifying\nWEIMIN\n=0 in the INCAR file. In that case all bands are treated accurately.\n\nThe other major problem (which occurs also for static calculations) is the initialization of the orbitals. Because the RMM-DIIS algorithm tends to find eigenvectors which are close the the initial set of trial vectors there is no guarantee to converge to the correct ground state! This situation is usually very easy to recognize; whenever one eigenvector is missing in the final solution, the convergence becomes slow at the end (mind, that it is possible that one state with a small fractional occupancy above the Fermi-level is missing). If you suspect that this is the case switch to\nICHARG\n=12 (i.e. no update of charge and Hamiltonian) and try to calculate the orbitals with high accuracy (\n10\n−\n6\n{\\displaystyle 10^{-6}}\n). If the convergence is fairly slow or stucks at some precision, the RMM-DIIS algorithm has problems with the initial set of orbitals (as a rule of thumb not more than 12 electronic iterations should be required to determine the orbital for the default precision for\nICHARG\n=12). The first thing to do in that case is to increase the number of bands (\nNBANDS\n) in the\nINCAR\nfile. This is usually the simplest and most efficient fix, but it does not work in all cases. This solution is also undesirable for MD's and long relaxations because it increases the computational demand somewhat. A simple alternative - which worked in all tested cases - is to use\nIALGO\n=38 (Davidson) for a few non selfconsistent iterations and to switch then to the RMM-DIIS algorithm. This setup is automatically selected when\nALGO\n= Fast is specified in the INCAR file (\nIALGO\nmust not specified in the\nINCAR\nfile in this case).\n\nThe final option is somewhat complicated and requires an understanding of how the initialization algorithm of the RMM-DIIS algorithm works: after the random initialization of the orbitals, the initial orbitals for the RMM-DIIS algorithm are determined during a non selfconsistent steepest descent phase (the number of steepest descent sweeps is given by\nNELMDL\n, default is\nNELMDL\n=-12 for RMM-DIIS). During this initial phase in each sweep, one steepest descent step per orbital is performed between each sub space rotation. This \"automatic\" simple steepest descent approach during the delay is faced with a rather ill-conditioned minimization problem and can fail to produce reasonable trial orbitals for the RMM-DIIS algorithm. In this case the quantity in the column \"rms\" will not decrease during the initial phase (12 steps), and you must improve the conditioning of the problem by setting the\nENINI\nparameter in the\nINCAR\nfile.\nENINI\ncontrols the cutoff during the initial (steepest descent) phase for\nIALGO\n=48. Default for\nENINI\nis\nENINI\n=\nENCUT\n. If convergence problems are observed, start with a slightly smaller\nENINI\n; reduce\nENINI\nin steps of 20%, till the norm of the residual vector (column \"rms\") decreases continuously during the first 12 steps.\n\nThe algorithm can be combined with\nLDIAG\n=.FALSE. to conserve the initial orbital order (when orbitals are read from the\nWAVECAR\nfile).\n\nA final note concerns the mixing:\nIALGO\n=48 dislikes too abrupt mixing. Since the RMM-DIIS algorithm always stays in the space spanned by the initial orbitals, and too strong mixing (large\nAMIX\n, small\nBMIX\n) might require discontinuous changes of the orbitals, the initial mixing must not be too sizable for\nIALGO\n=48. Try to reduce\nAMIX\nand increase\nBMIX\nif you suspect such a situation. Increasing\nNBANDS\nalso helps in this situation.\n\nDirect optimization\n\nIALGO\n=53-58: Treat total free energy as variational quantity and minimize the functional completely selfconsistently\n[3]\n[4]\n[5]\n.\n\nThese algorithms have been carefully optimized and should be selected for Hartree-Fock type as well as meta-GGA functionals. The present version is rather stable and robust even for metallic systems.\n\nImportant sub-switches:\n\nIALGO\n=53 damped MD with damping term automatically determined by the given time-step (\nALGO\n=D).\nIALGO\n=54 damped MD (velocity quenched or quickmin)\nIALGO\n=58 preconditioned conjugated gradient (\nALGO\n=A)\n\nFurthermore,\nLSUBROT\ndetermines whether the subspace rotation matrix (rotation matrix in the space spanned by the occupied and unoccupied orbitals) is optimized. The current default is\nLSUBROT\n=.FALSE. This allows for efficient groundstate calculations for insulators. When hybrid functionals are used,\nLSUBROT\n=.TRUE. can be tried for small gap semiconductors and  metals. This algorithm performs standard SCF steps during the direct optimization steps in order to determine an optimal rotation matrix between occupied and unoccupied orbitals. For hybrid functionals,\nLSUBROT\n=.TRUE. is generally faster, however, in rare cases, it can lead to instabilities\n[6]\n.\n\nThe preconditioned conjugate gradient (\nIALGO\n= 58,\nALGO\n= A) algorithm is recommended for insulators. The best stability is usually obtained if the number of bands equals half the number of electrons (non-spin-polarized case). In this case, the algorithm is fairly robust and foolproof and might even outperform the mixing algorithm.\n\nFor small gap systems and for metals, it is however usually required (metals) or desirable (semiconductors) to use a larger value for\nNBANDS\n. In this case, we recommend using the damped MD algorithm (\nIALGO\n=53,\nALGO\n=Damped) instead of the conjugate gradient.\n\nThe stability of the all bands simultaneously algorithms depends strongly on the setting of\nTIME\n. For the conjugate gradient case,\nTIME\ncontrols the step size in the trial step, which is required in order to perform a line minimization of the energy along the gradient (or conjugated gradient). Too small steps make the line minimization less accurate, whereas too large steps can cause instabilities. The step size is usually automatically scaled by the actual step size minimizing the total energy along the gradient (values can range from 1.0 for insulators to 0.01 for metals with a large density of states at the Fermi-level).\n\nFor the damped MD algorithm (\nIALGO\n=53,\nALGO\n=Damped), a sensible\nTIME\nstep is even more important. In this case\nTIME\nis not automatically adjusted, and the user is entirely responsible to choose an appropriate value. Too small time steps slow the convergence significantly, whereas too large values will always lead to divergence. It is sensible to optimize this value, in particular, if many different configurations are considered for a particular system. It is recommended to start with a small step size\nTIME\n, and to increase\nTIME\nby a factor 1.2 until the calculations diverge. The largest stable step\nTIME\nshould then be used for all calculations.\n\nThe damped MD algorithm can be combined with\nLDIAG\n=.FALSE. to conserve the initial orbital order (when orbitals are read from the\nWAVECAR\nfile).\n\nThe final algorithm\nIALGO\n=54 also uses a damped molecular dynamics algorithm but quenches the velocities to zero, if they are antiparallel to the present gradient (quick-min). It is usually not as efficient as\nIALGO\n=53, but it is also less sensitive to the\nTIME\nparameter.\n\nMind:\nConjugate gradient algorithms require a largely noise-free energy surface for fast and consistent convergence. Some functionals, for instance non-local vdW-DFT functionals or meta-GGA functionals can result in a very noisy energy surface with small discontinuities in the energy. This can cause divergence or very slow convergence of the direct minimization. The issue is usually mitigated by setting\nPREC\n= Accurate, or manually increasing the FFT grids for the densities (\nNGXF\n,\nNGYF\n,\nNGZF\n).\n\nMind:\nIt is very important to set an appropriate\nTIME\nfor some of the  algorithms. Furthermore, it might be expedient to set\nNELMDL\nto 1 or 2 for molecular dynamics simulations or relaxations in vasp.6. See the corresponding section in the documentation of\nNELMDL\n. If the ions move by a very large distance during relaxations, even\nNELMDL\n=3 can be expedient (in particular for HF type Hamiltonians).\n\nMiscellaneous\n\nIALGO\n=-1: Performance test.\n\nVASP does not perform an actual calculation, only some important parts of the program will be executed and the timing for each part is printed out at the end.\n\nIALGO\n=2: Orbitals and one-electron energies are kept fixed.\n\nOne electron occupancies and electronic density of states (DOS) are, however, recalculated. This option is only useful if a pre-converged\nWAVECAR\nfile is read. The option allows running selected post-processing tasks, such as local DOS, or the interface code to Wannier90.\n\nIALGO\n=3: Orbitals are kept fixed.\n\nOne-electron energies, band structure energies, and the electronic density of states (DOS) are, as well as, the total energy are recalculated for the present Hamiltonian (the one-electron occupancies are kept fixed, however). This option is only useful if a pre-converged\nWAVECAR\nfile is read. The option also allows running selected post-processing tasks, such as local DOS, or the interface code to Wannier90.\n\nIALGO\n=4: Orbitals are updated by applying a sub-space rotation.\n\nThe Hamiltonian is evaluated in the space spanned by the orbitals (read from\nWAVECAR\n), and one diagonalization in this space is performed. No optimization outside the subspace spanned by the orbitals is performed. Note: if\nNBANDS\nis larger or equal to the total number of plane waves, the resulting one-electron orbitals are exact.\n\nIALGO\n=90: Exact Diagonalization. This flag selects an exact diagonalization of the one-electron Hamiltonian. This requires a fairly large amount of memory and should be selected with caution. Specifically, we recommend selecting this algorithm to prepare the\nWAVECAR\nfor RPA or GW calculations, where many unoccupied orbitals are calculated (more than 30-50 % of the states spanned by the full plane-wave basis). To speed up the calculations, we recommend performing a routine ground-state calculation before calculating the unoccupied states.",
    "related_tags": [
      "ALGO",
      "LSUBROT",
      "NELM",
      "TIME",
      "LDIAG"
    ]
  },
  "IALL_IN_ONE": {
    "default_value": "Default: IALL_IN_ONE = 1 for LALL_IN_ONE =.TRUE. or NBANDS <0 | = -1 for LALL_IN_ONE =.FALSE.",
    "description": "IALL_IN_ONE >0 enables the all-in-one mode for many-body perturbation theory calculations, i.e., ALGO = ACFDT[R] , [EV]GW0[R] , GWR .",
    "detailed_description": "In the all-in-one mode, VASP automatically performs the necessary DFT steps prior to the many-body perturbation theory (MBPT) calculation, i.e. a DFT calculation with\nNBANDS\n, followed by an exact diagonalization of the Kohn-Sham Hamiltonian with\nNBANDSEXACT\nbands. \nNote,\nNBANDSEXACT\nis set by default to the maximum number of plane-waves given by the chosen energy cutoff for the orbitals\nENCUT\n. \nIn the all-in-one mode, the actual GW/RPA calculation is also performed with\nNBANDSEXACT\nbands. \nIf\nNBANDS_WAVE\nis not set, all orbitals are written to\nWAVECAR\n, which potentially becomes huge in file size.\n\nTip:\nThe\nNBANDS_WAVE\ntag can be used to limit the number of bands written to\nWAVECAR\nif\nIALL_IN_ONE\n>0.\n\nThe all-in-one mode is automatically enabled for\nALGO\n=[EV]GW[0]R, RPA[R],ACFDT[R] if\nNBANDS\nis not set.\n\nMind:\navailable as of VASP.6.4.0",
    "related_tags": [
      "ALGO",
      "NBANDS",
      "NBANDSEXACT",
      "NBANDS_WAVE",
      "LALL_IN_ONE"
    ]
  },
  "IBAND": {
    "default_value": "IBAND = not set",
    "description": "IBAND sets a list of bands that contribute to calculating the partial charge density .",
    "detailed_description": "IBAND\nselects a subset of bands for which the partial charge density is calculated when\nLPARD\n= .TRUE..\nPartial charge densities are written to the\nPARCHG\nfile, or one of its variants, depending on the setting of\nLSEPB\nand\nLSEPK\n.\n\nMind:\nSetting\nIBAND\nwill automatically set\nNBMOD\n= N, where N is the number of bands passed to\nIBAND\n, regardless of the\nNBMOD\nsetting in the\nINCAR\nfile.\n\nE.g. if\nIBAND = 20 21 22 23 45\nthe charge density will be calculated for the four bands 20 to 23 and band 45, and\nNBMOD\nwill be set to 5.",
    "related_tags": [
      "LPARD",
      "NBMOD",
      "EINT",
      "KPUSE",
      "LSEPB",
      "LSEPK",
      "LPARDH5",
      "PARCHG",
      "vaspout.h5",
      "Band-decomposed charge densities"
    ]
  },
  "IBRION": {
    "default_value": "Default: IBRION = -1 for NSW =−1 or 0 | = 0 else",
    "description": "determines how the crystal structure changes during the calculation:",
    "detailed_description": "no update\nIBRION\n=-1 (Avoid setting\nIBRION\n=-1 with\nNSW\n>0 to prevent recomputing the same structure\nNSW\ntimes).\n\nMolecular dynamics\nIBRION\n=0\n\nStructure optimization\nIBRION\n=1 RMM-DIIS\nIBRION\n=2 conjugate gradient\nIBRION\n=3 damped molecular dynamics\n\nComputing phonon modes\nIBRION\n=5 finite differences without symmetry\nIBRION\n=6 finite differences with symmetry\nIBRION\n=7 perturbation theory without symmetry\nIBRION\n=8 perturbation theory with symmetry\n\nAnalyzing transition states\nIBRION\n=40\nintrinsic-reaction-coordinate calculations\nIBRION\n=44\nimproved dimer method\n\nUser-supplied interactive changes\nIBRION\n=11 from standard input\nIBRION\n=12 from Python plugin\n\nMolecular dynamics\n\nIn\nmolecular-dynamics (MD) simulations\nthe positions of the ions are updated using a classical equation of motion for the ions. There are several algorithms for the\ntime propagation in MD\ncontrolled by selecting\nMDALGO\nand the choice of the\nthermostats\n. The MD run performs\nNSW\ntimesteps of length\nPOTIM\n.\n\nFrequently, performing an\nab-initio calculations\nin every step of an MD simulation is too expensive so that\nmachine-learned force fields\nare needed.\n\nTip:\nIn order to limit the output of the MD simulation, control the verbosity by setting\nNWRITE\n=0,1, or reduce the frequency of output using\nML_OUTBLOCK\n,\nNBLOCK\n, or\nKBLOCK\n.\n\nStructure optimization\n\nVASP optimizes the structure based on the degrees of freedom selected with the\nISIF\ntag and (if used) the selective dynamics\nPOSCAR\nfile.\nGenerally, the larger the number of degrees of freedom, the harder it is to find the optimal solution.\nTo find the solution, VASP provides multiple algorithms:\n\nRMM-DIIS (\nIBRION\n=1) reduces the forces by linear combination of previous positions. It is the method of choice for larger systems (>20 degrees of freedom) that are reasonably close to the ground-state structure.\nConjugate gradient (\nIBRION\n=2) finds the optimal step size along a search direction. It is a robust default choice but may need more iterations than RMM-DIIS.\nDamped molecular dynamics (\nIBRION\n=3) runs a MD simulation with decreasing velocity of the ions. Use this for large systems far away from the minimum to get to a better starting point for the other algorithms.\n\nConsult the\nstructure optimization\npage for advise on how to choose the optimization algorithm.\n\nComputing the phonon modes\n\nThe second-order derivatives of the total energy\nE\n{\\displaystyle E}\nwith respect to ionic positions\nR\nα\ni\n{\\displaystyle R_{\\alpha i}}\nof ion\nα\n{\\displaystyle \\alpha}\nin the direction\ni\n{\\displaystyle i}\n, is computed using a first-order derivative of the\nforces\nF\nβ\nj\n{\\displaystyle F_{\\beta j}}\n. Then, the dynamical matrix\nD\nα\ni\nβ\nj\n{\\displaystyle D_{\\alpha i \\beta j}}\nis constructed, diagonalized, and the phonon modes and frequencies of the system are reported in the\nOUTCAR\nfile and\nvaspout.h5\n. Also see\ntheory on phonons\n.\n\nTip:\nIt may be necessary to set\nEDIFF\nbecause the default (\nEDIFF\n= 1E-4\n) often results in unacceptably large errors.\n\nVASP implements two different methods to compute the phonon modes and can use symmetry to reduce the number of computed displacements:\n\nIBRION\n= 5\nfinite differences\nwithout\nsymmetry\nIBRION\n= 6\nfinite differences\nwith\nsymmetry\nIBRION\n= 7\ndensity-functional-perturbation theory\nwithout\nsymmetry\nIBRION\n= 8\ndensity-functional-perturbation theory\nwith\nsymmetry\n\nFor finite differences, the elastic tensors and internal strain tensors is computed for\nISIF\n>=3.\nCompute Born-effective charges, piezoelectric constants, and the ionic contribution to the dielectric tensor by specifying\nLEPSILON\n= .TRUE.\n(\nlinear response theory\n) or\nLCALCEPS\n= .TRUE.\n(finite external field).\n\nAlso see\ncomputing the phonon dispersion and DOS\n.\n\nAnalyzing transition states\n\nTo study the kinetics of chemical reactions, one may want to construct\ntransition states\nor follow the reaction path.\nFor the analysis of transition states the following methods are available:\n\nSetting\nIBRION\n= 40\n, you can start from a transition state and monitor the energy along an intrinsic-reaction coordinate (IRC). The\nIRC calculations\nsection describes this method.\nWith the\nimproved dimer method\n(\nIBRION\n= 44\n), you can search for a the transition state starting from an arbitrary structure in the investigated phase space.\nThe\nnudged elastic bands\nmethod finds an approximate reaction path based on the initial and final structure, i.e., reactant and product.\n\nInteractively supplied positions and lattice vectors\n\nOccasionally, you may want to run VASP for related structures where the overhead of restarting VASP is significant.\nIn these scenarios, VASP provides the following alternatives\n\nWith\nIBRION\n= 11\n, you can provide new structures via the standard input. For\nISIF\n>=3, a complete\nPOSCAR\nfile is read, otherwise just the positions in fractional coordinates.\n\nIf you\nlinked VASP with Python\n, you can\nwrite a Python plugin\nto modify the structure. Set\nIBRION\n= 12\nor\nPLUGINS/STRUCTURE\n= T\nto activate it.",
    "related_tags": [
      "NSW",
      "POTIM",
      "MDALGO",
      "SMASS",
      "NFREE",
      "ISIF",
      "LEPSILON",
      "LCALCEPS",
      "POSCAR",
      "CONTCAR",
      "XDATCAR",
      "vaspout.h5",
      "Time-propagation algorithms in molecular dynamics",
      "Structure optimization",
      "Selective dynamics",
      "Computing the phonon dispersion and DOS",
      "Transition states",
      "IRC calculations",
      "Improved Dimer Method",
      "Writing a Python plugin"
    ]
  },
  "IBSE": {
    "default_value": "IBSE = 2",
    "description": "IBSE can be used to select the algorithm for solving the Bethe-Salpeter or Casida equation.",
    "detailed_description": "The following options are available to solve the Bethe-Salpeter or Casida equation:\n\nIBSE\n= 0:\nExact diagonalization with old BSE driver\nIBSE\n= 1:\nTime evolution\nIBSE\n= 2:\nExact diagonalization\nIBSE\n= 3:\nLanczos algorithm\n\nIBSE\n= 2\nand\nIBSE\n= 0\nyield exactly the same results but the old driver (\nIBSE\n= 0\n) is typically much slower and will be deprecated in the future.\n\nMind:\nIBSE\n= 2\nand\nIBSE\n= 3\nare only available for VASP version 6.5.0 and above.\n\nRelated tag and articles\n\nIBSE\n,\nBSEPREC\n,\nNBANDSV\n,\nNBANDSO\n,\nCSHIFT\n,\nOMEGAMAX\n,\nBSE calculations\n,\nTime-dependent density-functional theory calculations\n,\nBethe-Salpeter equations",
    "related_tags": []
  },
  "ICHARG": {
    "default_value": "Default: ICHARG = 2 if ISTART =0 | = 0 else",
    "description": "ICHARG determines how VASP constructs the initial charge density.",
    "detailed_description": "ICHARG\n=0\n\nCalculate the charge density from initial wave functions.\nIf\nISTART\nis\ninternally reset\ndue to an invalid\nWAVECAR\nfile,\nICHARG\nwill be set to\nICHARG\n=2.\n\nWarning:\nThis may cause convergence problems for some systems.\n\nICHARG\n=1\n\nRead the charge density from\nCHGCAR\nfile, and extrapolate from the old positions (on\nCHGCAR\n) to the new positions using a linear combination of atomic charge densities.\nIn the\nPAW method\n, there is, however, one important point to keep in mind: For the on-site densities (that is, the densities within the PAW sphere), only l-decomposed charge densities up to\nLMAXMIX\nare written. Upon restart, the energies might, therefore, differ slightly from the fully converged energies. The discrepancies can be large for the DFT+U method. In this case, one might need to increase\nLMAXMIX\nto 4 (d-elements) or even 6 (f-elements).\n\nTip:\nTo improve convergence and reduce the number of electronic steps, it is recommended to set ICHARG = 1 when starting calculations repeatedly with small changes in the input parameters.\n\nICHARG\n=2\n\nTake superposition of atomic charge densities.\n\nICHARG\n=4\n\nRead potential from file\nPOT\n. The local potential on the file\nPOT\nis written by the optimized-effective-potential methods (OEP), if the flag\nLVTOT\n=.TRUE. is supplied in the\nINCAR\nfile. Supported as of VASP.5.1.\n\nICHARG\n=5\n\nExternal charge-density-update mode to read in and add an external correction to the Kohn-Sham (KS) occupations in every SCF step of the\nelectronic minimization\n. The initialization of the charge density is done as in\nICHARG\n=1, and after\nNELMDL\nsteps VASP reads the occupations from a user-supplied text file\nGAMMA\n(or\nvaspgamma.h5\nif compiled with\nHDF5 support\n) for each k point in each SCF step. The procedure described in Ref.\n[1]\nEq. (30)-(32) is then used to construct a new charge density from the combined occupations (KS occupations +\nGAMMA\nfile), from which the next KS potential is constructed. The\nDFT workflow\ncontinues after a user-supplied\nvasp.lock\nfile is read. Additionally, with\nICHARG\n=5 after each SCF step VASP writes out all with\nLOCPROJ\ndefined wave function projections. The\nICHARG\n=5 mode can be used with an external code that modifies the occupations, and requires extra output after each SCF step. The TRIQS software package\n[2]\nmakes use of it to perform charge self-consistent DFT plus dynamical mean field theory (DMFT) calculations\n[3]\n[4]\n. See the\nDFT+DMFT\nhowto page for a tutorial.\n\nICHARG\n=10\n\nnon-selfconsistent calculations: Adding 10 to the value of\nICHARG\n, e.g.,\nICHARG\n=11 or 12 (or the less convenient value 10) means that the charge density will be kept constant during the\nentire electronic minimization\n.\n\nThere are several reasons why to keep the charge density constant:\nICHARG\n=11\nTo obtain the eigenvalues (for band-structure plots) or the density of states (DOS) of a given charge density read from\nCHGCAR\n. The self-consistent\nCHGCAR\nfile must be determined beforehand by a fully self-consistent calculation with a k-point grid spanning the entire Brillouin zone.\n\nICHARG\n=12\nNon-self-consistent calculations for a superposition of atomic charge densities. This is in the spirit of the non-self-consistent\nHarris-Foulkes functional\n. The stress and the forces calculated by VASP are correct, and it is possible to perform an ab-initio MD for the non-selfconsistent\nHarris-Foulkes functional\n.\n\nTip:\nIf\nICHARG\nis set to 11 or 12, it is strongly recommended to set\nLMAXMIX\nto twice the maximum l-quantum number in the pseudopotentials. Thus, for s and p elements\nLMAXMIX\nshould be set to 2, for d elements\nLMAXMIX\nshould be set to 4, and for f elements\nLMAXMIX\nshould be set to 6.\n\nThe initial charge density is of importance in the following cases:\n\nIf\nICHARG\n≥10 the charge density remains constant during the run.\n\nFor all algorithms except\nIALGO\n=5X the initial charge density is used to set up the initial Hamiltonian that is used in the first few non-selfconsistent steps, c.f.,\nNELMDL\ntag.",
    "related_tags": [
      "CHGCAR",
      "ISTART",
      "LCHARG",
      "LMAXMIX",
      "NELMDL",
      "INIWAV",
      "GAMMA",
      "vaspgamma.h5",
      "↑",
      "M. Schüler, O. E. Peil, G. J. Kraberger, R. Pordzik, M. Marsman, G. Kresse, T. O. Wehling, and M. Aichhorn, Journal of Physics: Condensed Matter 30 , 475901 (2018).",
      "O. Parcollet, M. Ferrero, T. Ayral, H. Hafermann, I. Krivenko, L. Messio and P. Seth, Computer Physics Communications 196 , 398 (2015).",
      "M. E. Merkel, A. Carta, S. Beck and Alexander Hampel, Journal of Open Source Software 7 , 77 (2022).",
      "M. Aichhorn, L. Pourovskii, P. Seth, V. Vildosola, M. Zingl, O. E. Peil, X. Deng, J. Mravlje, G. J. Kraberger, C. Martins, M. Ferrero, O. Parcollet, Computer Physics Communications 204 , 200 (2016)."
    ]
  },
  "ICHIBARE": {
    "default_value": "ICHIBARE = 1",
    "description": "determines the order of the finite difference stencil used to calculate the magnetic susceptibility.",
    "detailed_description": "ICHIBARE\nspecifies the order of the finite difference stencil used to calculate the magnetic susceptibility (second order derivative in Eq. 47 of Yates\net al.\n[1]\n).\nICHIBARE\nmay be set to 1, 2, or 3. Often the default (\nICHIBARE\n=1) is sufficient. A higher\nICHIBARE\nresults in a substantial increase of the computational load.",
    "related_tags": [
      "LCHIMAG",
      "DQ",
      "LNMR_SYM_RED",
      "NLSPLINE"
    ]
  },
  "ICORELEVEL": {
    "default_value": "ICORELEVEL = 0",
    "description": "ICORELEVEL controls whether the core energies are explicitly calculated or not and how they are calculated.",
    "detailed_description": "The binding energy of core electrons\nE\nC\nL\n{\\displaystyle E_{CL}}\nis given as\n\nE\nC\nL\n=\nE\n(\nn\nc\n−\n1\n)\n−\nE\n(\nn\nc\n)\n{\\displaystyle E_{CL} = E(n_{c}-1) - E(n_{c})}\n.\n\nHere,\nE\n(\nn\nc\n)\n{\\displaystyle E(n_{c})}\nis the energy from a standard density-functional calculation in which the number of core electrons corresponds to the unexcited ground state.\nE\n(\nn\nc\n−\n1\n)\n{\\displaystyle E(n_{c}-1)}\nis the energy of a calculation where one electron is removed from the core of one particular atom and added to the valence or conduction band.\n\nThe core-level binding energies can be calculated either in the initial-state approximation or the final-state approximation. In the initial-state approximation, a core electron is removed from the core states and added to the valence/conduction bands but no change of the potential (by e.g. relaxation of the valence electrons) is allowed. The core-level binding energy can then be directly calculated by the Kohn-Sham eigenvalues\n[1]\n[2]\nof the core level\nϵ\nc\n{\\displaystyle \\epsilon_{c}}\nand the Fermi energy\nϵ\nF\n{\\displaystyle \\epsilon_{F}}\n\nE\nC\nL\ni\n=\nϵ\nc\n−\nϵ\nF\n{\\displaystyle E_{CL}^{\\mathrm{i}}=\\epsilon_{c} - \\epsilon_{F}}\n.\n\nIn the final-state approximation, the electrons (valence electrons in the frozen-core approximation) are allowed to relax, so that the local hole is screened. In other words, a fully self-consistent electronic calculation is carried out with a core hole and an additional electron in the valence/conduction bands.\n\nThe following options are available in VASP:\n\nICORELEVEL\n=0: The core energies are not calculated (default).\nICORELEVEL\n=1: The initial-state approximation is used. This just involves recalculating the KS eigenvalues of the core states\n\nafter a self-consistent calculation of the valence charge density.\nICORELEVEL\n=1 is a little bit more involved than the calculations using\nLVTOT\n=\n.TRUE.\n, since the Kohn-Sham energy of each core state is recalculated. This adds very little extra cost to the calculations. Usually,\nthe shifts correspond very closely to the change of the electrostatic potential at the lattice sites (calculated using\nLVTOT\n=\n.TRUE.\n).\n\nICORELEVEL\n=2: The final-state approximation is used. Electrons are removed from the core and placed into the valence (effectively increasing\nNELECT\n). The VASP implementation excites all selected core electrons for\n\nall atoms of one species. The species, as well as the selected electrons, are specified using\n\nCLNT\n= species\nCLN\n=  main quantum number of excited core electron\nCLL\n=  l quantum number of excited core electron\nCLZ\n=  electron count\n\nThe electron count\nCLZ\nspecifies how many electrons are excited\nfrom the core. Usually, 1 or 0.5 (Slater's transition state) are sensible choices.\nCLNT\nselects for which species in the\nPOTCAR\nfile the electrons\nare excited. Usually one would like to excite the electrons for\nonly one atom, this requires changing the\nPOSCAR\nand\nPOTCAR\nfile,\nsuch that the selected atom corresponds to one species in the\nPOTCAR\nfile.\ni.e. if the calculation invokes a supercell with 64 atoms of one type,\nthe selected atom needs to be singled out, and the\nPOSCAR\nfile will\nthen contain 63 \"standard\"  atoms as well as one special  species,\nat which the excited core hole will be placed\n(the\nPOTCAR\nfile will hold two identical PAW datasets in this case).\n\nSeveral caveats apply to this mode.\nFirst, the excited electron is always spherical and multipole splittings\nare not available. Second, the other core electrons are not allowed\nto relax, which might cause a slight error in the calculated\nenergies.\nThird, absolute energies are not meaningful, since VASP usually\nreports valence energies only. Only relative\nshifts of the core electron binding energies are relevant\n(in some cases, the VASP total energies might become even positive).\n\nSuper-cell core-hole method\n\nICORELEVEL\n=2 and itss related tags are necessary for the calculation of\nX-ray absorption spectra\n(XAS) using the super-cell core-hole method.\n\nA description of how to set up super-cell core-hole calculations is given in this\narticle\n.\n\nA tutorial for the calculation of XAS is given in this\narticle\n.\n\nBethe-Salpeter equation for XAS\n\nICORELEVEL\n=2 is required for the calculation of\nXAS\nusing the Bethe-Salpeter equation.\n\nA description of how to set up a BSE calculation for XAS is given in this\narticle\n. There is also an accompanying\ntheory page\n.",
    "related_tags": [
      "CLNT",
      "CLN",
      "CLL",
      "CLZ",
      "CH_LSPEC",
      "CH_SIGMA",
      "CH_NEDOS",
      "ALGO",
      "LADDER",
      "LHARTREE",
      "NBANDSV",
      "NBANDSO",
      "OMEGAMAX",
      "ANTIRES",
      "Bethe-Salpeter equation for core excitations",
      "Supercell core-hole calculations"
    ]
  },
  "IDIMENSIONALITY": {
    "default_value": "KERNEL_TRUNCATION/IDIMENSIONALITY = 3",
    "description": "KERNEL_TRUNCATION/IDIMENSIONALITY specifies the boundary condition used to compute the hartree and ionic potential.",
    "detailed_description": "If\nKERNEL_TRUNCATION/LTRUNCATE\n= T,\nKERNEL_TRUNCATION/IDIMENSIONALITY\ndetermines the boundary condition that is used to compute the local potential.\nThe default value of 3 implies that the system is periodic in all dimensions, i.e. there is no influence of kernel truncation on the resulting energies and forces.\nSetting\nKERNEL_TRUNCATION/IDIMENSIONALITY\nto either 0 or 2 uses the 0D and 2D truncated kernel respectively.\n[1]\n[2]\n[3]\nThese kernels create 0D (i.e. no periodic interactions, as is the case of molecules) and 2D (i.e. periodic interactions only in two dimensions, as in the case for surfaces).\n\nMind:\nIF\nKERNEL_TRUNCATION/LTRUNCATE\nis switched off, all other KERNEL_TRUNCATION tags, i.e.\nKERNEL_TRUNCATION/IDIMENSIONALITY\n,\nKERNEL_TRUNCATION/LCOARSEN\n, and\nKERNEL_TRUNCATION/ISURFACE\nwill be ignored.\n\nKERNEL_TRUNCATION/IDIMENSIONALITY\n= 0\n\nConsider using the option when computing energies and forces of atoms and molecules.\nRecommended\nINCAR\ntags to be used with option are\n\nKERNEL_TRUNCATION {\n       LTRUNCATE      = T\n       IDIMENSIONALITY = 0\n       LCOARSEN       = T\n }\n\nKERNEL_TRUNCATION/IDIMENSIONALITY\n= 2\n\nUse this option when computing the energies and forces of 2D and quasi-2D systems, such as 2D materials and surfaces. We suggest setting the following\nINCAR\ntags for a surface that is oriented along the z-axis\n\nKERNEL_TRUNCATION {\n       LTRUNCATE      = T\n       IDIMENSIONALITY = 2\n       LCOARSEN       = T\n       ISURFACE       = 3\n }",
    "related_tags": [
      "KERNEL_TRUNCATION/LTRUNCATE",
      "KERNEL_TRUNCATION/LCOARSEN",
      "KERNEL_TRUNCATION/ISURFACE"
    ]
  },
  "IDIPOL": {
    "default_value": "",
    "description": "IDIPOL switches on monopole/dipole and quadrupole corrections to the total energy in a specific direction (1-3) or all directions (4)",
    "detailed_description": "IDIPOL = 1-3\n\nThe dipole moment will be calculated only parallel to the direction of the first, second or third lattice vector, respectively. The corrections for the total energy are calculated as the energy difference between a monopole/dipole and quadrupole in the current supercell and the same dipole placed in a super cell with the corresponding lattice vector approaching infinity.\n\nTip:\nThis flag should be used for slab calculations, with the surface normal being the direction in which the\nIDIPOL\nis set, and optionally specifying the center of mass of the slab with the\nDIPOL\ntag.\n\nIDIPOL = 4\n\nFor\nIDIPOL\n=4 the full dipole moment in all directions will be calculated, and the corrections to the total energy are calculated as the energy difference between a monopole/dipole/quadrupole in the current supercell and the same monopole/dipole/quadrupole placed in a vacuum.\n\nTip:\nUse this flag for calculations for isolated molecules.\n\nNote\n: strictly speaking quadrupole corrections is not the proper wording. The relevant quantity is\n\n∫\nd\n3\nr\nρ\n(\nr\n)\n‖\nr\n‖\n2\n.\n{\\displaystyle  \\int d^3{\\mathbf r} \\rho(\\mathbf r) \\Vert \\mathbf r\\Vert^2.}",
    "related_tags": [
      "Monopole Dipole and Quadrupole corrections",
      "NELECT",
      "EPSILON",
      "DIPOL",
      "LDIPOL",
      "LMONO",
      "EFIELD"
    ]
  },
  "IEPSILON": {
    "default_value": "",
    "description": "IEPSILON determines along which Cartesian direction the E field is applied.",
    "detailed_description": "IEPSILON\n=1 x direction\nIEPSILON\n=2 y direction\nIEPSILON\n=3 z direction\nIEPSILON\n=4 x, y and z direction; three indpendent calculations are performed\n\nImportant:\nIEPSILON\nonly applies to the time-propagation algorithm.",
    "related_tags": [
      "BSE calculations"
    ]
  },
  "IFC_ASR": {
    "default_value": "IFC_ASR = 1",
    "description": "If positive, enforces the acoustic sum rule on the interatomic force constants during an electron-phonon calculation.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThe matrix of interatomic force constants (IFC) should obey the so-called acoustic sum rule (ASR).\nHowever, due to numerical inaccuracies, it is possible that the ASR is slightly broken in practice.\nIn such cases, the phonons obtained from the\nFourier interpolation of the IFC matrix\ncan become imaginary.\n\nBy setting\nIFC_ASR\n> 0\n, the ASR is explicitly enforced on the IFC matrix via an iterative scheme.\nThe number of iterations is also given by\nIFC_ASR\n.\n\nMind:\nIFC_ASR\n= -2\nhas a special meaning. Usually, the IFC matrix is forced to be symmetric. However, if\nIFC_ASR\n= -2\n, then the IFC matrix is neither forced to be symmetric nor is the ASR applied. We do not recommend to use this setting.",
    "related_tags": [
      "ELPH_RUN",
      "ELPH_IGNORE_IMAG_PHONONS"
    ]
  },
  "IFC_LR": {
    "default_value": "IFC_LR = 1",
    "description": "Controls the treatment of the long-range part of the interatomic force constants during electron-phonon calculations.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis tag controls the treatment of the\nlong-range electrostatic contributions to the interatomic force constants (IFC)\narising in polar dielectric materials.\nIFC_LR\n= 1\nhas the same effect as\nLPHON_POLAR\n= True\nbut is used in the context of electron-phonon interactions.\n\nMind:\nIn this case, the required Born effective charges and dielectric tensor are read from the\nphelel_params.hdf5\nfile.\n\nModes\n\nIFC_LR\n≤ 0\nNo long-range correction scheme is applied to the IFC matrix. This is most likely very inaccurate for semiconductors and insulators with non-vanishing Born effective charge.\nIFC_LR\n= 1\nDipole corrections are applied to the IFC matrix.",
    "related_tags": [
      "Bandstructure renormalization",
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_LR"
    ]
  },
  "IGPAR": {
    "default_value": "",
    "description": "This tag specifies the socalled parallel or G ∥ {\\displaystyle \\bold{G}_{\\parallel}} direction in the integration over the reciprocal space unit cell needed for LCALCPOL .",
    "detailed_description": "",
    "related_tags": [
      "LCALCPOL",
      "LCALCEPS",
      "EFIELD_PEAD",
      "LPEAD",
      "IPEAD",
      "LBERRY",
      "NPPSTR",
      "DIPOL",
      "Berry phases and finite electric fields"
    ]
  },
  "IMAGES": {
    "default_value": "IMAGES = 0",
    "description": "Defines the number of VASP calculations in separate directories, (e.g., 01, 02, 03, etc.) for nudged elastic band calculations, parallel tempering , and thermodynamic integration .",
    "detailed_description": "IMAGES\nsets the number of independent VASP calculations in separate directories. The primary\nINCAR\nfile should be located in the root directory.\nOther files such as\nKPOINTS\n,\nPOTCAR\n, and\nPOSCAR\ncan be placed in subdirectories, e.g., 01, 02, 03, etc., or in the root directory. Files in subdirectories take precedence over those in the root directory.\n\nSee\nuse cases\ndescribed below.\n\nFile handling\n\nWhen VASP starts, it reads the file\nINCAR\nin the root directory.\nSubsequently, VASP splits the MPI communicator into subgroups for each image.\nIf an\nINCAR\nfile is present in the subdirectories 01, 02, 03, ..., VASP will process those afterward.\nOtherwise, VASP continues reading from the root\nINCAR\nfile. \nYou can also provide image-specific data in the root\nINCAR\nfile if the files are very similar\n\n# general INCAR tags\n IMAGES = 4\n TEBEG = 600\n \n # INCAR tags only on IMAGE 1\n IMAGE_1 {\n   TEBEG = 400\n }\n \n # INCAR tags only on IMAGE 2\n IMAGE_2 {\n   TEBEG = 500\n }\n\nHere, images 3 and 4 would use\nTEBEG\n=600 because the value is not specified for the image.\nThe files\nKPOINTS\nand\nPOTCAR\nwill be read from the subdirectory if available and from the root directory otherwise.\nThe\nPOSCAR\nfile and all other input files are always read from the subdirectories.\nAll\noutput files\n(including\nOUTCAR\nand\nOSZICAR\n) are always written to the subdirectories.\n\nTo summarize, to run a calculation with\nIMAGES\n, you provide:\n\nan\nINCAR\nfile in the root directory\noptionally an overwriting\nINCAR\nfile in the subdirectories\nPOSCAR\nfiles in the subdirectories\nKPOINTS\nand\nPOTCAR\neither in the root or in the subdirectories\n\nUse cases\n\nNudged elastic bands\nIf\nIMAGES\nis set without any other tag, an elastic-band calculation is performed. This defaults to the recommended nudged-elastic-band method, but other options are available by modifying the\nSPRING\ntag. Please consider the\nnudged-elastic-bands how-to\nand the\nSPRING\ntag for more information.\n\nThermodynamic coupling-constant integrations\nWhen\nVCAIMAGES\nis set in the\nINCAR\nfile, VASP computes a thermodynamic coupling-constant integration. This, in turn, sets\nIMAGES\n=2, running two VASP calculations in the subdirectories 01 and 02. Since this is a special case where the two calculations may have different computational costs,\nNCORE_IN_IMAGE1\ncan be set to force an unequal split of the processes across the two images. The tag\nVCAIMAGES\ndescribes in more detail how to set up these calculations.\n\nParallel tempering/replica-exchange method and performing independent calculations\nIf the tag\nLTEMPER\n=.TRUE. is set in the\nINCAR\nfile, VASP will perform parallel tempering calculations. In this case, it is necessary to provide different\nPOSCAR\nfiles in each subdirectory and modify the\nTEBEG\neither by separate\nINCAR\nfiles or nested IMAGE_\nX\n/\nTEBEG\ndefinitions in the root\nINCAR\nfile. For further details, refer to the description of the\nLTEMPER\ntag. The combination\nLTEMPER\n=.TRUE. and\nNTEMPER\n=0, also allows to run entirely independent calculations in the individual subdirectories. This might be helpful to make better use of nodes with many cores.",
    "related_tags": [
      "VCAIMAGES",
      "LTEMPER",
      "nudged-elastic-bands how-to",
      "SPRING"
    ]
  },
  "IMIX": {
    "default_value": "IMIX = 4",
    "description": "IMIX specifies the type of density mixing .",
    "detailed_description": "IMIX\n=0: No mixing\n\nρ\nm\ni\nx\n=\nρ\no\nu\nt\n{\\displaystyle \\rho_{\\rm mix}=\\rho_{\\rm out}\\,}\n\nIMIX\n=1: Kerker mixing\n\nFor Kerker mixing\n[1]\n, the mixed density is given by\nρ\nm\ni\nx\n(\nG\n)\n=\nρ\ni\nn\n(\nG\n)\n+\nA\nG\n2\nG\n2\n+\nB\n2\n(\nρ\no\nu\nt\n(\nG\n)\n−\nρ\ni\nn\n(\nG\n)\n)\n{\\displaystyle \\rho_{\\rm mix}\\left(G\\right)=\\rho_{\\rm in}\\left(G\\right)+A \\frac{G^2}{G^2+B^2}\\Bigl(\\rho_{\\rm out}\\left(G\\right)-\\rho_{\\rm in}\\left(G\\right)\\Bigr)}\nwith\nA\n{\\displaystyle A}\n=\nAMIX\nand\nB\n{\\displaystyle B}\n=\nBMIX\n. If\nBMIX\nis very small, e.g.,\nBMIX\n=0.0001, a straight mixing is obtained.\n\nMind:\nBMIX\n=0 might cause floating-point exceptions on some platforms.\n\nIMIX\n=2: Variant of Tchebycheff mixing\n\nVASP uses a variant of the popular Tchebycheff-mixing scheme\n[2]\n. Here, the following second order equation of motion is used:\nρ\n¨\ni\nn\n(\nG\n)\n=\n2\n∗\nA\nG\n2\nG\n2\n+\nB\n2\n(\nρ\no\nu\nt\n(\nG\n)\n−\nρ\ni\nn\n(\nG\n)\n)\n−\nμ\nρ\n˙\ni\nn\n(\nG\n)\n{\\displaystyle \\ddot{\\rho}_{\\rm in}\\left(G\\right) = 2*A \\frac{G^2}{G^2+B^2}\\Bigl(\\rho_{\\rm out}\\left(G\\right)-\\rho_{\\rm in}\\left(G\\right)\\Bigr)-\\mu \\dot{\\rho}_{\\rm in}\\left(G\\right)}\nwith\nA\n{\\displaystyle A}\n=\nAMIX\n,\nB\n{\\displaystyle B}\n=\nBMIX\n, and\nμ\n{\\displaystyle \\mu}\n=\nAMIN\n. A velocity Verlet algorithm is used to integrate this equation. The discretized equation reads:\nρ\n˙\nN\n+\n1\n/\n2\n=\n(\n(\n1\n−\nμ\n/\n2\n)\nρ\n˙\nN\n−\n1\n/\n2\n+\n2\n∗\nF\nN\n)\n/\n(\n1\n+\nμ\n/\n2\n)\n{\\displaystyle \\dot{\\rho}_{N+1/2} =  \\Bigl(\\left(1-\\mu/2\\right) \\dot{\\rho}_{N-1/2} + 2*F_N \\Bigr)/\\left(1+\\mu/2\\right)}\nwhere\nF\n(\nG\n)\n=\nA\nG\n2\nG\n2\n+\nB\n2\n(\nρ\no\nu\nt\n(\nG\n)\n−\nρ\ni\nn\n(\nG\n)\n)\n{\\displaystyle F\\left(G\\right)=A\\frac{G^2}{G^2+B^2} \\Bigl(\\rho_{\\rm out}\\left(G\\right)-\\rho_{\\rm in}\\left(G\\right)\\Bigr)}\nand\nρ\nN\n+\n1\n=\nρ\nN\n+\n1\n+\nρ\n˙\nN\n+\n1\n/\n2\n{\\displaystyle \\rho_{N+1}=\\rho_{N+1}+\\dot{\\rho}_{N+1/2}}\n,\nwhere the index\nN\nis the electronic iteration, and\nF\nis the force acting on the charge.\n\nFor\nBMIX\n≈0, no model for the dielectric matrix is used. For\nμ\n=\n2\n{\\displaystyle \\mu=2}\na simple straight mixing is obtained. Therefore,\nμ\n=\n2\n{\\displaystyle \\mu=2}\ncorresponds to maximal damping, while\nμ\n=\n0\n{\\displaystyle \\mu=0}\nimplies no damping. To determine the optimal parameters for\nμ\n{\\displaystyle \\mu}\nand\nAMIX\n, first converge to the ground state with the Pulay mixer (\nIMIX\n=4). Then, search for the the eigenvalues of the charge-dielectric matrix in the\nOUTCAR\nfile at the last occurrence of\n\neigenvalues of (default mixing * dielectric matrix)\n\nThe optimal parameters are then given by:\n\nAMIX\n=\nA\nM\nI\nX\n(\na\ns\nu\ns\ne\nd\ni\nn\nP\nu\nl\na\ny\nr\nu\nn\n)\n∗\ns\nm\na\nl\nl\ne\ns\nt\ne\ni\ng\ne\nn\nv\na\nl\nu\ne\n{\\displaystyle ={\\rm AMIX}({\\rm as\\; used\\; in\\; Pulay\\; run})*{\\rm smallest\\; eigenvalue}}\nAMIN\n=\nμ\n=\n2\ns\nm\na\nl\nl\ne\ns\nt\ne\ni\ng\ne\nn\nv\na\nl\nu\ne\n/\nl\na\nr\ng\ne\ns\nt\ne\ni\ng\ne\nn\nv\na\nl\nu\ne\n{\\displaystyle =\\mu=2\\sqrt{{\\rm smallest\\; eigenvalue}/{\\rm largest\\; eigenvalue}}}\n\nIMIX\n=4: Broyden's 2\nnd\nmethod and Pulay-mixing method (default)\n\nFor\nWC\n=0, VASP uses Broyden's 2\nnd\nmethod,\n[3]\n[4]\nand, for\nWC\n>0, VASP uses Pulay-mixing method\n[5]\n.\nThe default is a Pulay mixer with an initial approximation for the charge-dielectric function according to Kerker\n[1]\nA\n×\nmax\n(\nG\n2\nG\n2\n+\nB\n2\n,\nA\nm\ni\nn\n)\n{\\displaystyle A\\times\\max\\left(\\frac{G^2}{G^2+B^2},A_{\\rm min}\\right)}\nwhere\nA\n{\\displaystyle A}\n=\nAMIX\n,\nB\n{\\displaystyle B}\n=\nBMIX\n, and\nA\nm\ni\nn\n{\\displaystyle A_{\\rm min}}\n=\nAMIN\n.\n\nAMIN\n=0.4 usually yields good convergence.\nAMIX\nstrongly depends on the system, for instance, it should be small, e.g.,\nAMIX\n= 0.02, for metals.\nIn the Broyden scheme, the functional form of the initial mixing matrix is determined by\nAMIX\nand\nBMIX\nor the\nINIMIX\ntag. The metric used in the Broyden scheme is specified through\nMIXPRE\n.",
    "related_tags": [
      "INIMIX",
      "MAXMIX",
      "AMIX",
      "BMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC"
    ]
  },
  "INCREM": {
    "default_value": "INCREM = 0",
    "description": "INCREM controls the transformation velocity in the slow-growth approach (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "In\nslow-growth simulations\n(\nMDALGO\n=1 | 2), the value of each controlled geometric parameter with\nSTATUS=0\nis increased by\nINCREM\nin every simulation step.\n\nIt must be supplied for each controlled geometric parameter for which\nSTATUS=0\nwas specified in the\nICONST\n-file.",
    "related_tags": [
      "MDALGO",
      "ICONST"
    ]
  },
  "INIMIX": {
    "default_value": "INIMIX = 1",
    "description": "Determines the functional form of the initial mixing matrix in the Broyden scheme ( IMIX =4).",
    "detailed_description": "The initial mixing matrix might influence the convergence speed for complex situations (especially surfaces and magnetic systems), nevertheless\nINIMIX\nmust not be changed from the default setting: anything which can be done with\nINIMIX\ncan also be done with\nAMIX\nand\nBMIX\n, and changing\nAMIX\nand\nBMIX\nis definitely preferable.\n\nPossible choices for INIMIX are:\n\nINIMIX\n=0\n\nLinear mixing according to the setting of\nAMIX\n\nINIMIX\n=1\n\nKerker mixing (see\nIMIX\n=1) according to the settings of\nAMIX\nand\nBMIX\n.\nThe mixed density is given by\nρ\nm\ni\nx\n(\nG\n)\n=\nρ\ni\nn\n(\nG\n)\n+\nA\nG\n2\nG\n2\n+\nB\n2\n(\nρ\no\nu\nt\n(\nG\n)\n−\nρ\ni\nn\n(\nG\n)\n)\n{\\displaystyle \\rho_{\\rm mix}\\left(G\\right)=\\rho_{\\rm in}\\left(G\\right)+A \\frac{G^2}{G^2+B^2}\\Bigl(\\rho_{\\rm out}\\left(G\\right)-\\rho_{\\rm in}\\left(G\\right)\\Bigr)}\nwith\nA\n{\\displaystyle A}\n=\nAMIX\nand\nB\n{\\displaystyle B}\n=\nBMIX\n\nINIMIX\n=2\n\nNo mixing (equal to\nINIMIX\n=0 and\nAMIX\n=1, not recommended)",
    "related_tags": [
      "IMIX",
      "MAXMIX",
      "AMIX",
      "BMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC"
    ]
  },
  "INIWAV": {
    "default_value": "Default: INIWAV = 1",
    "description": "Specifies how to set up the initial orbitals in case ISTART =0.",
    "detailed_description": "INIWAV\n=0\n\nTake 'jellium orbitals', i.e., fill the Kohn-Sham–orbital arrays with plane waves of lowest kinetic energy = lowest eigenvectors for a constant potential ('jellium').\n\nImportant:\n'jellium' calculations require a specific\nPOTCAR\nfile, not included in the standard potential database.\n\nINIWAV\n=1\n\nFill the Kohn-Sham–orbital arrays with random numbers. It is definitely the safest fool-proof switch.\n\nTip:\nUse\nINIWAV\n=1 whenever possible.\n\nMind:\nThe\nINIWAV\ntag is only used for jobs that start from scratch (\nISTART\n=0) and has no meaning otherwise.\n\nRelated tags and sections\n\nISTART",
    "related_tags": []
  },
  "IPEAD": {
    "default_value": "IPEAD = 4",
    "description": "IPEAD specifies the order of the finite difference stencil used to compute the derivative of the cell-periodic part of the orbitals w.r.t. k , |∇ k u n k ⟩ ( LPEAD =.TRUE.), and the derivative of the polarization w.r.t. the orbitals, δ P /δ⟨ψ n k | for ( LCALCEPS =.TRUE., or EFIELD_PEAD ≠ 0 ).",
    "detailed_description": "A central finite differences formula or order\nIPEAD\nis used to compute the first-order derivative of the cell-periodic part of the orbitals w.r.t.\nk\n.\nThe coefficients for the different orders can be found\nhere\n.",
    "related_tags": [
      "LPEAD",
      "LCALCEPS",
      "EFIELD_PEAD",
      "Berry phases and finite electric fields"
    ]
  },
  "IRC_DELTA0": {
    "default_value": "IRC_DELTA0 = 0.0015",
    "description": "Defines the tolerance factor Δ 0 {\\displaystyle \\Delta_0} in Å used in the IRC calculations .",
    "detailed_description": "The smaller the value of\nIRC_DELTA0\n, the closer the computed IRC trajectory follows the true IRC pathway. However, a small tolerance factor\nΔ\n0\n{\\displaystyle \\Delta_0}\nnecessitates more time steps and, thus, computational effort.",
    "related_tags": [
      "IRC calculations",
      "IRC_DIRECTION",
      "IRC_STOP",
      "IRC_MINSTEP",
      "IRC_MAXSTEP",
      "IRC_VNORM0"
    ]
  },
  "IRC_DIRECTION": {
    "default_value": "IRC_DIRECTION = 1",
    "description": "Defines the direction of the initial displacement of the initial transition-state structure in IRC calculations .",
    "detailed_description": "Defines the direction of the initial displacement of the initial transition-state structure along the unstable direction (corresponding to Hesse matrix eigenmode with negative force constant) used in\nIRC calculations\n. Only the values 1 and -1 are allowed, corresponding to the parallel and the antiparallel directions, respectively.",
    "related_tags": [
      "IRC calculations",
      "IRC_STOP",
      "IRC_DELTA0",
      "IRC_MINSTEP",
      "IRC_MAXSTEP",
      "IRC_VNORM0"
    ]
  },
  "IRC_MAXSTEP": {
    "default_value": "IRC_MAXSTEP = 3.000",
    "description": "Upper limit for the step size (in fs).",
    "detailed_description": "The damped-velocity-Verlet algorithm for the\nIRC calculations\nuses an adaptively varying size of the time step. It depends on the estimated accuracy of the previous step.\nIRC_MAXSTEP\ndefines the upper limit for the step size in fs.",
    "related_tags": [
      "IRC calculations",
      "IRC_DIRECTION",
      "IRC_STOP",
      "IRC_DELTA0",
      "IRC_MINSTEP",
      "IRC_VNORM0"
    ]
  },
  "IRC_MINSTEP": {
    "default_value": "IRC_MINSTEP = 0.0250",
    "description": "Lower limit for the step size (in fs).",
    "detailed_description": "The damped-velocity-Verlet algorithm for the\nIRC calculations\nuses an adaptively varying size of the time step. It depends on the estimated accuracy of the previous step.\nIRC_MINSTEP\ndefines the lower limit for the step size in fs.",
    "related_tags": [
      "IRC calculations",
      "IRC_DIRECTION",
      "IRC_STOP",
      "IRC_DELTA0",
      "IRC_MAXSTEP",
      "IRC_VNORM0"
    ]
  },
  "IRC_STOP": {
    "default_value": "IRC_STOP = 20",
    "description": "Sets the number of steps in which the energy must monotonously increase before an IRC calculation terminates.",
    "detailed_description": "Along the IRC pathway, from a higher energy state, i.e., the transition state or the excited state, towards a lower energy state, i.e., reactants or products, the energy generally decreases. In some cases, the IRC pathway may encounter regions with relatively constant energy (plateaus) or fluctuations due to numerical noise or complex interactions, particularly in the vicinity of transition states.\n\nIRC_STOP\nsets the number of time steps with increasing energy, after which the damped-velocity-Verlet algorithm in an\nIRC calculation\nterminates. In order to avoid a premature termination, especially close to transition states,\nIRC_STOP\nshould always be greater than 1.",
    "related_tags": [
      "IRC calculations",
      "IRC_DIRECTION",
      "IRC_DELTA0",
      "IRC_MINSTEP",
      "IRC_MAXSTEP",
      "IRC_VNORM0"
    ]
  },
  "IRC_VNORM0": {
    "default_value": "IRC_VNORM0 = 0.002",
    "description": "The constant velocity vector (in Å/fs) in an IRC calculation .",
    "detailed_description": "In the damped-velocity-Verlet algorithm for\nIRC calculations\n, the damping is realized via rescaling the velocity vector to a constant value (in Å/fs) defined via the parameter\nIRC_VNORM0\n.",
    "related_tags": [
      "IRC calculations",
      "IRC_DIRECTION",
      "IRC_STOP",
      "IRC_DELTA0",
      "IRC_MINSTEP",
      "IRC_MAXSTEP"
    ]
  },
  "ISEARCH": {
    "default_value": "ISEARCH = 0",
    "description": "Controls the line-search algorithm used during the direct minimization of the electronic structure ( ALGO = All ).",
    "detailed_description": "ISEARCH\n= 0\n: Legacy line-search algorithm.\nISEARCH\n= 1\n: Improved line-search algorithm.\n\nThe line search determines the optimal step size along the conjugate gradient search direction.\nISEARCH\n= 0\nperforms incremental steps along the search direction. It may lead to inconsistencies in total energy evaluations and slower convergence.\nISEARCH\n= 1\nintroduces a more robust and consistent method for determining the optimal step size, leading to improved convergence behavior and more reliable energy minimization.\n\nImportant:\nWe recommend\nISEARCH\n= 1\nwhen performing electronic minimizations with\nALGO\n= All\n, as it generally improves convergence stability and reduces the total number of required SCF steps.\n\nMind:\nISEARCH\n= 0\nshould only be used for backward compatibility or benchmarking against legacy behavior.\n\nImproved line-search algorithm\n\nThe improved algorithm (\nISEARCH\n= 1\n) introduces several enhancements over the legacy implementation:\n\nAbsolute reference\n- each line search step starts from the origin of the search direction rather than progressing incrementally. This improves energy consistency.\nEfficient slot system\n- all trial steps are stored in slots, reducing redundant energy evaluations.\nMinimum-acceptance criterion\n- the final energy minimum of the line search is accepted only if its neighboring slots have also been evaluated (first principles energies are known), ensuring reliable interpolation.\nPolynomial and spline fitting\nIf ≤ 5 data points are available, an up to 4th-order polynomial fit is used to determine the minimum.\nIf > 5 data points are available, a spline interpolation is used instead, offering greater robustness than higher-order polynomials.\nGradient correction\n- the line search typically relies on total energy evaluations only, which is faster than computing gradients. If the new gradient is not sufficiently orthogonal to the search direction from the previous step, a correction is applied using all available data points (via polynomial or spline fit).",
    "related_tags": [
      "ALGO"
    ]
  },
  "ISIF": {
    "default_value": "Default: ISIF = 0 for IBRION = 0 (molecular dynamics) or LHFCALC = .TRUE. | = 2 else",
    "description": "Determines if the stress tensor is calculated and which ionic degrees of freedom are varied.",
    "detailed_description": "For\nISIF\n≥\n{\\displaystyle \\ge}\n2, the stress tensor is calculated. It is defined as the negative of the derivative of the energy\nE\n{\\displaystyle   E }\nwith respect to the strain tensor\nη\nj\ni\n{\\displaystyle \\eta_{ji}}\n:\n\nσ\ni\nj\n=\n−\nδ\nE\nδ\nη\nj\ni\n{\\displaystyle   \\sigma_{ij} = - \\frac{\\delta E} {\\delta \\eta_{ji}} }\n.\n\nThis might be different from other first principles codes.\nA positive in the diagonals means that the system is under compressive strain and wants to expand. A negative value implies that the system is under tensile strain and wants to reduce its volume. The stress tensor is symmetric\nσ\ni\nj\n=\nσ\nj\ni\n{\\displaystyle \\sigma_{ij}=\\sigma_{ji}}\n, and, thus, it has six independent entries. \nThe calculation of the stress tensor is relatively time-consuming, and, therefore, by default, it is switched off in some cases. The forces are always calculated.\n\nISIF\nalso determines which degrees of freedom (ionic positions, cell volume, and cell shape) of the structure are allowed to change.\n\nISIF\ncalculate\ndegrees-of-freedom\nforces\nstress tensor\npositions\ncell shape\ncell volume\n0\nyes\nno\nyes\nno\nno\n1\nyes\ntrace only\nyes\nno\nno\n2\nyes\nyes\nyes\nno\nno\n3\nyes\nyes\nyes\nyes\nyes\n4\nyes\nyes\nyes\nyes\nno\n5\nyes\nyes\nno\nyes\nno\n6\nyes\nyes\nno\nyes\nyes\n7\nyes\nyes\nno\nno\nyes\n8\nyes\nyes\nyes\nno\nyes\n\nFor\nISIF\n= 1\n, only the trace of the stress tensor is calculated. This means only the total pressure is correct and can be read off in the line:\n\nexternal pressure =      ... kB\n\nThe individual components of the stress tensor are not reliable in this case and must be disregarded.\n\nAccuracy\n\nWarning:\nThe PAW basis for the\nelectronic minimization\nis not adjusted when the structure is varied during a calculation.\n\nTherefore, carefully consider effects such as\nPulay stress\nand choose generous settings for the\nelectronic minimization\n. Generally, volume changes should be done only with an increased energy cutoff, e.g.,\nENCUT\n= 1.3×max(\nENMAX\n)\n, and\nPREC\n= High\n.\n\nTo further control the ionic degrees of freedom that can vary during the calculation, set `Selective dynamics` in the\nPOSCAR\nfile.\nISIF\n= 8\nis only available as of VASP.6.4.1.",
    "related_tags": [
      "IBRION",
      "structure optimization",
      "Ensembles",
      "POSCAR",
      "LATTICE_CONSTRAINTS"
    ]
  },
  "ISMEAR": {
    "default_value": "ISMEAR = 1",
    "description": "ISMEAR determines how the partial occupancies f n k are set for each orbital. SIGMA determines the width of the smearing in eV.",
    "detailed_description": "Please consider how-to guide to choose the optimal\nsmearing technique\n.\n\nTag options\n\nISMEAR\n> 0\n: method of Methfessel-Paxton order\nISMEAR\nwith width\nSIGMA\n.\n\nMind:\nMethfessel-Paxton can yield erroneous results for insulators because the partial occupancies can be unphysical.\n\nISMEAR\n= 0\n: Gaussian smearing with width\nSIGMA\n.\n\nISMEAR\n= -1\n: Fermi smearing with width\nSIGMA\n.\n\nISMEAR\n= -2\n: Partial occupancies are read in from the\nWAVECAR\nand kept fixed throughout run. Alternatively, you can also choose occupancies in the\nINCAR\nfile with the tag\nFERWE\n(and\nFERDO\nfor\nISPIN\n= 2\ncalculations).\n\nISMEAR\n= -3\n: perform a loop over\nSMEARINGS\nparameters supplied in the\nINCAR\nfile.\n\nISMEAR\n= -4\n: Tetrahedron method without smearing.\n\nISMEAR\n= -5\n: Tetrahedron method with Blöchl corrections without smearing.\n\nISMEAR\n= -14\n: Tetrahedron method with Fermi-Dirac smearing\nSIGMA\n.\n\nISMEAR\n= -15\n: Tetrahedron method with Blöchl corrections with Fermi-Dirac smearing\nSIGMA\n.\n\nMind:\nUse a\nΓ-centered\nk\n-mesh\nfor the tetrahedron methods.",
    "related_tags": [
      "SIGMA",
      "EFERMI",
      "FERWE",
      "FERDO",
      "SMEARINGS",
      "Smearing technique",
      "K-point integration"
    ]
  },
  "ISPIN": {
    "default_value": "ISPIN = 1",
    "description": "ISPIN specifies spin polarization.",
    "detailed_description": "ISPIN\n=1: non-spin-polarized calculations are performed.\nISPIN\n=2: spin-polarized calculations (collinear) are performed.\n\nBy combining\nISPIN\nwith\nMAGMOM\ncollinear magnetism can be studied.\n\nImportant:\nFor noncollinear calculations\nISPIN\nis ignored. In VASP 6.5.0, the calculation will exit with an error message if\nISPIN\n=2 and\nMAGMOM\nis used in combination with the\nLNONCOLLINEAR\n=.TRUE.",
    "related_tags": [
      "MAGMOM"
    ]
  },
  "ISTART": {
    "default_value": "Default: ISTART = 1 if a WAVECAR file exists | = 0 else",
    "description": "ISTART determines whether or not to read the WAVECAR file.",
    "detailed_description": "ISTART\n=0\n\nStart job: \"begin from scratch\". Initialize the orbitals according to the flag\nINIWAV\n.\n\nISTART\n=1\n\nContinuation job: \"restart with constant energy cut-off\". Orbitals are read from the\nWAVECAR\nfile (usage is restricted in the parallel version). The set of plane waves will be redefined and re-padded according to the new cell size/shape (\nPOSCAR\n) and the new plane wave cut-off (\nINCAR\n). These values might differ from the old values, that are stored in the\nWAVECAR\nfile. If the\nWAVECAR\nfile is missing or if the\nWAVECAR\nfile contains an inappropriate number of bands and/or k-points the flag\nISTART\nwill revert to\nISTART\n=0 (see above).\n\nThe usage of\nISTART\n=1 is recommended if the size/shape of the supercell (see section on\nvolume relaxations\n) or the cut-off energy changed with respect to the last run and if one wishes to redefine the set of plane waves according to a new setting.\n\nISTART\n=1 is the usual setting for convergence tests with respect to the cut-off energy and for all jobs where the volume/cell-shape varies (e.g. to calculate binding energy curves looping over a set of volumes).\n\nISTART\n=2\n\nContinuation job: \"restart with constant basis set\". Orbitals are read from the\nWAVECAR\nfile.\n\nThe set of plane waves will\nnot\nbe changed even if the cut-off energy or the cell size/shape given on the\nINCAR\nand\nPOSCAR\nfiles are different from the values stored on the\nWAVECAR\nfile. If the\nWAVECAR\nfile is missing or if the\nWAVECAR\nfile contains an inappropriate number of bands and/or k-points the\nISTART\nwill revert to\nISTART\n=0 (see above).\n\nIf the cell shape has not changed then\nISTART\n=1 and\nISTART\n=2 lead to the same result.\n\nISTART\n=2 is usually used if one wishes to restart with the same basis set used in the previous run.\n\nMind:\nDue to\nPulay stresses\n, there is a difference between evaluating the equilibrium volume with a constant basis set and a constant energy cut-off (unless absolute convergence with respect to the basis set is achieved!).\n\nIf you are looking for the equilibrium volume, calculations with a constant energy cut-off are preferable to calculations with a constant basis set, therefore always restart with\nISTART\n=1 unless you really know what you are looking for (see the section on\nvolume relaxations\n).\n\nThere is only one exception to this general rule: all volume/cell shape relaxation algorithms implemented in VASP work with a constant basis set, so continuing such jobs requires to set\nISTART\n=2 to get a 'consistent restart' with respect to the previous runs (see section\nvolume relaxations\n)! This menas that that number of plane waves is consistent with the previous run but the energy cut-off is not (see section\nPulay stress\n).\n\nISTART\n=3\n\nContinuation job: \"full restart including orbitals and charge prediction\".\n\nSame as\nISTART\n=2 but in addition a valid\nTMPCAR\nfile must exist, containing the positions and orbitals at time steps\nt\n(\nN\n−\n1\n)\n{\\displaystyle t(N-1)}\nand\nt\n(\nN\n−\n2\n)\n{\\displaystyle t(N-2)}\n, which are needed for the orbital and charge prediction scheme (used for MD-runs).\n\nISTART\n=3 is generally not recommended unless an operating system imposes a serious restriction on the CPU time per job: if you continue with\nISTART\n=1 or 2, a relatively large number of electronic iterations might be necessary to reach convergence of the orbitals in the second and third molecular-dynamics steps.\nISTART\n=3 therefore saves time and is important if a molecular-dynamics run is split into very small pieces (e.g.,\nNSW\n<10).\n\nNevertheless, we have found that it is safer to restart the orbital prediction after 100 to 200 steps. If\nNSW\n>30,\nISTART\n=1 or 2 is strongly recommended.\n\nMind:\nIf\nISTART\n=3, a non-existing\nWAVECAR\nor\nTMPCAR\nfile or any inconsistency of input data will immediately stop execution.\n\nExamples that use this tag",
    "related_tags": []
  },
  "ISURFACE": {
    "default_value": "",
    "description": "KERNEL_TRUNCATION/ISURFACE specifies the non-periodic dimension when performing calculations with 2D kernel truncation methods.",
    "detailed_description": "When performing 2D kernel truncation with\nKERNEL_TRUNCATION/IDIMENSIONALITY\n=2,\nKERNEL_TRUNCATION/ISURFACE\nspecifies which direction is non-periodic.\nThe most common use case is to set\nKERNEL_TRUNCATION/ISURFACE\nto the dimension along the surface normal.\n\nIf the surface normal points in the direction of the x-axis\nKERNEL_TRUNCATION/ISURFACE\n= 1, if it is along the y-axis,\nKERNEL_TRUNCATION/ISURFACE\n= 2 and if it is along the z-axis,\nKERNEL_TRUNCATION/ISURFACE\n= 3.\n\nMind:\nIF\nKERNEL_TRUNCATION/LTRUNCATE\nis switched off, all other KERNEL_TRUNCATION tags, i.e.\nKERNEL_TRUNCATION/IDIMENSIONALITY\n,\nKERNEL_TRUNCATION/LCOARSEN\n, and\nKERNEL_TRUNCATION/ISURFACE\nwill be ignored.",
    "related_tags": [
      "KERNEL_TRUNCATION/LTRUNCATE",
      "KERNEL_TRUNCATION/LCOARSEN",
      "KERNEL_TRUNCATION/IDIMENSIONALITY"
    ]
  },
  "ISYM": {
    "default_value": "Default: ISYM = 1 if VASP runs with USPPs | = 3 if LHFCALC =.TRUE. | = 2 else",
    "description": "ISYM determines the way VASP treats symmetry.",
    "detailed_description": "ISYM\n=1 | 2 | 3, switches on the use of symmetry.\nFor\nISYM\n=-1 | 0, the use of symmetry is switched off.\n\nFor\nISYM\n=2 a more efficient, memory conserving symmetrization of the charge density is used (than for\nISYM\n=1). This reduces memory requirements in particular for the parallel version.\n\nFor\nISYM\n=3, VASP does not directly symmetrize the charge density. Instead, the charge density is constructed by applying the relevant symmetry operations to the orbitals at the\nk\n-points in the irreducible part of the Brillouin zone. This method of symmetrization is used when\nLHFCALC\n=.TRUE.\n\nFor\nISYM\n=0, VASP does not use symmetry, but it will assume that Ψ\nk\n=Ψ\n*\n-k\nand reduces the sampling of the Brillouin zone accordingly. This value should be set for molecular dynamics, i.e.\nIBRION\n=0.\n\nFor\nISYM\n=-1 the use of symmetry is switched off completely.\n\nWhen the use of symmetry is switched on, VASP determines the point group symmetry and the space group consistent with the structure and initial velocities found on the\nPOSCAR\nfile (this is written out to the\nOUTCAR\nfile for each\nNWRITE\noption), and the initial magnetic moments specified through the\nMAGMOM\ntag in the\nINCAR\nfile. The\nSYMPREC\n-tag (VASP.4.4.4 and newer versions) determines by how much atomic positions may differ and still be judged to be equivalent by the symmetry detection algorithms. The default is 10\n-5\n, which is usually sufficiently large even if the\nPOSCAR\nfile has been generated with a single precision program. Increasing the\nSYMPREC\ntag means, that the positions in the\nPOSCAR\nfile can be less accurate. During the symmetry analysis, VASP determines\n\nthe Bravais lattice type of the supercell,\nthe point group symmetry and the space group of the supercell with basis (static and dynamic) - and prints the names of the group (space group: only 'family'),\nthe type of the generating elementary (primitive) cell if the supercell is a non-primitive cell,\nall 'trivial non-trivial' translations (= trivial translations of the generating elementary cell within the supercell) -- needed for symmetrization of the charge,\nthe symmetry-irreducible set of k-points if automatic k-mesh generation was used and additionally the symmetry-irreducible set of tetrahedra if the tetrahedron method was chosen together with the automatic k-mesh generation and of course also the corresponding weights ('symmetry degeneracy'),\nand tables marking and connecting symmetry equivalent ions.\n\nThe symmetry analysis is done in four steps:\n\nFirst the point group symmetry of the lattice (as supplied by the user) is determined.\nThen tests are performed, on whether the basis breaks the symmetry. Accordingly, these symmetry operations are removed.\nThe initial velocities are checked for symmetry breaking.\nFinally, it is checked whether\nMAGMOM\nbreaks the symmetry. Correspondingly the magnetic symmetry group is determined.\n\nThe program symmetrizes automatically:\n\nThe total charge density according to the determined space group\nThe forces on the ions according to the determined space group.\nThe stress tensor according to the determined space group\n\nWhy is symmetrization necessary: Within LDA the symmetry of the supercell and the charge density is always the same. This symmetry is broken because a symmetry-irreducible set of\nk\npoints is used for the calculation. To restore the correct charge density and the correct forces it is necessary to symmetrize these quantities.\n\nIt must be stressed that VASP does not determine the symmetry elements of the primitive cell. If the supercell has a lower symmetry than the primitive cell only the lower symmetry of the supercell is used in the calculation. In this case, one should not expect that forces that should be zero according to symmetry will be precisely zero in actual calculations. The symmetry of the primitive cell is in fact broken in several places in VASP:\n\nLocal potential:\n\nIn reciprocal space, the potential\nV\n(\nG\n) should be zero, if\nG\nis not a reciprocal lattice vector of the primitive cell. For\nPREC\n=Medium, this is not guaranteed due to \"aliasing\" or wrap around and the charge density (and therefore the Hartree potential) might violate this point. But even for\nPREC\n=High, small errors are introduced, because the exchange-correlation potential is calculated in real space.\n\nk\n-points:\n\nIn most cases, the automatic\nk\n-point grid does not have the symmetry of the primitive cell.\n\nTip:\nIf symmetry is switched on then\nNWRITE\n=3 writes out the symmetry operations to the\nOUTCAR\nfile.",
    "related_tags": [
      "OUTCAR",
      "IALGO",
      "IBRION",
      "MDALGO",
      "ISIF",
      "NWRITE"
    ]
  },
  "IVDW": {
    "default_value": "IVDW = 0 (no correction)",
    "description": "IVDW specifies a vdW dispersion term of the atom-pairwise or many-body type.",
    "detailed_description": "Available vdW atom-pairwise and many-body methods\n\nWith all methods listed below, a dispersion correction is added to the total energy, but also to the atomic forces and stress tensor, such that lattice relaxations, molecular dynamics, and vibrational analysis (via finite differences) can be performed. Note, however, that these correction schemes are currently not available for phonon calculations based on\ndensity functional perturbation theory\n.\n\nIVDW=\nType\nDescription\n1 or 10\npairwise\nDFT-D2\nmethod of Grimme.\n[1]\nAvailable as of VASP.5.2.11.\n11\npairwise\nDFT-D3\nmethod of Grimme with zero-damping function.\n[2]\nAvailable as of VASP.5.3.4.\n12\npairwise\nDFT-D3\nmethod with Becke-Johnson damping function.\n[3]\nAvailable as of VASP.5.3.4.\n13\npairwise\nDFT-D4\nmethod.\n[4]\nAvailable as of VASP.6.2 as\nexternal package\n.\n3\npairwise\nDFT-ulg\n[5]\nmethod. Available as of VASP.5.3.5.\n4\npairwise\ndDsC dispersion correction\n[6]\n[7]\nmethod. Available as of VASP.5.4.1.\n2 or 20\npairwise\nTkatchenko-Scheffler method\n.\n[8]\nAvailable as of VASP.5.3.3.\n21\npairwise\nTkatchenko-Scheffler method with iterative Hirshfeld partitioning\n.\n[9]\n[10]\nAvailable as of VASP.5.3.5.\n202\nmany-body\nMany-body dispersion energy\nmethod (MBD@rsSCS).\n[11]\n[12]\nAvailable as of VASP.5.4.1.\n263\nmany-body\nMany-body dispersion energy with fractionally ionic model for polarizability\nmethod (MBD@rSC/FI).\n[13]\n[14]\nAvailable as of VASP.6.1.0.\n14\npairwise and many-body\nOne of the methods available in the\nLibrary libMBD of many-body dispersion methods\n.\n[15]\n[16]\n[17]\nAvailable as of VASP.6.4.3 as\nexternal package\n.\n\nMind:\nThe\nlibMBD\nimplementations (\nIVDW\n=14) of the Tkatchenko-Scheffler methods and their MBD extensions are much faster (analytical calculation of the forces) than the VASP implementations (numerical calculation of the forces). Therefore, it is strongly recommended to use the\nlibMBD\nimplementation if available.\nThe parameter\nLVDW\nused in previous versions of VASP (5.2.11 and later) to activate the\nDFT-D2\nmethod is now obsolete. If\nLVDW\n=\n.TRUE.\nis defined,\nIVDW\nis automatically set to 1 (unless\nIVDW\nis specified in\nINCAR\n).",
    "related_tags": [
      "DFT-D2",
      "DFT-D3",
      "DFT-D4",
      "Tkatchenko-Scheffler method",
      "Self-consistent screening in Tkatchenko-Scheffler method",
      "Tkatchenko-Scheffler method with iterative Hirshfeld partitioning",
      "Many-body dispersion energy",
      "Many-body dispersion energy with fractionally ionic model for polarizability",
      "DFT-ulg",
      "dDsC dispersion correction",
      "LIBMBD_METHOD",
      "LUSE_VDW",
      "Nonlocal vdW-DF functionals",
      "↑",
      "S. Grimme, J. Comput. Chem. 27 , 1787 (2006).",
      "S. Grimme, J. Antony, S. Ehrlich, and S. Krieg, J. Chem. Phys. 132 , 154104 (2010).",
      "S. Grimme, S. Ehrlich, and L. Goerigk, J. Comput. Chem. 32 , 1456 (2011).",
      "E. Caldeweyher, S. Ehlert, A. Hansen, H. Neugebauer, S. Spicher, C. Bannwarth, and S. Grimme, J. Chem. Phys. 150 , 154122 (2019).",
      "H. Kim, J.-M. Choi, and W. A. Goddard, III, J. Phys. Chem. Lett. 3 , 360 (2012).",
      "S. N. Steinmann and C. Corminboeuf, J. Chem. Phys. 134 , 044117 (2011).",
      "S. N. Steinmann and C. Corminboeuf, J. Chem. Theory Comput. 7 , 3567 (2011).",
      "A. Tkatchenko and M. Scheffler, Phys. Rev. Lett. 102 , 073005 (2009).",
      "T. Bučko, S. Lebègue, J. Hafner, and J. G. Ángyán, J. Chem. Theory Comput. 9 , 4293 (2013)",
      "T. Bučko, S. Lebègue, J. G. Ángyán, and J. Hafner, J. Chem. Phys. 141 , 034114 (2014).",
      "A. Tkatchenko, R. A. DiStasio, Jr., R. Car, and M. Scheffler, Phys. Rev. Lett. 108 , 236402 (2012).",
      "A. Ambrosetti, A. M. Reilly, and R. A. DiStasio Jr., J. Chem. Phys. 140 , 018A508 (2014).",
      "T. Gould and T. Bučko, C6 Coefficients and Dipole Polarizabilities for All Atoms and Many Ions in Rows 1–6 of the Periodic Table , J. Chem. Theory Comput. 12 , 3603 (2016).",
      "T. Gould, S. Lebègue, J. G. Ángyán, and T. Bučko, A Fractionally Ionic Approach to Polarizability and van der Waals Many-Body Dispersion Calculations , J. Chem. Theory Comput. 12 , 5920 (2016).",
      "https://libmbd.github.io/",
      "https://github.com/libmbd/libmbd",
      "J. Hermann, M. Stöhr, S. Góger, S. Chaudhuri, B. Aradi, R. J. Maurer, and A. Tkatchenko, libMBD: A general-purpose package for scalable quantum many-body dispersion calculations , J. Chem. Phys. 159 , 174802 (2023)."
    ]
  },
  "IVDW_NL": {
    "default_value": "Default: IVDW_NL = 1 for a GGA | = 2 for a METAGGA",
    "description": "IVDW_NL allows to select the kernel of the nonlocal van der Waals part of a functional (available as of VASP.6.4.0).",
    "detailed_description": "IVDW_NL\n=1 corresponds to the kernel of Dion\net al.\n[1]\nand\nIVDW_NL\n=2 to the kernel rVV10\n[2]\n. Note that the kernel of Dion\net al.\ncontains one adjustable parameter (\nZAB_VDW\n), while the rVV10 kernel contains two such parameters (\nBPARAM\nand\nCPARAM\n).",
    "related_tags": [
      "GGA",
      "METAGGA",
      "LUSE_VDW",
      "ZAB_VDW",
      "BPARAM",
      "CPARAM",
      "Nonlocal vdW-DF functionals",
      "↑",
      "M. Dion, H. Rydberg, E. Schröder, D. C. Langreth, and B. I. Lundqvist, Phys. Rev. Lett. 92 , 246401 (2004).",
      "R. Sabatini, T. Gorni, and S. de Gironcoli, Phys. Rev. B 87 , 041108(R) (2013)."
    ]
  },
  "IWAVPR": {
    "default_value": "Default: IWAVPR = 12 if IBRION =0 (MD) and 11 (relaxation, on-the-fly machine learning MD) | = 0 else (static calculation)",
    "description": "IWAVPR determines how orbitals and/or charge densities are extrapolated from one ionic configuration to the next configuration.",
    "detailed_description": "For\nIWAVPR\n<10, the file\nTMPCAR\nis used to store old orbitals that\nare required for the prediction. This setting is depreciated, and not supported by the MPI version. \nThe recommended settings are\nIWAVPR\n>10. In this case, the prediction is\nperformed without an external file\nTMPCAR\n(i.e. all required arrays\nare stored in the main memory).\n\nThe following options are available for\nIWAVPR\n:\n\nIWAVPR\n=0 no extrapolation, usually not preferable for first-principles molecular dynamics simulations or relaxations of the ions into the groundstate.\nIWAVPR\n=1|11 Simple extrapolation of the charge density using atomic charge densities (eq. (9.8) in thesis G. Kresse). This switch is convenient for geometry optimizations (ionic relaxation and volume/cell shape with the conjugate gradient or Quasi-Newton methods, i.e.\nIBRION\n=1,2,3 etc.)\nIWAVPR\n=2|12 A second-order extrapolation for the orbitals and the charge density (eq. (9.9) in thesis G. Kresse) is performed. This results in superior performance for first-principles molecular-dynamics simulations. It might cause instabilities during on-the-fly learning, so the default is 11 in this case.\n\nIWAVPR\n=3|13 In this case a second-order extrapolation for the orbitals, and a simple extrapolation of the charge density using atomic charge densities is done. This is a mixture between\nIWAVPR\n=1 and 2, however, it is usually worse than\nIWAVPR\n=2.\n\nMind: We don't encourage this setting.",
    "related_tags": [
      "IBRION"
    ]
  },
  "I_CONSTRAINED_M": {
    "default_value": "I_CONSTRAINED_M = none",
    "description": "I_CONSTRAINED_M switches on the constrained local moments approach.",
    "detailed_description": "VASP offers the possibility to add a penalty contribution to the total energy expression (and consequently a penalty functional to the Hamiltonian) that drives the local magnetic moment (integral of the magnetization in a site centered sphere of radius\nRWIGS\n) into a direction given by the\nM_CONSTR\n-tag.\n\nI_CONSTRAINED_M\n=1: Constrain the\ndirection\nof the magnetic moments.\n\nThe total energy is given by\n\nE\n=\nE\n0\n+\n∑\nI\nλ\n[\nM\n→\nI\n−\nM\n^\nI\n0\n(\nM\n^\nI\n0\n⋅\nM\n→\nI\n)\n]\n2\n{\\displaystyle E=E_0+ \\sum_I\\lambda \\left[ \\vec{M}_I-\\hat{M}^0_I \\left( \\hat{M}^0_I \\cdot \\vec{M}_I\\right)\\right]^2}\n\nwhere\nE\n0\nis the usual DFT energy, and the second term on the right-hand-side represents the penalty. The sum is taken over all atomic sites\nI\n,\nM\n^\nI\n0\n{\\displaystyle \\hat{M}^0_I}\nis the desired direction (unit vector) of the magnetic moment at site\nI\n(as specified using\nM_CONSTR\n), and\nM\n→\nI\n{\\displaystyle \\vec{M}_I}\nis the integrated magnetic moment inside a sphere Ω\nI\n(the radius\nmust\nbe specified by means of\nRWIGS\n) around the position of atom\nI\n,\n\nM\n→\nI\n=\n∫\nΩ\nI\nm\n→\n(\nr\n)\nF\nI\n(\n|\nr\n|\n)\nd\nr\n{\\displaystyle \\vec{M}_I=\\int_{\\Omega_I} \\vec{m}(\\mathbf{r}) F_I(|\\mathbf{r}|) d\\mathbf{r}}\n\nwhere\nF\nI\n(|\nr\n|) is a function of norm 1 inside Ω\nI\n, that smoothly goes to zero towards the boundary of Ω\nI\n.\n\nThe penalty term in the total energy introduces an additional potential inside the aforementioned spheres centered at the atomic sites\nI\n, given by\n\nV\nI\n(\nr\n)\n=\n2\nλ\n[\nM\n→\nI\n−\nM\n^\nI\n0\n(\nM\n^\nI\n0\n⋅\nM\nI\n→\n)\n]\n⋅\nσ\n→\nF\nI\n(\n|\nr\n|\n)\n{\\displaystyle \nV_I (\\mathbf{r})=2\\lambda \\left[ \\vec{M}_I-\\hat{M}^0_I \\left( \\hat{M}^0_I \\cdot \\vec{M_I}\\right)\\right]\n\\cdot \\vec{\\sigma} F_I(|\\mathbf{r}|) \n}\n\nwhere\nσ\n→\n=\n(\nσ\nx\n,\nσ\ny\n,\nσ\nz\n)\n{\\displaystyle \\vec{\\sigma}=(\\sigma_x,\\sigma_y,\\sigma_z)}\nare the Pauli spin-matrices.\n\nI_CONSTRAINED_M\n=2: Constrain the\nsize and direction\nof the magnetic moments.\n\nThe total energy is given by\n\nE\n=\nE\n0\n+\n∑\nI\nλ\n(\nM\n→\nI\n−\nM\n→\nI\n0\n)\n2\n{\\displaystyle E=E_0+ \\sum_I\\lambda \\left( \\vec{M}_I-\\vec{M}^0_I \\right)^2}\n\nwhere\nM\n→\nI\n0\n{\\displaystyle \\vec{M}^0_I}\nis the desired magnetic moment at site\nI\n(as specified using\nM_CONSTR\n).\nThe additional potential that arises from the penalty contribution to the total energy is given by\nV\nI\n(\nr\n)\n=\n2\nλ\n(\nM\n→\nI\n−\nM\n→\nI\n0\n)\n⋅\nσ\n→\nF\nI\n(\n|\nr\n|\n)\n{\\displaystyle V_I (\\mathbf{r})=2\\lambda \\left( \\vec{M}_I-\\vec{M}^0_I \\right)\\cdot \\vec{\\sigma} F_I(|\\mathbf{r}|)}\n\nI_CONSTRAINED_M\n=4: Constrain the\ndirection and sign\nof the magnetic moments\n[1]\n, available since VASP.6.4.0.\n\nThe total energy is given by\n\nE\n=\nE\n0\n+\n∑\nI\nλ\n(\n|\nM\n→\nI\n|\n−\nM\n^\nI\n0\n⋅\nM\n→\nI\n)\n{\\displaystyle E=E_0+ \\sum_I\\lambda \\left( |\\vec{M}_I| - \\hat{M}^0_I \\cdot \\vec{M}_I\\right)}\n\nwhere\nM\n^\nI\n0\n{\\displaystyle \\hat{M}^0_I}\nis the desired magnetic moment at site\nI\n(as specified using\nM_CONSTR\n).\nThe additional potential that arises from the penalty contribution to the total energy is given by\nV\nI\n(\nr\n)\n=\nλ\n(\nM\n^\nI\n−\nM\n^\nI\n0\n)\n⋅\nσ\n→\nF\nI\n(\n|\nr\n|\n)\n{\\displaystyle V_I (\\mathbf{r})=\\lambda \\left( \\hat{M}_I-\\hat{M}^0_I \\right)\\cdot \\vec{\\sigma} F_I(|\\mathbf{r}|)}\nwhere\nM\n^\nI\n{\\displaystyle \\hat{M}_I}\ndenotes the unit vector in\nM\n→\nI\n{\\displaystyle \\vec{M}_I}\ndirection.\n\nThe weight λ, with which the penalty terms enter into the total energy expression and the Hamiltonian in the above is specified through the\nLAMBDA\ntag.\n\nAs is probably clear from the above, applying constraints by means of a penalty functional contributes to the total energy. This contribution, however, decreases with increasing\nLAMBDA\nand can in principle be made vanishingly small\n[1]\n. Increasing\nLAMBDA\nstepwise, from one run to another (slowly so the solution remains stable) one thus converges towards the DFT total energy for a given magnetic configuration.\n\nWhen one uses the constrained moment approach, additional information pertaining to the effect of the constraints is written into the\nOSZICAR\nfile:\n\nE_p =  0.36856E-07  lambda =  0.500E+02\n<lVp>=  0.30680E-02\n DBL = -0.30680E-02\n ion        MW_int                 M_int\n  1 -0.565  0.000  0.000   -0.770  0.000  0.000\n  2  0.565  0.000  0.000    0.770  0.000  0.000\n  3 -0.565  0.000  0.000   -0.770  0.000  0.000\n  4  0.565  0.000  0.000    0.770  0.000  0.000\nDAV:   8    -0.133293620177E+03    0.15284E-05   -0.29410E-08  4188   0.144E-03    0.119E-04\n\nE_p\nis the contribution to the total energy arising from the penalty functional. Under\nM_int\nVASP lists the integrated magnetic moment at each atomic site. The column labeled\nMW_int\nshows the result of the integration of magnetization density which has been smoothed towards the boundary of the sphere. It is actually the\nsmoothed integrated moment\nwhich enters in the penalty terms (the smoothing ensures that the total local potential remains continuous at the sphere boundary). One should look at the latter numbers to check whether enough of the magnetization density around each atomic site is contained within the integration sphere and increase\nRWIGS\naccordingly. What exactly constitutes \"enough\" in this context is hard to say. It is best to set\nRWIGS\nin such a manner that the integration spheres do not overlap and are otherwise as large as possible.\n\nDAV:   9    -0.133293621087E+03   -0.91037E-06   -0.18419E-08  4188   0.104E-03\n   1 F= -.13329362E+03 E0= -.13329362E+03  d E =0.000000E+00  mag=     0.0000     0.0000     0.0000\n\n E_p =  0.36600E-07  lambda =  0.500E+02\n ion             lambda*MW_perp\n  1  -0.67580E-03  -0.12424E-22  -0.88276E-23\n  2   0.67580E-03   0.14700E-22  -0.24744E-22\n  3  -0.67790E-03  -0.82481E-23  -0.19834E-22\n  4   0.67790E-03   0.15710E-23   0.34505E-22\n\nUnder\nlambda*MW_perp\nthe constraining \"magnetic field\" at each atomic site is listed. It shows which magnetic field is added to the DFT Hamiltonian to stabilize the magnetic configuration.",
    "related_tags": [
      "M_CONSTR",
      "LAMBDA",
      "RWIGS",
      "LNONCOLLINEAR"
    ]
  },
  "KBLOCK": {
    "default_value": "KBLOCK = NSW",
    "description": "After KBLOCK * NBLOCK ionic steps the averaged pair-correlation function and DOS are written to the files PCDAT and DOSCAR . More details can be found on the page describing the tag NBLOCK .",
    "detailed_description": "",
    "related_tags": [
      "NBLOCK",
      "PCDAT",
      "DOSCAR"
    ]
  },
  "KGAMMA": {
    "default_value": "KGAMMA = .TRUE.",
    "description": "Determines whether the k points (specified by the KSPACING tag ) include ( KGAMMA =.TRUE.) the Γ {\\displaystyle \\Gamma} point.",
    "detailed_description": "Important:\nIf a\nKPOINTS\nfile is present, VASP ignores the\nKGAMMA\ntag and the\nKSPACING\ntag.",
    "related_tags": [
      "KSPACING"
    ]
  },
  "KPAR": {
    "default_value": "KPAR = 1",
    "description": "KPAR determines the number of k -points that are to be treated in parallel (available as of VASP.5.3.2). Also, KPAR is used as parallelization tag for Laplace transformed MP2 calculations .",
    "detailed_description": "VASP currently offers parallelization and data distribution over bands and/or over plane wave coefficients (see\nNCORE\nand\nNPAR\n), and as of VASP.5.3.2, parallelization over\nk\n-points.\nTo obtain high efficiency on massively parallel systems or modern multi-core machines, it is strongly recommended to use all at the same time. Most algorithms work with any data distribution (except for the single band conjugated gradient, which is considered to be obsolete).\n\nThe set of\nk\n-points is distributed over\nKPAR\ngroups of compute cores, in a round-robin fashion.\nThis means that a group of\nN\n=(# of cores/\nKPAR\n) compute cores together work on an individual\nk\n-point (choose\nKPAR\nsuch that it is an integer divisor of the total number of cores).\nWithin this group of\nN\ncores that share the work on an individual\nk\n-point, the usual parallelism over bands and/or plane wave coefficients applies (as set by means of the\nNCORE\nand\nNPAR\ntags).\n\nNote\n: the data is not distributed additionally over\nk\n-points.\n\nNote\n:\nKPAR\nbecomes obsolete if\nLMP2LT\nor\nLSMP2LT\nare set and specifies the number of plane-waves treated in parallel, see\nhere\nfor more information.",
    "related_tags": [
      "NCORE",
      "NPAR",
      "LPLANE",
      "LSCALU",
      "NSIM",
      "LSCALAPACK",
      "LSCAAWARE",
      "LSMP2LT",
      "LMP2LT"
    ]
  },
  "KPOINTS_OPT_MODE": {
    "default_value": "KPOINTS_OPT_MODE = 1",
    "description": "Selects which diagonalization algorithm to use for the optional k-points driver",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nSometimes, the electronic Kohn-Sham orbitals are required on an alternative k-point mesh, for example via\nKPOINTS_OPT\nor\nKPOINTS_ELPH\n.\nIn this case, the tag\nKPOINTS_OPT_MODE\nselects which diagonalization algorithm should be used to obtain these eigenvalues.\n\nTag options\n\nKPOINTS_OPT_MODE\n= 0\nThe diagonalization of the Hamiltonian at the alternative k-points is skipped entirely\nKPOINTS_OPT_MODE\n= 1\nUses the\nBlocked-Davidson algorithm\n(same as\nALGO\n= Normal\n)\nKPOINTS_OPT_MODE\n= 2\nPerforms an exact diagonalization (same as\nALGO\n= Exact\n)",
    "related_tags": [
      "KPOINTS_OPT",
      "KPOINTS_ELPH",
      "ALGO"
    ]
  },
  "KPOINTS_OPT_NKBATCH": {
    "default_value": "KPOINTS_OPT_NKBATCH = Number of k-points in the irreducible Brillouin zone of the self-consistent calculation.",
    "description": "KPOINTS_OPT_NKBATCH determines the size of the batch of k-points for the KPOINTS_OPT driver.",
    "detailed_description": "When the\nKPOINTS_OPT\nis present an additional non-self-consistent calculation is performed after self-consistency is reached.\nThis one-shot calculation is done in batches of N k-points to reduce memory usage.\nIncreasing the size of the batch leads to faster calculation times but higher memory usage in the non-self-consistent calculation.",
    "related_tags": [
      "LKPOINTS_OPT",
      "KPOINTS_OPT",
      "PROCAR_OPT"
    ]
  },
  "KPOINT_BSE": {
    "default_value": "",
    "description": "KPOINT_BSE specifies the k-point index at which VASP calculates the dielectric matrix.",
    "detailed_description": "In the simplest form, one can specify\n\nKPOINT_BSE = index_of_k-point\n\nSelect the desired k point from the list of k points in the\nOUTCAR\nfile. Additionally, a shift by an arbitrary reciprocal lattice vector can be supplied by specifying three additional integer numbers:\n\nKPOINT_BSE = index_of_k-point  n1 n2 n3\n\nThis allows calculating the dielectric function at a k point outside of the first Brillouin zone corresponding to\n\nk\n+\nn\n1\nb\n1\n+\nn\n2\nb\n2\n+\nn\n3\nb\n3\n{\\displaystyle  \\bold{k} + n_{1} \\bold{b}_{1}+ n_{2} \\bold{b}_{2} + n_{3} \\bold{b}_{3} }\n\nwhere\nb\ni\n{\\displaystyle \\bold{b}_{i}}\nare the reciprocal-lattice vectors of the unit cell.\n\nWarning:\nWe strongly recommend using\nANTIRES\n=2 for the finite wavevector calculations. The Tamm-Dancoff approximation can lead to unphysical results for the dielectric function at a finite wavevector.",
    "related_tags": [
      "BSE calculations"
    ]
  },
  "KPUSE": {
    "default_value": "KPUSE = not set",
    "description": "KPUSE sets a list of k points that contribute to calculating the partial charge density .",
    "detailed_description": "IBAND\nselects a subset of\nk'\npoints for which the partial charge density is calculated when\nLPARD\n= .TRUE..\nPartial charge densities are written to the\nPARCHG\nfile, or one of its variants, depending on the setting of\nLSEPB\nand\nLSEPK\n.\n\nMind:\nAll\nk\npoint weights will be internally reset to 1 if\nKPUSE\nis specified. Thus results are usually only correct if the groundstate calculation and the partial charge post-processing is performed with\nISYM\n= -1.\n\nE.g. if\nKPUSE = 1 4 7\nthe charge density will be calculated for the three\nk\npoints 1, 4, and 7.",
    "related_tags": [
      "LPARD",
      "NBMOD",
      "EINT",
      "IBAND",
      "LSEPB",
      "LSEPK",
      "LPARDH5",
      "PARCHG",
      "vaspout.h5",
      "Band-decomposed charge densities"
    ]
  },
  "KSPACING": {
    "default_value": "KSPACING = 0.5",
    "description": "The tag KSPACING determines the number of k points if the KPOINTS file is not present.",
    "detailed_description": "KSPACING\nis the smallest allowed spacing between k points in units of\nÅ\n−\n1\n{\\displaystyle \\AA^{-1}}\n. The number of k points increases when the spacing is decreased.\nThe number of k points in the direction of the first, second and third reciprocal lattice vector is determined by\nN\ni\n=\nm\na\nx\n(\n1\n,\nc\ne\ni\nl\ni\nn\ng\n(\n|\nb\ni\n|\n2\nπ\n/\nK\nS\nP\nA\nC\nI\nN\nG\n)\n)\n{\\displaystyle  N_i= \\mathrm{max}(1, \\mathrm{ceiling}( | \\mathbf{b}_i| 2\\pi / \\mathrm{KSPACING} ))}\nwith\nc\ne\ni\nl\ni\nn\ng\n(\nx\n)\n{\\displaystyle \\mathrm{ceiling}( x )}\nbeing the ceiling function which returns the least integer that is equal or larger than\nx\n{\\displaystyle x}\n. In this equation,\nb\ni\n{\\displaystyle  \\mathbf{b}_i  }\nare the reciprocal lattice vectors\nb\ni\na\nj\n=\nδ\ni\nj\n{\\displaystyle  \\mathbf{b}_i \\mathbf{a}_j = \\delta_{ij} }\n.\nThe generated grid is centered at the\nΓ\n{\\displaystyle \\Gamma}\npoint if\nKGAMMA\n=True (default), i.e., includes the\nΓ\n{\\displaystyle \\Gamma}\npoint. For\nKGAMMA\n=False, the grid is shifted away from the\nΓ\n{\\displaystyle \\Gamma}\npoint as done for Monkhorst-Pack grids.\n\nMind:\nThis implementation is not entirely identical with the deprecated\nautomatic k-point generation\nused in the\nKPOINTS\nfile.\n\nIf the k points are generated using the\nautomatic mode\nin the\nKPOINTS\nfile,\nN\ni\n{\\displaystyle  N_i}\nis calculated as\nN\ni\n=\ni\nn\nt\n(\nm\na\nx\n(\n1\n,\nR\nk\n|\nb\ni\n|\n+\n0.5\n)\n)\n{\\displaystyle  N_i= \\mathrm{int}(\\mathrm{max}(1, R_k| \\mathbf{b}_i| + 0.5)) }\nwith\nR\nk\n=\n2\nπ\n/\nK\nS\nP\nA\nC\nI\nN\nG\n{\\displaystyle R_k=2\\pi/\\mathrm{KSPACING}}\nand rounding it to the nearest integer.  We recommend using the\nKSPACING\ntag in the\nINCAR\nfile \nand avoiding the automatic mode via the\nKPOINTS\nfile.",
    "related_tags": [
      "KGAMMA",
      "KPOINTS"
    ]
  },
  "LADDER": {
    "default_value": "LADDER = .NOT. LRPA",
    "description": "Controls whether the ladder diagrams are included in the BSE calculation. Note that the default for LRPA and therefore LADDER is somewhat convoluted; so better to always double-check the OUTCAR file whether VASP behaves as expected. Generally, VASP will select ladder diagrams whenever this seems reasonable. This is for instance the case for ALGO =\"BSE\" or \"TDHF\" calculations.",
    "detailed_description": "LADDER\nis used together with\nLHARTREE\n. If\nLADDER\n=\n.FALSE.\n, the ladder diagrams (i.e. the exchange terms related to\nW\n{\\displaystyle W}\nor the screened exchange) are not included.\nIf\nLHARTREE\n=\n.FALSE.\n, the Hartree diagrams or bubble diagrams are not included. The following table summarizes all possible combinations:\n\nLHARTREE\nLADDER\n.TRUE.\n.TRUE.\nfull BSE / TDHF\n.FALSE.\n.TRUE.\nonly excitonic effects (ladders)\n.TRUE.\n.FALSE.\nrandom phase approximation (rings = bubbles only)\n.FALSE.\n.FALSE.\nindependent particle picture\n\nThe last combination can be useful for sanity checks: the results must be identical to the results obtained using\nLOPTICS\n=\n.TRUE.\nin the preceding calculations. If this is not the case, it usually implies that the one-electron\nenergies have been updated in the\nWAVECAR\nfile, or that the\nWAVEDER\nfile is not properly set up. The end of\nBSE\nexplains how to recalculate\nthe\nWAVEDER\nfile from an existing\nWAVECAR\nfile.",
    "related_tags": [
      "LHARTREE",
      "LOPTICS",
      "BSE_calculations"
    ]
  },
  "LAECHG": {
    "default_value": "LAECHG = .FALSE.",
    "description": "when LAECHG =.TRUE. the all-electron charge density will be reconstructed explicitly and written to files.",
    "detailed_description": "If\nLAECHG\n=.TRUE. is set VASP will reconstruct the\nall-electron\ncharge density on the so-called \"fine\" FFT-grid.\nThis \"fine\" FFT-grid consists of\nNGXF\n×\nNGYF\n×\nNGZF\npoints in real space (\ni.e.\n, the grid that is used to represent the augmented pseudo charge densities of the USPP and PAW methods).\n\nIn fact, for\nLAECHG\n=.TRUE., VASP will reconstruct three distinct\nall-electron\ndensities:\n\nthe core density.\nthe proto-atomic valence density (overlapping atomic charge densities).\nthe self-consistent valence density.\n\nThese are written to the files\nAECCAR0\n,\nAECCAR1\n, and\nAECCAR2\n, respectively.\nThe first two of these files are written at the start of the run, whereas the last is written at the end after self-consistency has been reached.\n\nN.B.:\nIn the language of the\nPAW method\nan \"all-electron\" density does\nnot\nrefer to the\ndensity of all electrons\n, instead it denotes a density that includes all the nodal features near the nucleus associated with the\ntrue\n(as opposed to the\npseudized\n) one-electron orbitals.\nWithin the PAW method, the\nall-electron\ndensity arising from the one-electron pseudo orbitals\n{\nψ\n~\nn\nk\n}\n{\\displaystyle \\{ \\widetilde{\\psi}_{n\\mathbf{k}} \\}}\nis given by:\n\nn\n(\nr\n)\n=\n∑\nn\nk\nf\nn\nk\n⟨\nψ\n~\nn\nk\n|\nr\n⟩\n⟨\nr\n|\nψ\n~\nn\nk\n⟩\n+\n∑\nα\n,\nβ\n(\nϕ\nα\n∗\n(\nr\n)\nϕ\nβ\n(\nr\n)\n−\nϕ\n~\nα\n∗\n(\nr\n)\nϕ\n~\nβ\n(\nr\n)\n)\n∑\nn\nk\nf\nn\nk\n⟨\nψ\n~\nn\nk\n|\np\n~\nα\n⟩\n⟨\np\n~\nβ\n|\nψ\n~\nn\nk\n⟩\n{\\displaystyle \nn(\\mathbf{r})=\n\\sum_{n{\\mathbf{k}}} f_{n{\\mathbf{k}}}\n\\langle \\widetilde{\\psi}_{n\\mathbf{k}}| \\mathbf{r}\\rangle\\langle  \\mathbf{r}| \\widetilde{\\psi}_{n\\mathbf{k}} \\rangle +\n\\sum_{\\alpha, \\beta} \n(\n  \\phi^\\ast_\\alpha(\\mathbf{r})\n  \\phi_\\beta (\\mathbf{r})\n -\n  \\widetilde{\\phi}^\\ast_\\alpha(\\mathbf{r})\n  \\widetilde{\\phi}_\\beta (\\mathbf{r})\n)\n\\sum_{n{\\mathbf{k}}} f_{n{\\mathbf{k}}}\n\\langle\\widetilde{\\psi}_{n\\mathbf{k}}|\\widetilde{p}_\\alpha\\rangle\n\\langle\\widetilde{p}_\\beta| \\widetilde{\\psi}_{n\\mathbf{k}}\\rangle\n}\n\nNormally one does not attempt to reconstruct\nall-electron\ndensities explicitly since the second term on the right-hand side varies rapidly near the nuclei and is too costly to expand in-plane waves (see the bit about\naugmentation and compensation charges\n). For\nLAECHG\n=.TRUE., however, this reconstruction is exactly the thing that is done.",
    "related_tags": [
      "AECCAR0",
      "AECCAR1",
      "AECCAR2"
    ]
  },
  "LALL_IN_ONE": {
    "default_value": "Default: LALL_IN_ONE = .FALSE. for NBANDS >0 | = .TRUE. for NBANDS <0",
    "description": "LALL_IN_ONE =.TRUE. enables the all-in-one mode for many-body perturbation theory calculations, i.e., ALGO = ACFDT[R] , [EV]GW0[R] , GWR .",
    "detailed_description": "Mind:\navailable as of VASP.6.4.0\n\nIn the all-in-one mode, VASP automatically performs the necessary DFT steps prior to the many-body perturbation theory (MBPT) calculation, i.e. a DFT calculation with\nNBANDS\n, followed by an exact diagonalization of the Kohn-Sham Hamiltonian with\nNBANDSEXACT\nbands. \nNote,\nNBANDSEXACT\nis set by default to the maximum number of plane-waves given by the chosen energy cutoff for the orbitals\nENCUT\n. \nIn the all-in-one mode, the actual GW/RPA calculation is also performed with\nNBANDSEXACT\nbands. \nIf\nNBANDS_WAVE\nis not set, all orbitals are written to\nWAVECAR\n, which potentially becomes huge in file size.\n\nTip:\nThe\nNBANDS_WAVE\ntag can be used to limit the number of bands written to\nWAVECAR\nif\nLALL_IN_ONE\n=.TRUE.\n\nThe all-in-one mode is automatically enabled for\nALGO\n=[EV]GW[0]R, RPA[R],ACFDT[R] if\nNBANDS\nis not set.",
    "related_tags": [
      "ALGO",
      "NBANDS",
      "NBANDSEXACT",
      "NBANDS_WAVE",
      "IALL_IN_ONE"
    ]
  },
  "LAMBDA": {
    "default_value": "LAMBDA = 0",
    "description": "LAMBDA sets the weight with which the penalty terms of the constrained local moment approach enter into the total energy expression and the Hamiltonian.",
    "detailed_description": "See the explanation given in the description of the\nI_CONSTRAINED_M\ntag.",
    "related_tags": [
      "I_CONSTRAINED_M",
      "M_CONSTR",
      "RWIGS",
      "LNONCOLLINEAR"
    ]
  },
  "LANCZOSTHR": {
    "default_value": "LANCZOSTHR = 10 − 3 {\\displaystyle 10^{-3}}",
    "description": "LANCZOSTHR is used by the BSE Lanczos algorithm to stop the iterative procedure, once the dielectric function has reached numerical convergence.",
    "detailed_description": "The difference between the dielectric function at two consecutive iterations,\ni\n{\\displaystyle i}\nand\ni\n+\n1\n{\\displaystyle i+1}\n, is computed as root-mean-square over the frequency grid\n\nR\nM\nS\n[\nϵ\n]\n=\n∑\nj\n=\n1\nN\n1\nN\n[\nϵ\ni\n(\nω\nj\n)\n−\nϵ\ni\n+\n1\n(\nω\nj\n)\n]\n2\n{\\displaystyle \n\\mathrm{RMS}[\\epsilon] = \\sqrt{\\sum_{j=1}^N\\frac{1}{N}\\left[\\epsilon_{i}(\\omega_j)-\\epsilon_{i+1}(\\omega_j)\\right]^2}\n}\n\nand once\nR\nM\nS\n[\nϵ\n]\n<=\n{\\displaystyle \\mathrm{RMS}[\\epsilon]<=}\nLANCZOSTHR the iterative algorithm stops.\n\nRelated tag and articles\n\nBSE\n,\nBSE calculations\n,\nBethe-Salpeter equations",
    "related_tags": []
  },
  "LANGEVIN_GAMMA": {
    "default_value": "LANGEVIN_GAMMA = NTYP×0",
    "description": "LANGEVIN_GAMMA specifies the friction coefficients (in ps -1 ) for atomic degrees-of-freedom when using a Langevin thermostat (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "When using a\nLangevin thermostat\n[1]\n(\nMDALGO\n=3), the friction coefficients γ for the atomic degrees-of-freedom are specified (in ps\n-1\n) using the\nLANGEVIN_GAMMA\n-tag.\n\nOne has to specify a separate friction coefficient for each of the NTYP atomic species found on the\nPOTCAR\n-file.\n\nPractical example\n\nConsider a system consisting of 16 hydrogen and 48 silicon atoms. Suppose that eight silicon atoms are considered to be Langevin atoms and the remaining 32 Si atoms are either fixed or Newtonian atoms. The Langevin and Newtonian (or fixed) atoms should be considered as different species,\ni.e.\n, the\nPOSCAR\n-file should contain the line like this:\n\nSi H Si\n40 16 8\n\nAs only the final eight Si atoms are considered to be Langevin atoms, the\nINCAR\n-file should contain the following line defining the friction coefficients:\n\nLANGEVIN_GAMMA = 0.0   0.0   10.0\n\ni.e.\n, for all non-Langevin atoms, γ should be set to zero.",
    "related_tags": [
      "LANGEVIN_GAMMA_L",
      "MDALGO"
    ]
  },
  "LANGEVIN_GAMMA_L": {
    "default_value": "LANGEVIN_GAMMA_L = 0",
    "description": "LANGEVIN_GAMMA_L specifies the friction coefficient (in ps -1 ) for lattice degrees-of-freedom in case of Parrinello-Rahman dynamics (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "When running\nNpT\nsimulations with a\nLangevin thermostat\n[1]\n(\nMDALGO\n=3), using the method of\nParrinello and Rahman\n,\n[2]\n[3]\nthe friction coefficient for lattice degrees-of-freedom have to be specified (in ps\n-1\n) by means of the\nLANGEVIN_GAMMA_L\n-tag.\nA fictitious mass for the lattice degrees-of-freedom has to be assigned using the\nPMASS\ntag.\n\nThe friction coefficients γ for the atomic degrees-of-freedom are specified using the\nLANGEVIN_GAMMA\n-tag.",
    "related_tags": [
      "LANGEVIN_GAMMA",
      "PMASS",
      "MDALGO"
    ]
  },
  "LASPH": {
    "default_value": "LASPH = .FALSE.",
    "description": "include non-spherical contributions related to the gradient of the density in the PAW spheres.",
    "detailed_description": "Usually VASP calculates only the spherical contribution to the gradient corrections inside the PAW spheres (non-spherical contributions for the LDA part of the potential and the Hartree potential are always included).\n\nFor\nLASPH\n= .TRUE., non-spherical contributions from the gradient corrections inside the PAW spheres will be included as well. For VASP.4.6, these contributions are only included in the total energy, after self-consistency has been reached disregarding the aspherical contributions in the gradient corrections.\n\nFor VASP.5.X the aspherical contributions are properly accounted for in the Kohn-Sham potential as well, if\nLASPH\n= .TRUE. is set. This is essential for accurate total energies and band structure calculations for\nf\n-elements (e.g. ceria), all 3\nd\n-elements (transition metal oxides), and magnetic atoms in the 2nd row (B-F atom), in particular if DFT+U or hybrid functionals, meta-GGAs, or vdW-DFT are used, since these functionals often result in aspherical charge densities.",
    "related_tags": [
      "LMAXPAW",
      "LMAXTAU",
      "LMIXTAU"
    ]
  },
  "LASYNC": {
    "default_value": "LASYNC = .FALSE.",
    "description": "Controls the overlap in communication.",
    "detailed_description": "If\nLASYNC\n=\n.TRUE.\nis set in the INCAR file, VASP will try to overlap communication with calculations.\nThis might improve performance or degrade it depending on the MPI library and hardware you are running on.\nPlease do your own testing and compare the runtimes and results before using this tag in production runs.\nCompiling VASP using the\n-DPROFILING\nprecompiler switch provides a detailed timing of the different VASP routines which helps in determining if there is a performance gain.\nPlease report any issues in the\nVASP forum\n.\n\nExamples that use this tag",
    "related_tags": []
  },
  "LATTICE_CONSTRAINTS": {
    "default_value": "",
    "description": "Sets three boolean to selectively allow changes in the lattice vectors.",
    "detailed_description": "The lattice vectors\na\n1\n{\\displaystyle \\mathbf{a}_{1}}\n,\na\n2\n{\\displaystyle \\mathbf{a}_{2}}\n,\na\n3\n{\\displaystyle \\mathbf{a}_{3}}\ndefined in the\nPOSCAR\nfile can be represented by following matrix:\n\nA\n=\n[\na\n11\na\n12\na\n13\na\n21\na\n22\na\n23\na\n31\na\n32\na\n33\n]\n.\n{\\displaystyle \n   \\mathbf{A} = \n   \\begin{bmatrix}\n     a_{11} & a_{12} & a_{13} \\\\\n     a_{21} & a_{22} & a_{23} \\\\\n     a_{31} & a_{32} & a_{33}\n  \\end{bmatrix}.\n}\n\nLATTICE_CONSTRAINTS\nis used to constrain certain entries of this matrix during an MD run.\n\nOrthorhombic case\n\nFor orthorhombic unit cells\nA\n{\\displaystyle \\mathbf{A}}\nis of diagonal form:\n\nA\n=\n[\na\n11\n0\n0\n0\na\n22\n0\n0\n0\na\n33\n]\n,\n{\\displaystyle \n   \\mathbf{A} = \n   \\begin{bmatrix}\n     a_{11} & 0      & 0 \\\\\n      0     & a_{22} & 0 \\\\\n      0     & 0      & a_{33}\n  \\end{bmatrix},\n}\n\nTherefore by setting one of the entries of\nLATTICE_CONSTRAINTS\nto FALSE the lattice parameter in this direction will not be allowed to change.                                                     \nFor\nMD simulations\n(\nIBRION\n=0), we recommend using\nLATTICE_CONSTRAINTS\nfor (orthorhombic) liquids in the isobaric-isothermal (\nNpT\n) ensemble in the following way:\n\nLATTICE_CONSTRAINTS\n= .FALSE. .FALSE. .TRUE.\n\nHere, the first two lattice constants are not allowed to change. The third lattice constant needs to be free to allow volume changes for the barostat. The system is then like a piston. The constraints are necessary for liquids in\nNpT\nsimulations because if all lattice degrees of freedom are allowed to relax, irreversible deformations of the cell are very likely to happen. This can lead to undesirable results like a very flat supercell, which cannot be used to obtain valid MD trajectories.\n\nFor\nstructure relaxation\n(\nIBRION\n=1,2),\nLATTICE_CONSTRAINTS\nis useful to relax the lattice constants of 2D materials. In case of a slab in the\na\n1\n{\\displaystyle \\mathbf{a}_1}\n-\na\n2\n{\\displaystyle \\mathbf{a}_2}\nplane, add vacuum padding along\na\n3\n{\\displaystyle \\mathbf{a}_3}\nand set\n\nLATTICE_CONSTRAINTS\n= .TRUE. .TRUE. .FALSE.\n\nNon-orthorhombic case\n\nFor non-orthorhombic boxes\nLATTICE_CONSTRAINTS\nis more complicated to use. The tag will set certain rows and columns of the stress tensor\n\nσ\n=\n[\nx\nx\nx\ny\nx\nz\ny\nx\ny\ny\ny\nz\nz\nx\nz\ny\nz\nz\n]\n,\n{\\displaystyle \n   \\mathbf{\\sigma} = \n   \\begin{bmatrix}\n     xx & xy & xz \\\\\n     yx & yy & yz \\\\\n     zx & zy & zz\n  \\end{bmatrix},\n}\n\nto zero. By setting certain entries of the stress tensor to zero the corresponding entries of the lattice\nA\n{\\displaystyle \\mathbf{A}}\nwill not be updated.\nFor example when setting\nLATTICE_CONSTRAINTS\n= .FALSE. .TRUE. .TRUE. the used stress tensor will look like\n\nσ\n=\n[\n0\n0\n0\n0\ny\ny\ny\nz\n0\nz\ny\nz\nz\n]\n,\n{\\displaystyle \n   \\mathbf{\\sigma} = \n   \\begin{bmatrix}\n     0 & 0 & 0 \\\\\n     0 & yy & yz \\\\\n     0 & zy & zz\n  \\end{bmatrix},\n}\n\nand therefore the first row and the first column of the lattice\nA\n{\\displaystyle \\mathbf{A}}\nwill not change.\nAnother example would be to set\nLATTICE_CONSTRAINTS\n= .FALSE. .TRUE. .FALSE. resulting in the following\nstress tensor\n\nσ\n=\n[\n0\n0\n0\n0\ny\ny\n0\n0\n0\n0\n]\n{\\displaystyle \n   \\mathbf{\\sigma} = \n   \\begin{bmatrix}\n     0 & 0  & 0 \\\\\n     0 & yy & 0 \\\\\n     0 & 0  & 0\n  \\end{bmatrix}\n}\n\nSo only the\ny\ny\n{\\displaystyle yy}\n/\na\n22\n{\\displaystyle a_{22}}\nentry of the lattice\nA\n{\\displaystyle \\mathbf{A}}\nwill change.\n\nMind:\nNote that for non-orthorhombic boxes the angles between the lattice vectors\na\n1\n{\\displaystyle \\mathbf{a}_{1}}\n,\na\n2\n{\\displaystyle \\mathbf{a}_{2}}\n,\na\n3\n{\\displaystyle \\mathbf{a}_{3}}\nwill not be conserved.\n\nMind:\nLATTICE_CONSTRAINTS\nin combination with\nIBRION\n=1,2 is available from VASP 6.4.3.\n\nMind:\nLATTICE_CONSTRAINTS\nin combination with\nISIF\n=4,5 is available from VASP 6.5.1.\n\nWarning:\nBe aware of a bug in versions < 6.5.0 as described in following forum post\n[1]\n.",
    "related_tags": [
      "IBRION",
      "MDALGO",
      "Interface pinning"
    ]
  },
  "LBERRY": {
    "default_value": "LBERRY = .FALSE.",
    "description": "This tag is used in the the evaluation of the Berry phase expression for the electronic polarization of an insulating system.",
    "detailed_description": "As of VASP.5.2, calculating the macroscopic polarization and Born effective charges along the lines of the following example (using\nLBERRY\n=\n.TRUE.\netc) is unnecessary. The use of\nLCALCPOL\nor\nLCALCEPS\nis much more convenient.\n\nSetting\nLBERRY\n=\n.TRUE.\nin the\nINCAR\nfile switches on the evaluation of the Berry phase expression for the electronic polarization of an insulating system, as modified for the application of USPP's and PAW datasets\n[1]\n[2]\n[3]\n[4]\n[5]\n[6]\n[7]\n.\nIn addition, the following keywords must be specified in order to generate the mesh of k-points:\n\nIGPAR = 1|2|3\n\nIGPAR\ntag specifies the socalled parallel or\nG\n∥\n{\\displaystyle \\bold{G}_{\\parallel}}\ndirection in the integration over the reciprocal space unit cell.\n\nNPPSTR = number of points on the strings in the IGPAR direction\n\nNPPSTR\nspecifies the number of k-points on the strings\nk\nj\n=\nk\n⊥\n+\nj\nG\n∥\n/\nN\nP\nP\nS\nT\nR\n{\\displaystyle \\bold{k}_{j} = \\bold{k}_{\\perp} + j\\bold{G}_{\\parallel}/\\mathrm{NPPSTR} }\n(with\nj\n=\n0\n,\n.\n.\n,\nN\nP\nP\nS\nT\nR\n−\n1\n{\\displaystyle  j=0,..,\\mathrm{NPPSTR}-1}\n).\n\nDIPOL = center of cell (fractional coordinates)\n\nDIPOL\nspecifies the origin with respect to which the ionic contribution to the dipole moment in the cell is calculated. When comparing changes in this contribution due to the displacement of an ion, this center should be chosen in such a way that the ions in the distorted and the undistorted structure remain on the same side of\nDIPOL\n(in terms of a minimum image convention).\n\nAn example: The fluorine displacement dipole (Born effective charge) in NaF\n\nFirst one needs to determine the electronic polarization of the undistorted NaF.\n\nCaluclation1:\nIt is usually convenient to calculate the self-consistent Kohn-Sham potential of the undistorted structure, using a symmetry reduced\n6\n×\n6\n×\n6\n{\\displaystyle 6\\times6\\times6}\nMonkhorst-Pack sampling of the Brillouin zone. Using for instance the following\nINCAR\nfile:\n\nPREC   = Med\nISMEAR = 0\nEDIFF  = 1E-6\n\nKPOINTS\nfile:\n\n6x6x6\n 0\nGamma\n 6 6 6\n 0 0 0\n\nPOSCAR\nfile:\n\nNaF\n 4.5102\n 0.0 0.5 0.5\n 0.5 0.0 0.5\n 0.5 0.5 0.0\n1 1\nDirect\n  0.0000000000000000  0.0000000000000000  0.0000000000000000\n  0.5000000000000000  0.5000000000000000  0.5000000000000000\n\nand LDA Na_sv and F PAW datasets.\n\nCalculation 2:\nTo calculate the electronic contribution to the polarization, along the reciprocal lattice vector\nG\n1\n{\\displaystyle \\bold{G}_{1}}\n(i.e.\nP\n⋅\nG\n1\n{\\displaystyle  \\bold{P} \\cdot \\bold{G}_{1} }\n), add the following lines to the\nINCAR\nfile:\n\nLBERRY = .TRUE.\nIGPAR  = 1\nNPPSTR = 8\nDIPOL = 0.25 0.25 0.25\n\nSetting\nLBERRY\n=\n.TRUE.\nautomatically sets\nICHARG\n=11, i.e., the charge density of the previous calculation is read and kept fixed, and only the orbitals and one-electron eigenenergies are recalculated for the new k-point set. This is advantageous, since the number of k-points used to evaluate the Berry phase expression can be quite large, and precalculating the charge density (\nICHARG\n=11) saves significant CPU time.\n\nThe\nOUTCAR\nwill now contain the following lines:\n\ne<r>_ev=(     0.00000     0.00000     0.00000 ) e*Angst\n                                e<r>_bp=(     0.00000     0.00000     0.00000 ) e*Angst\n\nTotal electronic dipole moment: p[elc]=(     0.00000     0.00000     0.00000 ) e*Angst\n\nionic dipole moment: p[ion]=(     2.25510     2.25510     2.25510 ) e*Angst\n\nCalculations 3 and 4:\nThe procedure mentioned under Calculation 2 now has to be repeated with\nIGPAR\n=2 and\nIGPAR\n=3 (again using the charge density obtained from Calculation 1), to obtain the contributions to the electronic polarization along\nG\n2\n{\\displaystyle \\bold{G}_2}\nand\nG\n3\n{\\displaystyle \\bold{G}_{3}}\n, respectively.\n\nCalculations 5 to 8:\nTo calculate the change in the electronic polarization of NaF due to the displacement of the fluorine sublattice, one should repeat Calculations 1 to 4, using the following\nPOSCAR\nfile:\n\nNaF\n 4.5102\n 0.0 0.5 0.5\n 0.5 0.0 0.5\n 0.5 0.5 0.0\n1 1\nDirect\n  0.0000000000000000  0.0000000000000000  0.0000000000000000\n  0.5100000000000000  0.5100000000000000  0.4900000000000000\n\nThis corresponds to a displacement of the F ion by\n0.01\n×\n4.51\nÅ\n{\\displaystyle 0.01\\times 4.51\\AA}\nalong the\nz\n^\n{\\displaystyle \\hat{z}}\ndirection. The output of the Berry phase calculation using\nIGPAR\n=1 should now look similar to:\n\ne<r>_ev=(     0.00000     0.00000     0.00004 ) e*Angst\n                                e<r>_bp=(     0.00000     0.18028     0.18028 ) e*Angst \n\n Total electronic dipole moment: p[elc]=(     0.00000     0.18028     0.18031 ) e*Angst\n\nionic dipole moment: p[ion]=(     2.25510     2.25510     1.93939 ) e*Angst\n\nCollecting the results:\nThe change in the electronic contribution to the polarization due to the F-sublattice displacement should be calculated as follows:\n\nTake the average of the\ne\n<\nr\n>\ne\nv\n{\\displaystyle e<\\mathrm{r}>_\\mathrm{ev}}\nterms obtained in calculations 2 to 4. Lets call this\ne\n<\nr\n>\ne\nv\n,\nu\nn\nd\ni\ns\nt\n{\\displaystyle e<\\mathrm{r}>_{\\mathrm{ev,undist}}}\n\nAdd the\ne\n<\nr\n>\nb\np\n{\\displaystyle e<\\mathrm{r}>_{\\mathrm{bp}} }\nterms obtained in calculations 2 to 4. Lets call this\ne\n<\nr\n>\nb\np\n,\nu\nn\nd\ni\ns\nt\n{\\displaystyle e<\\mathrm{r}>_{\\mathrm{bp,undist}}}\n\nThe electronic polarization of the undistorted structure is then given by:\n\ne\n<\nr\n>\ne\nl\n,\nu\nn\nd\ni\ns\nt\n=\ne\n<\nr\n>\ne\nv\n,\nu\nn\nd\ni\ns\nt\n+\ne\n<\nr\n>\nb\np\n,\nu\nn\nd\ni\ns\nt\n{\\displaystyle  e<\\mathrm{r}>_{\\mathrm{el,undist}}=e<\\mathrm{r}>_{\\mathrm{ev,undist}}+e<\\mathrm{r}>_{\\mathrm{bp,undist}} }\n\nRepeat the above three steps for the results obtained using the distorted structure (Calculations 6 to 8), to evaluate\ne\n<\nr\n>\ne\nv\n,\nd\ni\ns\nt\n{\\displaystyle e<\\mathrm{r}>_{\\mathrm{ev,dist}}}\n,\ne\n<\nr\n>\nb\np\n,\nd\ni\ns\nt\n{\\displaystyle e<\\mathrm{r}>_{\\mathrm{bp,dist}}}\n, and\ne\n<\nr\n>\ne\nl\n,\nd\ni\ns\nt\n{\\displaystyle e<\\mathrm{r}>_{\\mathrm{el,dist}}}\n\nThe change in the electronic contribution to the polarization due to the F-sublattice displacement,\ne\nΔ\n<\nr\n>\ne\nl\n{\\displaystyle e\\Delta<\\mathrm{r}>_\\mathrm{el}}\nis then given by\ne\n<\nr\n>\ne\nl\n,\nd\ni\ns\nt\n−\ne\n<\nr\n>\ne\nl\n,\nu\nn\nd\ni\ns\nt\n{\\displaystyle e<\\mathrm{r}>_{\\mathrm{el,dist}}-e<\\mathrm{r}>_{\\mathrm{el,undist}}}\n\nTo calculate the total change in polarization,\ne\nΔ\n<\nr\n>\n{\\displaystyle e\\Delta<\\mathrm{r}> }\n, one should account for the ionic contribution to this change. This contribution can be calculated from p[ion] as given above from\nCalculations 2 and 5:\nΔ\np\n[\ni\no\nn\n]\n=\np\n[\ni\no\nn\n]\nd\ni\ns\nt\n−\np\n[\ni\no\nn\n]\nu\nn\nd\ni\ns\nt\n{\\displaystyle  \\Delta\\mathrm{p[ion]}=\\mathrm{p[ion]}_{\\mathrm{dist}}-\\mathrm{p[ion]}_{\\mathrm{undist}} }\n.\n\ne\nΔ\n<\nr\n>\n{\\displaystyle  e\\Delta<\\mathrm{r}> }\nis then given by\nΔ\np\n[\ni\no\nn\n]\n+\ne\nΔ\n<\nr\n>\ne\nl\n{\\displaystyle  \\Delta \\mathrm{p[ion]}+e\\Delta<\\mathrm{r}>_\\mathrm{el} }\n. In this example we find\ne\nΔ\n<\nr\n>=\n0.04489\n{\\displaystyle  e\\Delta<\\mathrm{r}>=0.04489}\nelectrons\nÅ\n{\\displaystyle \\AA}\n. Considering that the moved F-sublattice was displaced by 0.045102\nÅ\n{\\displaystyle \\AA }\n, this calculation yields a Born effective charge for fluorine in NaF of\nZ\n∗\n=\n−\n0.995\n{\\displaystyle Z^{*}=-0.995 }\n.\n\nN.B.(I) In the case of spinpolarized calculations (\nISPIN\n=2),the Berry phase of the orbitals is evaluated separately for each spin direction. This means a\ngrep\non \"\n<\nr\n>\n{\\displaystyle <\\mathrm{r}> }\n\" will yield two sets of\n<\nr\n>\ne\nv\n{\\displaystyle  <\\mathrm{r}>_{\\mathrm{ev}} }\nand\n<\nr\n>\nb\np\n{\\displaystyle  <\\mathrm{r}>_{\\mathrm{bp}}}\nterms, which have to be added to oneanother to obtain the total electronic polarization of the system.\n\nN.B.(II) One should take care of the fact that the calculated \"Berry phase\" term\n<\nr\n>\nb\np\n{\\displaystyle  <\\mathrm{r}>_{\\mathrm{bp}}}\nalong\nG\ni\n{\\displaystyle \\mathbf{G}_{i}}\nis, in principle, obtained modulo a certain period, determined by the lattice vector\nR\ni\n{\\displaystyle  \\mathbf{R}_{i} }\n(\nR\ni\n⋅\nG\ni\n=\n2\nπ\n{\\displaystyle \\mathbf{R}_{i} \\cdot \\mathbf{G}_{i} = 2 \\pi }\n), the spin multiplicity of the orbitals, the volume of the unit cell, the number of k-point in the \"perpendicular\" grid, and some aspects of the symmetry of the system. More information on this particular aspect of the Berry phase calculations can be found in references\n[1]\n[2]\n[3]\n[4]\n[5]\n[7]\n.",
    "related_tags": [
      "IGPAR",
      "DIPOL",
      "NPPSTR",
      "LCALCPOL",
      "LCALCEPS",
      "ICHARG",
      "ISPIN"
    ]
  },
  "LBLUEOUT": {
    "default_value": "LBLUEOUT = .FALSE.",
    "description": "for LBLUEOUT =.TRUE., VASP writes output for the free-energy gradient calculation to the REPORT file (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "If LBLUEOUT=.TRUE., the information needed to compute the free-energy gradient is written in the\nREPORT\nfile after each molecular-dynamics step (\nMDALGO\n=1 | 2), check the lines after the header:\n\n>Blue_moon\n       lambda         |z|^(-1/2)      GkT           |z|^(-1/2)*(lambda+GkT)\n\nFor the theory of the blue-moon ensemble we refer to\nhere\n.",
    "related_tags": [
      "IBRION",
      "MDALGO",
      "ICONST",
      "Blue-moon ensemble",
      "Slow-growth approach"
    ]
  },
  "LBONE": {
    "default_value": "LBONE = .FALSE.",
    "description": "LBONE adds the small B -component to the chemical shift tensor.",
    "detailed_description": "LBONE\nrestores the small\nB\n-component of the wave function inside\nthe PAW spheres in the linear-response calculation of the NMR chemical shift\ntensor. The POTCARs used in VASP are scalar-relativistic and the\nAE-partial waves are solutions of the scalar-relativistic Kohn-Sham\nequation for the spherical atom. These have a large (\nA\n) and a small (\nB\n) component.\nThe latter is not retained on the POTCAR, but approximately restored when\nLBONE\n=.TRUE.\n[1]\n.\nLBONE\nonly affects the one-center valence contributions to the chemical shift. The contribution of the core electrons includes the\nB\n-component by default.\n\nRelated tags and articless\n\nLCHIMAG\n\nReferences\n\n↑\nG. A. de Wijs, R. Laskowski, P. Blaha, R. W. A. Havenith, G. Kresse, and M. Marsman,\nNMR shieldings from density functional perturbation theory: GIPAW versus all-electron calculations\n, J. Chem. Phys.\n146\n, 064115 (2017).",
    "related_tags": []
  },
  "LCALCEPS": {
    "default_value": "LCALCEPS = .FALSE.",
    "description": "for LCALCEPS =.TRUE. the macroscopic ion-clamped static dielectric tensor, Born effective charge tensors, and the ion-clamped piezoelectric tensor of the system are determined from the response to finite electric fields.",
    "detailed_description": "For\nLCALCEPS\n=.TRUE., VASP calculates the ion-clamped static dielectric tensor\n\nϵ\ni\nj\n∞\n=\nδ\ni\nj\n+\n4\nπ\nϵ\n0\n∂\nP\ni\n∂\nE\nj\n,\ni\n,\nj\n=\nx\n,\ny\n,\nz\n{\\displaystyle \n\\epsilon^\\infty_{ij}=\\delta_{ij}+\n\\frac{4\\pi}{\\epsilon_0}\\frac{\\partial P_i}{\\partial \\mathcal{E}_j},\n\\qquad\n{i,j=x,y,z}\n}\n\nthe Born effective charge tensors\n\nZ\ni\nj\n∗\n=\nΩ\ne\n∂\nP\ni\n∂\nu\nj\n=\n1\ne\n∂\nF\nj\n∂\nE\ni\n,\ni\n,\nj\n=\nx\n,\ny\n,\nz\n{\\displaystyle \nZ^*_{ij}=\\frac{\\Omega}{e}\\frac{\\partial P_i}{\\partial u_j}\n        =\\frac{1}{e}\\frac{\\partial F_j}{\\partial \\mathcal{E}_i},\n\\qquad\n{i,j=x,y,z}\n}\n\nand the ion-clamped piezoelectric tensor of the system\n\ne\ni\nj\n(\n0\n)\n=\n−\n∂\nσ\ni\n∂\nE\nj\n,\ni\n=\nx\nx\n,\ny\ny\n,\nz\nz\n,\nx\ny\n,\ny\nz\n,\nz\nx\nj\n=\nx\n,\ny\n,\nz\n{\\displaystyle \ne^{(0)}_{ij}=-\\frac{\\partial \\sigma_i}{\\partial \\mathcal{E}_j},\n\\qquad\n{i=xx, yy, zz, xy, yz, zx}\\quad{j=x,y,z}\n}\n\nfrom the\nself-consistent response to a finite electric field\nε\n.\nIn this case, the \"response\" of the system is the change in the polarization\nP\n, the Hellmann-Feynman forces\nF\n, and the stress tensor σ. Mind the\ndefinition/sign convention of the stress tensor\n.\n\nIf this is combined with\nIBRION\n=6, the contribution from the ionic relaxations to the piezoelectric and dielectric tensors are calculated as well.\n\nTo this end VASP will perform essentially three successive calculations, with:\n\nEFIELD_PEAD\n=\nε\nx\n0 0\n\nEFIELD_PEAD\n= 0\nε\ny\n0\n\nEFIELD_PEAD\n= 0 0\nε\nz\n\nwhere, by default, VASP chooses\nε\nx\n=\nε\ny\n=\nε\nz\n=0.01 eV/Å.\n\nThis default may be overwritten by specifying\n\nEFIELD_PEAD\n=\nε\nx\nε\ny\nε\nz\n\nin the\nINCAR\nfile.\n\nThe relevant output is found in the\nOUTCAR\nfile, immediately following the lines (see the description of\nLEPSILON\n=.TRUE. as well):\n\nMACROSCOPIC STATIC DIELECTRIC TENSOR (including local field effects)\n\nBORN EFFECTIVE CHARGES (including local field effects)\n\nPIEZOELECTRIC TENSOR (including local field effects)\n\nIn the above, \"including local field effects\" pertains to the fact that changes in the orbitals due to the electric field induce changes in the Hartree- and exchange-correlation potential. One may choose to limit this to changes in the Hartree potential alone, by specifying:\n\nLRPA\n=.TRUE.\n\nThis is commonly referred to as the response within the \"Random Phase Approximation\" (RPA), or the \"neglect of local field effects\". The OUTCAR file will now contain additional sections, headed by the lines:\n\nMACROSCOPIC STATIC DIELECTRIC TENSOR (excluding local field effects)\n\nBORN EFFECTIVE CHARGES (excluding local field effects)\n\nPIEZOELECTRIC TENSOR (excluding local field effects)\n\nNote\n: For standard DFT functionals, ε\n∞\n,\nZ\n*\n, and\ne\n(0)\nmay be more easily calculated from density functional perturbation theory (see\nLEPSILON\n=.TRUE.). For functionals that depend not only on the density but also explicitly on the orbitals, like\nhybrid functionals\n, density functional perturbation theory is presently not implemented and\nLEPSILON\n=.TRUE. is not applicable.\n\nNote\n: The piezoelectric tensor has the wrong sign in Vasp 5.4.4 and older. The bug is fixed with\npatch.5.4.4.16052018.gz\n.",
    "related_tags": [
      "LEPSILON",
      "LCALCPOL",
      "EFIELD_PEAD",
      "LPEAD",
      "IPEAD",
      "LBERRY",
      "IGPAR",
      "NPPSTR",
      "DIPOL",
      "IBRION",
      "Berry phases and finite electric fields"
    ]
  },
  "LCALCPOL": {
    "default_value": "LCALCPOL = .FALSE.",
    "description": "LCALCPOL =.TRUE. switches on the evaluation of the Berry phase expressions for the macroscopic electronic polarization in accordance with the so-called Modern Theory of Polarization .",
    "detailed_description": "For\nLCALCPOL\n=.TRUE., VASP calculates the electronic contribution to the polarization, along the three reciprocal lattice vectors\nG\ni\n, i=1,2,3,  (i.e. Σ\ni\nP\n·\nG\ni\n) in a single run (unlike\nLBERRY\n=.TRUE.).\n\nAn example: The fluorine displacement dipole (Born effective charge) in NaF\n\nWith\nINCAR\nfile:\n\nPREC\n= Med\nEDIFF\n= 1E-6\nISMEAR\n= 0\nDIPOL\n= 0.25 0.25 0.25\nLCALCPOL\n= .TRUE.\n\nKPOINTS\nfile:\n\n6x6x6\n 0\nGamma\n 6 6 6\n 0 0 0\n\nPOSCAR\nfile:\n\nNaF\n 4.5102\n 0.0 0.5 0.5\n 0.5 0.0 0.5\n 0.5 0.5 0.0\n1 1\nDirect\n  0.0000000000000000  0.0000000000000000  0.0000000000000000\n  0.5000000000000000  0.5000000000000000  0.5000000000000000\n\nand LDA Na_sv and F PAW datasets.\n\nThe\nOUTCAR\nfile should now contain the following lines:\n\nIonic dipole moment: p[ion]=(     2.25510     2.25510     2.25510 ) electrons Angst\n\n Total electronic dipole moment: p[elc]=(     0.00000     0.00000     0.00000 ) electrons Angst\n\nHere the units \"electrons Angst\" denote\ne\nÅ\n=\n−\n1.602\n10\n−\n19\nC\nÅ\n{\\displaystyle e\\AA=-1.602 10^{-19}C\\AA}\n.\n\nTo calculate the change in the electronic polarization of NaF due to the displacement of the fluorine sublattice we repeat the previous calculation with the following\nPOSCAR\nfile:\n\nNaF\n 4.5102\n 0.0 0.5 0.5\n 0.5 0.0 0.5\n 0.5 0.5 0.0\n1 1\nDirect\n  0.0000000000000000  0.0000000000000000  0.0000000000000000\n  0.5100000000000000  0.5100000000000000  0.4900000000000000\n\nThe\nOUTCAR\nshould now contain something very similar to the following lines:\n\nIonic dipole moment: p[ion]=(     2.25510     2.25510     1.93939 ) electrons Angst\n\n Total electronic dipole moment: p[elc]=(     0.00000     0.00000     0.36061 ) electrons Angst\n\nFrom the above one easily recognizes that the change in the electronic dipole moment due to the F-sublattice displacement is:\n\nΔ\np\n[\ne\nl\nc\n]\n=\n0.3606\nz\n^\ne\nÅ\n{\\displaystyle \\Delta\\mathrm{p[elc]}=0.3606\\hat{z}\\;e\\AA}\n\nand the corresponding change in the ionic dipole moment:\n\nΔ\np\n[\ni\no\nn\n]\n=\n1.93939\n−\n2.25510\n=\n−\n0.31571\nz\n^\ne\nÅ\n{\\displaystyle \\Delta\\mathrm{p[ion]}=1.93939-2.25510=-0.31571\\hat{z}\\;e\\AA}\n\nThus the total change is found to be:\n\nΔ\np\n[\nt\no\nt\n]\n=\n0.36061\n−\n0.31571\n=\n0.0449\nz\n^\ne\nÅ\n{\\displaystyle \\Delta\\mathrm{p[tot]}=0.36061-0.31571=0.0449\\hat{z}\\;e\\AA}\n\nand considering that the F-sublattice was displaced by 0.045102 Å these calculations yield a Born effective charge for fluorine of\n\nZ\n∗\n=\n0.0449\n/\n0.045102\n=\n−\n0.995\n|\ne\n|\n{\\displaystyle Z^*=0.0449/0.045102=-0.995|e|\\;}\n.\n\nThe socalled parallel or\nG\n∥\n{\\displaystyle \\bold{G}_{\\parallel}}\ndirection in the integration over the reciprocal space unit cell is set in\nIGPAR\n.",
    "related_tags": [
      "LCALCEPS",
      "EFIELD_PEAD",
      "LPEAD",
      "IPEAD",
      "LBERRY",
      "IGPAR",
      "NPPSTR",
      "DIPOL",
      "Berry phases and finite electric fields"
    ]
  },
  "LCHARG": {
    "default_value": "LCHARG = .NOT. LH5",
    "description": "LCHARG determines whether the charge densities (files CHGCAR and CHG ) are written.",
    "detailed_description": "",
    "related_tags": [
      "LWAVE",
      "LWAVEH5",
      "LCHARGH5",
      "LH5"
    ]
  },
  "LCHARGH5": {
    "default_value": "LCHARGH5 = LH5",
    "description": "LCHARGH5 determines whether the charge densities are written to vaspwave.h5 .",
    "detailed_description": "",
    "related_tags": [
      "LWAVE",
      "LWAVEH5",
      "LCHARG",
      "LH5"
    ]
  },
  "LCHIMAG": {
    "default_value": "LCHIMAG = .FALSE.",
    "description": "Calculate the chemical shifts and magnetic susceptibility within linear response theory.",
    "detailed_description": "For\nLCHIMAG\n= True\n, the chemical shift tensors and magnetic susceptibility is computed. The implementation\n[1]\nis based on linear response theory using the gauge-invariant PAW method of Yates, Pickard, and Mauri\n[2]\n[3]\n, that is an extension to the standard\nPAW method\nto account for the effects of a vector gauge field\nA\n{\\displaystyle A}\n. The NMR response currents are computed and the induced B field is calculated based on the Biot-Savart law.\n\nFollow these guides for\ncalculating the chemical shieldings\nand\ncalculating the magnetic susceptibility\n.\n\nDefinitions\n\nThe chemical shielding tensor is defined as:\n\nσ\ni\nj\n(\nR\n)\n=\n−\n∂\nB\ni\ni\nn\n(\nR\n)\n∂\nB\nj\ne\nx\nt\n{\\displaystyle \n\\sigma_{ij}(\\mathbf{R}) = - \\frac{ \\partial B^{\\mathrm{in}}_i(\\mathbf{R})}{ \\partial B^{\\mathrm{ext}}_j}\n}\n\nHere\nR\n{\\displaystyle \\mathbf{R}}\ndenotes the atomic nuclear site,\ni\n{\\displaystyle i}\nand\nj\n{\\displaystyle j}\ndenote Cartesian indices,\nB\ne\nx\nt\n{\\displaystyle \\mathbf{B}^{\\mathrm{ext}}}\nan applied DC external magnetic field and\nB\ni\nn\n(\nR\n)\n{\\displaystyle \\mathbf{B}^{\\mathrm{in}}(\\mathbf{R})}\nthe induced magnetic field at the nucleus.\n\nNMR experiments yield information on the shielding relative to a reference compound:\n\nδ\ni\nj\n(\nR\n)\n=\nσ\ni\nj\nr\ne\nf\n−\nσ\ni\nj\n(\nR\n)\n{\\displaystyle \n\\delta_{ij}(\\mathbf{R}) = \\sigma_{ij}^{\\mathrm{ref}} - \\sigma_{ij}(\\mathbf{R})\n}\n\nHere,\nσ\ni\nj\nr\ne\nf\n{\\displaystyle \\sigma_{ij}^{\\mathrm{ref}}}\nis the isotropic shielding of the nucleus in the reference compound.\nδ\ni\nj\n(\nR\n)\n{\\displaystyle \\delta_{ij}(\\mathbf{R})}\nis the chemical shift tensor. In order to compare numerical results with the experimental data, one usually considers a series of compounds and references them to the experimental series.\n\nVASP calculates chemical \"shifts\" for non-metallic crystalline systems using the linear response method of Yates, Pickard, and Mauri\n[2]\n[3]\n.\n\nThe isotropic chemical \"shift\"\nσ\ni\ns\no\n{\\displaystyle \\sigma_{iso}}\n, span\nΩ\n{\\displaystyle \\Omega}\n, and skew\nκ\n{\\displaystyle \\kappa}\nare also reported, according to the following  Herzfeld-Berger convention\n[4]\n:\n\nσ\ni\ns\no\n=\n(\nσ\n11\n+\nσ\n22\n+\nσ\n33\n)\n/\n3\n{\\displaystyle \n\\sigma_{iso} = (\\sigma_{11} + \\sigma_{22} + \\sigma_{33})/3\n}\n\nΩ\n=\nσ\n33\n−\nσ\n11\n{\\displaystyle \n\\Omega = \\sigma_{33} - \\sigma_{11}\n}\n\nκ\n=\n3\n(\nσ\ni\ns\no\n−\nσ\n22\n)\n/\nΩ\n.\n{\\displaystyle \n\\kappa = 3(\\sigma_{iso} - \\sigma_{22})/\\Omega.\n}\n\nThe orbital magnetic susceptibility\nχ\n{\\displaystyle \\chi}\nis calculated according to a finite-differences approach:\n\nχ\nbare\n=\nlim\nq\n→\n0\nF\n(\nq\n)\n2\nF\n(\nq\n)\n+\nF\n(\n−\nq\n)\nq\n2\n{\\displaystyle \n\\chi_{\\textrm{bare}} = \\lim_{q\\to0} \\frac{F(q) 2F(q) + F(-q)}{q^2}\n}\n\nwhere\nF\ni\nj\n(\nq\n)\n=\n(\n2\n−\nδ\ni\nj\n)\nQ\ni\nj\n(\nq\n)\n{\\displaystyle F_{ij}(q)=(2-\\delta_{ij})Q_{ij}(q)}\n.\n\nQ\nij\nis approximated in two ways. The so-called\npGv\n-approximation is used by default\n[3]\n, where\np\nis momentum,\nv\nis velocity, and\nG\nis a Green's function. An alternative approach, the\nvGv\n-approximation is also used to calculate an alternative susceptibility since VASP 6.4.0\n[5]\n.\nQ\nis defined for the\npGv\n-approximation as:\n\nQ\n(\nq\n)\n=\n−\n1\nc\n2\nN\nk\nV\nc\n∑\ni\n=\nx\n,\ny\n,\nz\n∑\no\n,\nk\nRe\n[\n⟨\nu\n¯\no\n,\nk\n(\n0\n)\n|\nu\n^\ni\n×\n(\n−\ni\n∇\n+\nk\n)\n×\nG\nk\n+\nq\ni\n(\nϵ\no\n,\nk\n)\nu\n^\ni\n×\nv\nk\n+\nq\ni\n,\nk\n(\nϵ\no\n,\nk\n)\n|\nu\n¯\no\n,\nk\n(\n0\n)\n⟩\n]\n{\\displaystyle \nQ(q) = - \\frac{1}{c^2 N_k V_c} \\sum_{i=x,y,z} \\sum_{o,\\textbf{k}} \\textrm{Re}[\\langle \\bar{u}^{(0)}_{o,\\textbf{k}} | \\hat{\\textbf{u}}_i \\times (-i \\nabla + \\textbf{k})  \\times \\mathcal{G}_{\\textbf{k} + \\textbf{q}_i}(\\epsilon_{o,\\textbf{k}}) \\hat{\\textbf{u}}_i \\times \\textbf{v}_{\\textbf{k} + \\textbf{q}_i, \\textbf{k}}(\\epsilon_{o,\\textbf{k}}) | \\bar{u}^{(0)}_{o,\\textbf{k}} \\rangle]\n}\n\nand for the\nvGv\n-approximation as:\n\nQ\n(\nq\n)\n=\n−\n1\nc\n2\nN\nk\nV\nc\n∑\ni\n=\nx\n,\ny\n,\nz\n∑\no\n,\nk\nRe\n[\n⟨\nu\n¯\no\n,\nk\n(\n0\n)\n|\nu\n^\ni\n×\nv\nk\n+\nq\ni\n,\nk\n(\nϵ\no\n,\nk\n)\n×\nG\nk\n+\nq\ni\n(\nϵ\no\n,\nk\n)\nu\n^\ni\n×\nv\nk\n+\nq\ni\n,\nk\n(\nϵ\no\n,\nk\n)\n|\nu\n¯\no\n,\nk\n(\n0\n)\n⟩\n]\n{\\displaystyle \nQ(q) = - \\frac{1}{c^2 N_k V_c} \\sum_{i=x,y,z} \\sum_{o,\\textbf{k}} \\textrm{Re}[\\langle \\bar{u}^{(0)}_{o,\\textbf{k}} | \\hat{\\textbf{u}}_i \\times \\textbf{v}_{\\textbf{k} + \\textbf{q}_i, \\textbf{k}}(\\epsilon_{o,\\textbf{k}})  \\times \\mathcal{G}_{\\textbf{k} + \\textbf{q}_i}(\\epsilon_{o,\\textbf{k}}) \\hat{\\textbf{u}}_i \\times \\textbf{v}_{\\textbf{k} + \\textbf{q}_i, \\textbf{k}}(\\epsilon_{o,\\textbf{k}}) | \\bar{u}^{(0)}_{o,\\textbf{k}} \\rangle]\n}\n.\n\nOutput\n\nThe isotropic chemical shieldings are printed towards the end of the\nOUTCAR\nfile, after the self-consistent calculation has finished. The chemical shift tensors both before and after space group symmetrization. These are the absolute tensors for the infinite lattice, excluding core contributions. They can be searched for under the\nUNSYMMETRIZED TENSORS\nand\nSYMMETRIZED TENSORS\nafter\nAbsolute Chemical Shift tensors\n. Additionally, the magnetic susceptibility is printed shortly after and found under\nORBITAL MAGNETIC SUSCEPTIBILITY\n.\n\nMagnetic susceptibility\n\nThe magnetic susceptibility is found at the start of the\nORBITAL MAGNETIC SUSCEPTIBILITY, excluding core contribution\n. The magnetic susceptibility is split into that obtained by the\npGv\n-approximation and obtained by the\nvGv\n-approximation:\n\n-------------------------------------------------------------\n  ORBITAL MAGNETIC SUSCEPTIBILITY, excluding core contribution\n -------------------------------------------------------------\n  Approximate magnetic susceptibility, pGv (10^-6 cm^3/mole)\n     1        -70.928534         -0.000000          0.000000\n     2         -0.000000        -70.928534          0.000000\n     3          0.000000          0.000000        -70.928534\n -------------------------------------------------------------\n  Approximate magnetic susceptibility, vGv (10^-6 cm^3/mole)\n     1        -63.412095         -0.000000          0.000000\n     2         -0.000000        -63.412095          0.000000\n     3          0.000000          0.000000        -63.412095\n\n         principal value                      axis\n       (10^-6 cm^3/mole)           x,          y,          z\n      --------------------------------------------------------\n              -63.412095      0.1652     -0.9863      0.0000\n              -63.412095     -0.9863     -0.1652      0.0000\n              -63.412095      0.0000      0.0000      1.0000\n -------------------------------------------------------------\n\nChemical shielding\n\nTo obtain the full absolute tensors requires adding both the\nG\n=\n0\n{\\displaystyle \\mathbf{G=0}}\ncontribution (cf.\nG=0 CONTRIBUTION TO CHEMICAL SHIFT\n) and the contributions due to the core electrons. The latter consists of contributions for each chemical species separately (depending on\nPOTCAR\n) and a global\nG\n=\n0\n{\\displaystyle \\mathbf{G=0}}\nsusceptibility contribution.\n\nThe reference shift experienced by the core is given first:\n\nCore NMR properties\n\n  typ  El   Core shift (ppm)\n ----------------------------\n    1  C     -200.5098801\n ----------------------------\n\n  Core contribution to magnetic susceptibility:     -0.31  10^-6 cm^3/mole\n --------------------------------------------------------------------------\n\nImportant:\nThe isotropic chemical shift\nδ\ni\ns\no\n[\nV\nA\nS\nP\n]\n{\\displaystyle \\delta_{\\mathrm{iso}}\\mathrm{[VASP]}}\n(ISO_SHIFT) is the negative of the isotropic shielding. To make it a\nreal shift\none should add the reference shielding.\n\nNext, the tensor is processed and its chemical shielding anisotropy (CSA) characteristics are printed in the\nOUTCAR\n. The tensor is symmetrized (\nσ\ni\nj\n=\nσ\nj\ni\n{\\displaystyle \\sigma_{ij} = \\sigma_{ji}}\nis enforced) and diagonalized. From the three diagonal values the isotropic chemical \"shift\"\nδ\ni\ns\no\n[\nV\nA\nS\nP\n]\n{\\displaystyle \\delta_{\\mathrm{iso}}\\mathrm{[VASP]}}\n, span\nΩ\n{\\displaystyle \\Omega}\n, and skew\nκ\n{\\displaystyle \\kappa}\nare calculated and printed see Ref.\n[4]\nfor unambiguous definitions. Note that\nκ\n{\\displaystyle \\kappa}\nis ill-defined if\nΩ\n=\n0\n{\\displaystyle \\Omega = 0}\n. Units are ppm, except for the skew. A typical output is given below:\n\n---------------------------------------------------------------------------------\n    CSA tensor (J. Mason, Solid State Nucl. Magn. Reson. 2, 285 (1993))\n   ---------------------------------------------------------------------------------\n               EXCLUDING G=0 CONTRIBUTION             INCLUDING G=0 CONTRIBUTION\n           -----------------------------------   -----------------------------------\n    ATOM    ISO_SHIFT        SPAN        SKEW     ISO_SHIFT        SPAN        SKEW\n   ---------------------------------------------------------------------------------\n    (absolute, valence only)\n       1    4598.8125      0.0000      0.0000     4589.9696      0.0000      0.0000\n       2     291.5486      0.0000      0.0000      282.7058      0.0000      0.0000\n       3     736.5979    344.8803      1.0000      727.7550    344.8803      1.0000\n       4     736.5979    344.8803      1.0000      727.7550    344.8803      1.0000\n       5     736.5979    344.8803      1.0000      727.7550    344.8803      1.0000\n   ---------------------------------------------------------------------------------\n    (absolute, valence and core)\n       1   -6536.1417      0.0000      0.0000    -6547.9848      0.0000      0.0000\n       2   -5706.3864      0.0000      0.0000    -5718.2296      0.0000      0.0000\n       3   -2369.4015    344.8803      1.0000    -2381.2446    344.8803      1.0000\n       4   -2369.4015    344.8803      1.0000    -2381.2446    344.8803      1.0000\n       5   -2369.4015    344.8803      1.0000    -2381.2446    344.8803      1.0000\n   ---------------------------------------------------------------------------------\n    IF SPAN.EQ.0, THEN SKEW IS ILL-DEFINED\n   ---------------------------------------------------------------------------------\n\nThe isotropic chemical shielding for each atom, excluding and including G=0 contributions, as well as the span and skew (descriptions of asymmetry), follow. Finally, core contributions are taken into account for the\nISO_SHIFT\n,\nSPAN\n, and\nSKEW\n.\n\nImportant:\nThe columns excluding the\nG\n=\n0\n{\\displaystyle \\mathbf{G=0}}\ncontribution are useful for supercell calculations on molecules.\nThe columns including the\nG\n=\n0\n{\\displaystyle \\mathbf{G=0}}\ncontribution are for crystals.\nThe upper block gives the shielding due to only the electrons included in the SCF calculation.\nThe lower block has the contributions due to the frozen PAW cores added. These core contributions are rigid\n[6]\n. They depend on\nPOTCAR\nand are isotropic, i.e. affect neither SPAN nor SKEW.",
    "related_tags": [
      "DQ",
      "ICHIBARE",
      "LNMR_SYM_RED",
      "NLSPLINE",
      "LLRAUG",
      "LBONE",
      "LVGVCALC",
      "LVGVAPPL",
      "NUCIND",
      "Calculating the chemical shieldings",
      "Calculating the magnetic susceptibility"
    ]
  },
  "LCOARSEN": {
    "default_value": "KERNEL_TRUNCATION/LCOARSEN = .True.",
    "description": "KERNEL_TRUNCATION/LCOARSEN speeds up computation of the local potential in the kernel truncation method by coarsening the charge density before padding it",
    "detailed_description": "Kernel truncation methods pad the computational cell with vacuum.\nThis padded cell is expensive to compute due to FFTs being performed on a larger grid.\nThe\nKERNEL_TRUNCATION/LCOARSEN\nmethod selectively replaces the long range potential with the truncated potential instead of computing the entire potential on a padded grid.\nThis selective replacement of the potential bypasses the need for padding, speeding up the computation of the kernel truncation methods.\n\nMind:\nIF\nKERNEL_TRUNCATION/LTRUNCATE\nis switched off, all other KERNEL_TRUNCATION tags, i.e.\nKERNEL_TRUNCATION/IDIMENSIONALITY\n,\nKERNEL_TRUNCATION/LCOARSEN\n, and\nKERNEL_TRUNCATION/ISURFACE\nwill be ignored.",
    "related_tags": [
      "KERNEL_TRUNCATION/LTRUNCATE",
      "KERNEL_TRUNCATION/IDIMENSIONALITY",
      "KERNEL_TRUNCATION/ISURFACE"
    ]
  },
  "LCORR": {
    "default_value": "LCORR = .TRUE.",
    "description": "Controls whether Harris corrections are calculated or not.",
    "detailed_description": "Based on the ideas of the\nHarris-Foulkes functional\nit is possible to derive a correction to the forces for non fully self-consistent calculations, we call these corrections Harris corrections. For\nLCORR\n=\n.TRUE.\nthese corrections are calculated and included in the stress-tensor and the forces. The contributions are explicitly written to the file\nOUTCAR\nand help to show how well forces and stress are converged. For surfaces, the correction term might be relatively large and testing has shown that the corrected forces converge much faster to the exact forces than uncorrected forces.",
    "related_tags": [
      "Harris-Foulkes functional"
    ]
  },
  "LDAU": {
    "default_value": "LDAU = .FALSE.",
    "description": "LDAU =.TRUE. switches on DFT+U.",
    "detailed_description": "LDAU\nis the main control tag to switch on DFT+U. Check\nLDAUTYPE\nfor an overview of the available methods. A typical setup in the INCAR file may include\n\nLDAU\n= .TRUE.\nLDAUTYPE\n= 2\nLDAUL\n= 2 -1      # l quantum number where U is added for each atom; -1 is no U added\nLDAUU\n= 7.00 0.00 # on-site Coulomb interaction (in eV) for each atom\nLDAUJ\n= 1.00 0.00 # on-site exchange interaction (in eV) for each atom\nLMAXMIX\n= 4\n\nNote on band-structure calculation\n: The\nCHGCAR\nfile contains only information up to angular momentum quantum number\nl\n{\\displaystyle l}\n=\nLMAXMIX\nfor the\non-site PAW occupancy matrices\n. When the\nCHGCAR\nfile is read and kept fixed in the course of the calculations (\nICHARG\n=11), the results will necessarily be not identical to a self-consistent run. The deviations are often large for DFT+U calculations. For the calculation of band structures within the DFT+U approach, it is hence strictly required to increase\nLMAXMIX\nto 4 (\nd\n{\\displaystyle d}\nelements) and 6 (\nf\n{\\displaystyle f}\nelements).",
    "related_tags": [
      "LDAUTYPE",
      "LDAUL",
      "LDAUU",
      "LDAUJ",
      "LDAUPRINT",
      "LMAXMIX"
    ]
  },
  "LDAUJ": {
    "default_value": "LDAUJ = NTYP*0.0",
    "description": "Sets the effective on-site exchange interactions (eV).",
    "detailed_description": "LDAUJ\nspecifies the strength of the effective on-site exchange interactions in eV. It must hold one value for each atomic species.\n\nWarning:\nThe total energy will depend on the parameters\nU\n{\\displaystyle U}\n(\nLDAUU\n) and\nJ\n{\\displaystyle J}\n(\nLDAUJ\n). It is, therefore, not meaningful to compare the total energies resulting from calculations with different\nU\n{\\displaystyle U}\nand/or\nJ\n{\\displaystyle J}\n; or\nU\n−\nJ\n{\\displaystyle U-J}\nin the case of Dudarev's approach (\nLDAUTYPE\n=2).\n\nMind:\nFor\nLDAUTYPE\n=3, the\nLDAUU\nand\nLDAUJ\ntags specify the strength (in eV) of the spherical potential acting on the spin-up and spin-down manifolds, respectively.",
    "related_tags": [
      "LDAU",
      "LDAUTYPE",
      "LDAUL",
      "LDAUU",
      "LDAUPRINT",
      "LMAXMIX"
    ]
  },
  "LDAUL": {
    "default_value": "LDAUL = NTYP*2",
    "description": "LDAUL specifies the l {\\displaystyle l} -quantum number for which the on-site interaction is added.",
    "detailed_description": "For\nLDAUL\n=-1 no on-site interaction is added.\n\nMind\n: one\nhas\nto specify one number for each atomic species.",
    "related_tags": [
      "LDAU",
      "LDAUTYPE",
      "LDAUU",
      "LDAUJ",
      "LDAUPRINT",
      "LMAXMIX"
    ]
  },
  "LDAUPRINT": {
    "default_value": "LDAUPRINT = 0",
    "description": "LDAUPRINT controls the verbosity of a DFT+U calculation.",
    "detailed_description": "LDAUPRINT\n=0: No onsite occupancy matrix is written to the\nOUTCAR\nfile.\nLDAUPRINT\n=1: The spin up and spin down onsite occupancy matrices of the atoms types to which a\nU\n{\\displaystyle U}\nis applied are written to the\nOUTCAR\nfile at each iteration (below \"onsite density matrix\"). The eigenvalues and eigenvectors of the total (spin up + spin down) onsite matrix is also written (below \"occupancies and eigenvectors\").",
    "related_tags": [
      "LDAU",
      "LDAUTYPE",
      "LDAUL",
      "LDAUU",
      "LDAUJ",
      "LMAXMIX"
    ]
  },
  "LDAUTYPE": {
    "default_value": "LDAUTYPE = 2",
    "description": "LDAUTYPE specifies the DFT+U variant that will be used.",
    "detailed_description": "The following variants of the\nDFT+U\nare available:\n\nLDAUTYPE\n=1: The rotationally invariant DFT+U introduced by Liechtenstein\net al.\n[1]\n\nLDAUTYPE\n=2: The simplified (rotationally invariant) approach to DFT+U, introduced by Dudarev\net al.\n[2]\n\nLDAUTYPE\n=3: Linear response ansatz of Cococcioni et al.\n[3]\nto compute U. See\nhow to calculate U\n.\n\nMind:\nFor\nLDAUTYPE\n=3, the\nLDAUU\nand\nLDAUJ\ntags specify the strength of the spherical potential acting on the spin-up and spin-down manifolds, respectively.\n\nLDAUTYPE\n=4: Same as\nLDAUTYPE\n=1, but without exchange splitting.\n\nA method to estimate the parameters for DFT+U is the\nconstrained-random-phase approximation\n. Another method is the linear response ansatz with\nLDAUTYPE\n=3, mentioned above. On the other hand, in many applications, the DFT+U parameters are used as tuning parameters to fit experimental data.\n\nTip:\nFor band-structure calculations, increase\nLMAXMIX\nto 4 (\nd\n{\\displaystyle d}\nelements) or 6 (\nf\n{\\displaystyle f}\nelements).\n\nThis is because the\nCHGCAR\nfile contains only information up to angular momentum quantum number set by\nLMAXMIX\nfor the\non-site PAW occupancy matrices\n. When the\nCHGCAR\nfile is read and kept fixed in the course of the calculations (\nICHARG\n=11), the results will necessarily not be identical to a self-consistent run. The deviations are often large for DFT+U calculations.\n\nWarning:\nThe total energy will depend on the parameters\nU\n{\\displaystyle U}\n(\nLDAUU\n) and\nJ\n{\\displaystyle J}\n(\nLDAUJ\n). It is, therefore, not meaningful to compare the total energies resulting from calculations with different\nU\n{\\displaystyle U}\nand/or\nJ\n{\\displaystyle J}\n; or\nU\n−\nJ\n{\\displaystyle U-J}\nin the case of Dudarev's approach (\nLDAUTYPE\n=2).\n\nIt is possible to use\nLDAUTYPE\n=1, 2, and 3 for a non–spin-polarized calculation with\nISPIN\n=1.",
    "related_tags": [
      "LDAU",
      "LDAUL",
      "LDAUU",
      "LDAUJ",
      "LDAUPRINT",
      "LMAXMIX"
    ]
  },
  "LDAUU": {
    "default_value": "LDAUU = NTYP*0.0",
    "description": "Sets the effective on-site Coulomb interactions (eV).",
    "detailed_description": "LDAUU\nspecifies the strength of the effective on-site Coulomb interactions in eV. It must hold one value for each atomic species.\n\nWarning:\nThe total energy will depend on the parameters\nU\n{\\displaystyle U}\n(\nLDAUU\n) and\nJ\n{\\displaystyle J}\n(\nLDAUJ\n). It is, therefore, not meaningful to compare the total energies resulting from calculations with different\nU\n{\\displaystyle U}\nand/or\nJ\n{\\displaystyle J}\n; or\nU\n−\nJ\n{\\displaystyle U-J}\nin the case of Dudarev's approach (\nLDAUTYPE\n=2).\n\nMind:\nFor\nLDAUTYPE\n=3, the\nLDAUU\nand\nLDAUJ\ntags specify the strength (in eV) of the spherical potential acting on the spin-up and spin-down manifolds, respectively.",
    "related_tags": [
      "LDAU",
      "LDAUTYPE",
      "LDAUL",
      "LDAUJ",
      "LDAUPRINT",
      "LMAXMIX"
    ]
  },
  "LDIAG": {
    "default_value": "LDIAG = .TRUE.",
    "description": "Determines whether a subspace diagonalization is performed within the algorithm selected by ALGO or IALGO .",
    "detailed_description": "For\nALGO\n=\nNormal\n,\nFast\n, and\nVeryFast\n, VASP performs a diagonalization in the subspace spanned by all orbitals. This is often referred to as the\nRayleigh–Ritz method\n. \nThis step increases the convergence rate and thus is expedient in most cases.\nFurthermore, the subspace diagonalization sorts the orbital/eigenvalues in ascending order.\n\nFor the direct optimization algorithms (for instance\nALGO\n=\nAll\nor\nDamped\n),\na subspace diagonalization is usually not performed, but in order to improve the accuracy of the calculated forces,\nafter convergence has been reached one single diagonalization in the subspace spanned by all orbitals is performed.\n\nFor\nALGO\n=\nVeryFast\nand\nDamped\nit is possible to switch off the subspace diagonalization by specifying\nLDIAG\n=\n.FALSE.\nin the\nINCAR\nfile.\nSpecifically, for\nALGO\n=\nVeryFast\n,\nLDIAG\n=\n.FALSE.\nchanges from an exact Rayleigh–Ritz diagonalization to Loewdin perturbation theory.\n\nNote, Loewdin perturbation theory strictly conserves the orbital order,\ni.e.\n, the\nn\n-th orbital will remain stored in the\nn\n-th storage slot and only small rotations into that orbital can occur.\nFor\nALGO\n=\nDamped\nand\nAll\n, the final subspace diagonalization is simply skipped if\nLDIAG\n=\n.FALSE.\nis set.\nGenerally using\nLDIAG\n=\n.FALSE.\nis only advised, if one wants to maintain a certain orbital order, for instance, when reading the orbitals from an existing\nWAVECAR\nfile.\n\nFor the algorithms\nALGO\n=\nNormal\nor\nFast\n, by construction it is not possible to switch off subspace diagonalization, as these algorithms require subspace diagonalizations during the iterative refinement of the orbitals.\nFurthermore, algorithms that minimize the total energy (\nALGO\n=\nAll\n) are often too \"greedy\" and tend to alternate the orbital order in the course of the SCF cycle and energy optimization.\n\nIn summary, the following combinations are potentially useful:\n\nALGO = VeryFast ; LDIAG = .FALSE.\n\nALGO = Damped ; LDIAG = .FALSE.\n\nOther combinations using\nLDIAG\n=\n.FALSE.\nare likely to yield undesirable results.\n\nWarning:\nALGO\n=\nVeryFast\nis not supported for hybrid functionals.",
    "related_tags": [
      "IALGO",
      "ALGO"
    ]
  },
  "LDIPOL": {
    "default_value": "LDIPOL = .FALSE.",
    "description": "LDIPOL switches on corrections to the potential and forces. Can be applied for charged molecules and slabs with a net dipole moment.",
    "detailed_description": "The presence of a dipole in combination with periodic boundary conditions leads to a slow convergence of the total energy with the size of the supercell.\nFurthermore, finite-size errors affect the potential and the forces.\nThis effect can be counterbalanced by setting\nLDIPOL\n=.TRUE. in the\nINCAR\nfile. \nFor\nLDIPOL\n=.TRUE., a linear correction, and for charged cells, a quadratic electrostatic potential is added to the local potential in order to correct the errors introduced by the periodic boundary conditions. When activating this tag the tag\nIDIPOL\nhas to be specified, and optionally the tag\nDIPOL\nas well.\n\nMind:\nThis is in the spirit of Neugebauer\net al.\n[1]\n, though more general. Note that the total energy is correctly implemented, whereas Ref.\n[1]\ncontains an erroneous factor 2 in the total energy.\n\nThe biggest advantage of this mode is that leading errors in the forces are corrected and that the work function can be evaluated for asymmetric slabs. The disadvantage is that the convergence to the electronic ground state might slow down considerably, i.e., more electronic iterations might be required to obtain the required precision.\n\nWarning:\nFor charged systems, the potential correction is currently only implemented for cubic supercells. VASP will stop if the supercell is not cubic and\nLDIPOL\nis used.",
    "related_tags": [
      "Monopole Dipole and Quadrupole corrections",
      "NELECT",
      "EPSILON",
      "IDIPOL",
      "DIPOL",
      "LMONO",
      "EFIELD"
    ]
  },
  "LDISENTANGLED": {
    "default_value": "LDISENTANGLED = .FALSE.",
    "description": "Selects the disentangled cRPA method .",
    "detailed_description": "Selects the cRPA method of Miyake, Aryasetiawan, and Imada\n[1]\n. Following screening is subtracted from the full RPA polarizability:\n\nχ\n~\nG\n,\nG\n′\nσ\n(\nq\n,\ni\nω\n)\n=\n1\nN\nk\n∑\nk\n∑\nn\nn\n′\n∈\nT\nf\nn\nk\n−\nf\nn\n′\nk\n−\nq\nϵ\n~\nn\nk\n−\nϵ\n~\nn\n′\nk\n−\nq\n−\ni\nω\n⟨\nu\n~\nn\nk\nσ\n|\ne\n−\ni\n(\nG\n+\nq\n)\nr\n|\nu\n~\nn\n′\nk\n−\nq\nσ\n′\n⟩\n⟨\nu\n~\nn\n′\nk\n−\nq\nσ\n′\n|\ne\n−\ni\n(\nG\n′\n−\nq\n)\nr\n′\n|\nu\n~\nn\nk\nσ\n⟩\n{\\displaystyle \\tilde  \\chi^\\sigma_{{\\bf G,G}'}({\\bf q},i\\omega)=\n\\frac 1{N_k}\\sum_{\\bf k}\\sum_{nn'\\in{\\cal T}} \n\\frac{\nf_{n\\bf k}-f_{n'\\bf k-q}\n}{\n\\tilde\\epsilon_{n{\\bf k}} -  \\tilde\\epsilon_{n'\\bf k-q} - i \\omega \n}\n\\langle\n\\tilde u_{n {\\bf k  }}^{\\sigma  } \n|e^{-i \\bf (G+q) r}| \n\\tilde u_{n'{\\bf k-q}}^{ \\sigma' }\n\\rangle\n\\langle\n\\tilde u_{n' {\\bf k-q}}^{\\sigma' }\n|e^{-i \\bf (G'-q)r'} |\n\\tilde u_{n{\\bf k  }}^{ \\sigma  }\n\\rangle\n}\n,\n\nwhere\nϵ\n~\nn\nk\nσ\n{\\displaystyle \\tilde \\epsilon_{n\\bf k}^\\sigma}\nis the disentangled band structure.",
    "related_tags": [
      "LWEIGHTED",
      "LSCRPA",
      "ALGO"
    ]
  },
  "LDMATRIX": {
    "default_value": "LDMATRIX = .FALSE.",
    "description": "Computes the zero-field splitting (ZFS) matrix.",
    "detailed_description": "To compute the zero-field-splitting (ZFS) tensor due to spin-spin interactions in a collinear magnetic calculation (\nISPIN\n= 2\n), set:\n\nLDMATRIX\n= True\n # sets default\nLHFCALC\n= True ;\nAEXX\n=0.0\n\nThe ZFS arises from spin-spin interactions between unpaired electrons in a high-spin state with a total spin\nS\n≥\n1\n{\\displaystyle  S \\geq 1 }\n. The ZFS matrix, also called D matrix, is measured in electron-spin resonance (ESR) experiments and provides insights into the local electronic environment of defect centers.\n\nThe implementation follows the formalism of Rayson and Briddon (2008)\n[1]\n, which efficiently evaluates the spin-spin interaction within periodic density-functional theory (DFT) using reciprocal space methods. This approach avoids expensive six-dimensional real-space integrations, leading to a stable and computationally efficient method. The expressions are similar to integrals used to evaluate the exact exchange energies for\nhybrid and HF-type calculation\n, hence VASP sets\nLHFCALC\n= True\n. This still allows for simple DFT calculations (\nAEXX\n= 0.0\ndefault), however mind that the default symmetrization is\nISYM\n= 3\n.\nLDMATRIX\nshould not be combined with\nISYM\n= 1\n, or\n2\n.\n\nOutput\n\nThe computed zero-field splitting is written in MHz to the stdout:\n\nJij:    -0.0003356     0.0003475    -0.0000119   965.1231107   965.1238969   965.1238508\n-Kij:    -0.0002748    -0.0000059     0.0002807    64.8471208    64.8472015    64.8471523\n D1c:    -0.0000541     0.0000275     0.0000267    11.1897131    11.1897125    11.1897272\n\nand the\nOUTCAR\nfile:\n\nSpin-spin contribution to zero-field splitting tensor (MHz)\n---------------------------------------------------------------\n     D_xx      D_yy      D_zz      D_xy      D_xz      D_yz \n---------------------------------------------------------------\n     0.001     0.000    -0.001  1042.316  1020.260  1041.130\n---------------------------------------------------------------\n\nafter diagonalization\n---------------------------------------------\n    D_diag          eigenvector (x,y,z)\n---------------------------------------------\n -1020.244      -0.697    -0.019     0.717\n -1048.926      -0.427     0.814    -0.393\n  2069.171      -0.576    -0.580    -0.576\n---------------------------------------------\n\nAdvice\n\nChoice of PAW potentials\n: The ZFS tensor values can be sensitive to the specific\nPAW potential\nused, as different\npseudopotentials\ninclude varying number of electrons in the valence. In particular, it is crucial that the states that give rise to the magnetic moment are included.\nNUPDOWN\ntag can be used to obtain a high-spin state.\nThe\nLDMATRIX\nimplementation is best tested for\nvasp_std\n. A bug for\nvasp_gam\nwith\nNCORE\n> 1\nhas been fixed, see\nD-matrix broken for vasp_gam\n.\n\nWarning:\nLDMATRIX\ncannot be used with noncollinear magnetic calculations (\nLNONCOLLINEAR\nand/or\nLSORBIT\n).\n\nSpin-contamination corrections: Some users have modified the source code to include spin-contamination corrections, particularly for low-spin states (\nS\n=\n0\n{\\displaystyle S=0}\n). These modifications are\nnot\nincluded in the default VASP version but can be implemented manually. See forum discussion:\nhttps://vasp.at/forum/viewtopic.php?p=29801p29801\n\nRelated tags an articles\n\nLHFCALC\n,\nNUPDOWN\n,\nISPIN\n\nReferences\n\n↑\nRayson, M. J., and Briddon, P. R.,\nFirst principles method for the calculation of zero-field splitting tensors in periodic systems\n, Phys. Rev. B,\n77\n, 035119 (2008).",
    "related_tags": []
  },
  "LDOWNSAMPLE": {
    "default_value": "LDOWNSAMPLE = .FALSE.",
    "description": "LDOWNSAMPLE selects a sub-grid of k-points defined in KPOINTS from WAVECAR .",
    "detailed_description": "If\nLDOWNSAMPLE\nis present, VASP selects a sub-grid of k-points defined in\nKPOINTS\nand stored in the\nWAVECAR\nfile. \nThis option is automatically selected for\ncRPA calculations\n, where it can be beneficial to perform the Wannier projection on a denser k-point grid than the actual cRPA calculation. For this purpose, the Wannier projection should be written to\nWANPROJ\n.\n\nThis tag is not restricted to cRPA jobs and can be used for any other task that start from a pre-calculated\nWAVECAR\nand/or\nWANPROJ\nfile.",
    "related_tags": [
      "LWANNIER90",
      "LWANNIER90_RUN",
      "WANPROJ"
    ]
  },
  "LEFG": {
    "default_value": "LEFG = .FALSE.",
    "description": "The LEFG computes the electric field gradient (EFG) at positions of the atomic nuclei.",
    "detailed_description": "For\nLEFG\n=.TRUE., the electric field gradient tensors at the positions of the atomic nuclei are calculated using the method of Petrilli\net al.\n[1]\n.\n\nThe EFG tensors are symmetric. The principal components\nV\nii\nand asymmetry parameter η are printed for each atom. Following convention the principal components\nV\nii\nare ordered such that:\n\n|\nV\nz\nz\n|\n>\n|\nV\nx\nx\n|\n>\n|\nV\ny\ny\n|\n.\n{\\displaystyle \n|V_{zz}| > |V_{xx}| > |V_{yy}|.\n}\n\nThe asymmetry parameter is defined as\nη\n=\n(\nV\ny\ny\n−\nV\nx\nx\n)\n/\nV\nz\nz\n{\\displaystyle \\eta = {(V_{yy} - V_{xx})}/ V_{zz}}\n.\nFor so-called \"quadrupolar nuclei\",\ni.e.\n, nuclei with nuclear spin I>1/2, NMR experiments can\naccess\nV\nzz\nand η.\n\nTo convert the\nV\nzz\nvalues into the\nC\nq\noften encountered in NMR literature, one has to specify the nuclear quadrupole moment by means of the\nQUAD_EFG\n-tag.\n\nMind:\nSeveral definitions of\nC\nq\n{\\displaystyle C_q}\nare used in the NMR community, ensure that you are comparing between the same definitions in calculation and experiment.\n\nImportant:\nFor heavy nuclei inaccuracies are to be expected because of an incomplete treatment of relativistic effects.\n\nA guide for calculating the electric field gradient can be found in this\narticle\n.\n\nOutput\n\nThe EFG is listed atom-wise after the SCF cycle has been completed. First, the full 3x3 tensor is printed:\n\nElectric field gradients (V/A^2)\n ---------------------------------------------------------------------\n  ion       V_xx      V_yy      V_zz      V_xy      V_xz      V_yz\n ---------------------------------------------------------------------\n    1        -         -         -         -         -         -\n\nThe tensor is then diagonalized and reprinted:\n\nElectric field gradients after diagonalization (V/A^2)\n  (convention: |V_zz| > |V_xx| > |V_yy|)\n ----------------------------------------------------------------------\n  ion       V_xx      V_yy      V_zz     asymmetry (V_yy - V_xx)/ V_zz\n ----------------------------------------------------------------------\n    1       -         -         -             -\n\nThe corresponding eigenvectors are printed atom-wise. Finally, the quadrupolar parameters are presented, which are commonly reported in NMR experiments.\n\nNMR quadrupolar parameters\n\n  Cq : quadrupolar parameter    Cq=e*Q*V_zz/h\n  eta: asymmetry parameters     (V_yy - V_xx)/ V_zz\n  Q  : nuclear electric quadrupole moment in mb (millibarn)\n ----------------------------------------------------------------------\n  ion       Cq(MHz)       eta       Q (mb)\n ----------------------------------------------------------------------\n    1        -             -         -",
    "related_tags": [
      "QUAD_EFG",
      "Calculating the electric field gradient"
    ]
  },
  "LELF": {
    "default_value": "LELF = .FALSE.",
    "description": "LELF determines whether to create an ELFCAR file or not.",
    "detailed_description": "This file contains the so-called ELF (electron localization\nfunction)\n[1]\n\nIf\nLELF\nis set,\nNPAR\n=1 has to be set explicitely in\nthe\nINCAR\nfile in addition",
    "related_tags": [
      "NPAR"
    ]
  },
  "LEPSILON": {
    "default_value": "LEPSILON = .FALSE.",
    "description": "LEPSILON =.TRUE. determines the static dielectric matrix, ion-clamped piezoelectric tensor, and the Born effective charges using density functional perturbation theory.",
    "detailed_description": "Determines the static ion-clamped dielectric matrix using density functional perturbation\ntheory. The dielectric matrix is calculated with and without local field effects. Usually, local field effects are determined on the Hartree level, i.e. including changes of the Hartree potential.\nTo include microscopic changes of the exchange-correlation potential \nthe tag\nLRPA\n=.FALSE. must be set. The method is explained in detail in paper by Gajdoš\net al.\n[1]\nand closely follows the original work of Baroni and Resta\n[2]\n.\nA summation over empty conduction band states is not required, instead the usual expressions in perturbation theory (\nLOPTICS\n=.TRUE.),\n\n|\n∇\nk\n|\nu\n~\nn\nk\n⟩\n=\n∑\nn\n′\n≠\nn\n|\nu\n~\nn\n′\nk\n⟩\n⟨\nu\n~\nn\n′\nk\n|\n∂\n(\nH\n(\nk\n)\n−\nϵ\nn\nk\nS\n(\nk\n)\n)\n∂\nk\n|\nu\n~\nn\nk\n⟩\nϵ\nn\nk\n−\nϵ\nn\n′\nk\n,\n{\\displaystyle \n| \\nabla_{\\mathbf{k}} |\\tilde{u}_{n\\mathbf{k}} \\rangle = \\sum_{n'\\ne n} \n\\frac{  | \\tilde{u}_{n'\\mathbf{k}} \\rangle  \\langle \\tilde{u}_{n'\\mathbf{k}} |\n   \\frac{\\partial\\, (\\mathbf{H}(\\mathbf k) -\\epsilon_{n\\mathbf{k}} \\mathbf{S}(\\mathbf k))}{ \\partial {\\mathbf{k}}}\n | \\tilde{u}_{n\\mathbf{k}} \\rangle }{\\epsilon_{n\\mathbf{k}}-  \\epsilon_{n'\\mathbf{k}}},\n}\n\nare rewritten as linear Sternheimer equations:\n\n(\nH\n(\nk\n)\n−\nϵ\nn\nk\nS\n(\nk\n)\n)\n|\n∇\nk\nu\n~\nn\nk\n⟩\n=\n−\n∂\n(\nH\n(\nk\n)\n−\nϵ\nn\nk\nS\n(\nk\n)\n)\n∂\nk\n|\nu\n~\nn\nk\n⟩\n.\n{\\displaystyle \n \\left( \\mathbf{H}(\\mathbf k) - \\epsilon_{n\\mathbf k} \\mathbf{S}(\\mathbf k) \\right) \n | \\nabla_{\\mathbf{k}} \\tilde{u}_{n\\mathbf{k}} \\rangle  = -\n \\frac{\\partial  \\,(\\mathbf{H}(\\mathbf k)-  \\epsilon_{n\\mathbf{k}} \\mathbf{S}(\\mathbf k)) }\n{ \\partial {\\mathbf{k}}} | \\tilde{u}_{n\\mathbf{k}} \\rangle .\n}\n\nThe solution of this equation involves similar iterative techniques as the conventional selfconsistency cycles. Hence, for each element of the dielectric matrix several lines will be written to the\nstdout\nand\nOSZICAR\n. These possess a similar structure as for conventional selfconsistent or non-selfconsistent calculations (a residual minimization scheme is used to solve the linear equation, other schemes such as Davidson do not apply to a linear equation):\n\nN       E              dE             d eps       ncg     rms          rms(c)\nRMM:   1    -0.14800E+01   -0.85101E-01   -0.72835E+00   220   0.907E+00    0.146E+00\nRMM:   2    -0.14248E+01    0.55195E-01   -0.27994E-01   221   0.449E+00    0.719E-01\nRMM:   3    -0.13949E+01    0.29864E-01   -0.10673E-01   240   0.322E+00    0.131E-01\nRMM:   4    -0.13949E+01    0.13883E-04   -0.31511E-03   242   0.600E-01    0.336E-02\nRMM:   5    -0.13949E+01    0.28357E-04   -0.25757E-04   228   0.177E-01    0.126E-02\n\nIt is important to note that exact values for the dielectric matrix are obtained even if only valence band states are calculated. Hence this method does not require increasing the\nNBANDS\nparameter. The final values for the static dielectric matrix can be found in the\nOUTCAR\nfile after the lines\n\nMICROSCOPIC STATIC DIELECTRIC TENSOR (excluding local field effects)\n\nand\n\nMACROSCOPIC STATIC DIELECTRIC TENSOR (including local field effects in DFT)\n\nThe values found after\nMACROSCOPIC STATIC DIELECTRIC TENSOR (excluding local field effects)\nshould match exactly to the zero frequency values ω→0 determined by the method selected using\nLOPTICS\n=.TRUE..\nThis offers a convenient way to determine how many empty bands are required for\nLOPTICS\n=.TRUE.. Simply execute VASP using\nLEPSILON\n=.TRUE. in order to determine the exact values for the dielectric constants. Next, switch to\nLOPTICS\n=.TRUE. and increase the number of conduction bands until the same values are obtained using density functional perturbation theory.\n\nNote that the routine also parses and uses the value supplied in the\nLNABLA\ntag.\nFurthermore, the routine calculates the Born effective charge tensor (dynamical charges) and electronic contribution to the piezoelectric tensor,\nand prints them after\n\nBORN EFFECTIVE CHARGES (in e, cumulative output)\n\nand\n\nPIEZOELECTRIC TENSOR  for field in x, y, z        (C/m^2)\n\nif\nLRPA\n=.FALSE. is set (the calculated tensors are not sensible in the random phase approximation\nLRPA\n=.TRUE.). Regarding the piezoelectric tensor, mind the\ndefinition/sign convention of the stress tensor\n.\n\nPros compared to\nLOPTICS\n=.TRUE.\n\nno conduction bands required.\nlocal field effects included on the RPA and DFT level (see\nACFDT/RPA calculations\n).\n\nCons compared to\nLOPTICS\n=.TRUE.\n\npresently only static properties available.\nrequires a relatively time consuming iterative process.\ndoes not support HF or hybrid functionals, whereas\nLOPTICS\n=.TRUE. and the GW routines do.\n\nWe do not recommend to select\nLOPTICS\n=.TRUE. and\nLEPSILON\n=.TRUE.\nin a single run (although it might work in some versions).\nDensity functional perturbation theory\nLEPSILON\n=.TRUE. does not require to increase\nNBANDS\nand is, in fact, much slower if\nNBANDS\nis increased, whereas the summation over empty conduction band states requires a large number of such states.",
    "related_tags": [
      "LOPTICS",
      "LRPA",
      "LCALCEPS",
      "IBRION"
    ]
  },
  "LFINITE_TEMPERATURE": {
    "default_value": "LFINITE_TEMPERATURE = .FALSE.",
    "description": "LFINITE_TEMPERATURE switches on the finite-temperature formalism of many-body perturbation theory for adiabatic-connection-fluctuation-dissipation-theorem (ACFDT)/GW calculations.",
    "detailed_description": "This feature is available as of VASP.6.1.0 for ACFDT/random-phase-approximation (RPA), i.e.,\nALGO\n=ACFDT, ACFDTR, ACFDTRK, and low-scaling\nGW calculations\n, i.e.,\nALGO\n=EVGW0R, GWR[K].\n\nFor\nLFINITE_TEMPERATURE\n=.TRUE., a compressed\nMatsubara-frequency\ngrid is used (instead of the zero-temperature formalism of many-body perturbation theory). This allows for GW and RPA calculations for metallic systems.\n[1]\nTo this end, the electronic temperature is set with the k-point smearing parameter\nSIGMA\nin units of eV, e.g. a value of\nσ\n=\n1\ne\nV\n{\\displaystyle \\sigma=1 eV}\ncorresponds to a electronic temperature of\nT\n≈\n11\n604\nK\n{\\displaystyle T\\approx 11 604 K}\n.\n\nWarning:\nCan only be used in combination with Fermi smearing\nISMEAR\n= -1.",
    "related_tags": [
      "NOMEGA",
      "NOMEGAPAR",
      "NTAUPAR",
      "ISMEAR",
      "↑",
      "M. Kaltak and G. Kresse, Phys. Rev. B. 101 , 205145 (2020)."
    ]
  },
  "LFOCKACE": {
    "default_value": "LFOCKACE = .TRUE. Default: LFOCKACE = .TRUE. for VASP.6 = N/A for VASP.5.X and older",
    "description": "LFOCKACE determines whether the Adaptively Compressed Exchange Operator is used. [1]",
    "detailed_description": "N.B.:Available for CPU and OpenACC version of VASP.6 when compiled with\n-Dfock_dblbuf\n.\n\nFor\nLFOCKACE\n=.TRUE. the Cholesky decomposition\nX\n=\nL\nL\n†\n{\\displaystyle X=LL^\\dagger}\nof the Fock exchange matrix\nX\ni\nj\n=\n⟨\nψ\n~\ni\n∣\nV\n~\nX\n∣\nψ\n~\nj\n⟩\n{\\displaystyle X_{ij} = \\langle \\tilde\\psi_i \\mid \\tilde V_X \\mid \\tilde\\psi_j \\rangle }\nis calculated and the adaptively compressed exchange operator\nV\n~\nA\nC\nE\n=\n−\n∑\ni\n∣\nX\n~\ni\n⟩\n⟨\nX\n~\ni\n∣\n{\\displaystyle \\tilde V_{ACE} = -\\sum_i \\mid \\tilde X_i \\rangle \\langle \\tilde X_i \\mid }\nis used for the action of the Fock exchange on the pseudo orbitals. This method can be used for\nhybrid functionals\nin combination with the Davidson algorithm (\nALGO\n=Normal) to save a factor of\n≈\n3\n{\\displaystyle \\approx 3}\nin computation time.\n\nFor\nLFOCKACE\n=.FALSE. the conventional orbital representation is used.\n\nNote: it is good scientific practice to cite the original publication (Ref.\n[1]\n) if you use this feature. The feature is used by default, if the Davidson algorithm (\nALGO\n= Normal) is used; ACE is not used for\nALGO\n= Damped or\nALGO\n= All.",
    "related_tags": [
      "AEXX",
      "AGGAX",
      "AGGAC",
      "LHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "LFOCKAEDFT": {
    "default_value": "LFOCKAEDFT = .FALSE.",
    "description": "LFOCKAEDFT forces VASP to use the same charge augmentation for the Hartree and DFT exchange correlation part as is used in the Fock exchange and the many body beyond DFT methods, such as RPA, MP2 etc.",
    "detailed_description": "This flag should be set only in exceptional cases. The Hartree as well\nas the DFT part are usually calculated very accurately using the one-centre\nPAW spheres. Restoring the all-electron charge accurately on the plane\nwave grid adds potentially noise, but should not change the results (relative energies,\nforces etc.).\nThe flag, however, needs to be set for optimized potential methods, which\nare supported by VASP but not documented yet.",
    "related_tags": [
      "LMAXFOCKAE",
      "NMAXFOCKAE",
      "QMAXFOCKAE"
    ]
  },
  "LFOCKSTD": {
    "default_value": "LFOCKSTD = .FALSE.",
    "description": "LFOCKSTD applies to RPA and GW calculations. It forces VASP to evaluate the exact exchange fully consistent with the standard treatment in HF calculations.",
    "detailed_description": "Mind:\nAvaliable as of 6.5.2.\n\nThis feature is availabe for low-scaling\nACFDT/random-phase-approximation (RPA)\nand\nGW calculations\n, i.e.\nALGO\n=ACFDTR, RPAR, EVGW0R, GWR.\n\nVASP typically employs shape restoration (see\nNMAXFOCKAE\nand\nLMAXFOCKAE\n) to calculate the RPA correlation energy and the exact exchange energy during RPA/GW calculations. However, this results in significant noise in the exact exchange energy and its nuclear gradients. To mitigate this issue, the\nLFOCKSTD\noption was introduced, forcing VASP to use the standard HF treatment for the exact exchange while continuing to use shape restoration for the correlation energy. This reduces the noise in energies and RPA forces, and it leads to an exact exchange energy that is fully compatible with the exact exchange energy in standard HF calculations.  This means that the energy \" HF-free energy      FHF\" in RPA calculations is identical to the \"free  energy   TOTEN \" when reading the WAVECAR file and performing a single-step total energy evaluation ( ALGO = Eigenval; LFHCALC = .TRUE. ; AEXX = 1.0 ; NELM = 1). In other words, when using LFOCKSTD in RPA calculations, the exact exchange energy is fully compatible with the stepwise evaluation explained here:\nstep wise computation of the total energy\n.\n\nIt is strongly recommended to activate LFOCKSTD for all GW and RPA calculations starting from version 6.5.2.\n\nNote that VASP uses one-center terms to correct the exact exchange energy for the difference in shape between all-electron and pseudo orbitals. Therefore, shape restoration is neither required nor beneficial for the exact exchange term (see\nNMAXFOCKAE\nand\nLMAXFOCKAE\n).",
    "related_tags": [
      "LRPAFORCE"
    ]
  },
  "LFXC": {
    "default_value": "Default: LFXC = .FALSE.",
    "description": "LFXC enables the local exchange-correlation kernel in TD-DFT and TDHF calculations.",
    "detailed_description": "The local exchange-correlation kernel is determined via\n[1]\n\nf\nx\nc\nl\no\nc\n(\nr\n,\nr\n′\n)\n=\nδ\n2\n{\nE\nc\nD\nF\nT\n+\n(\n1\n−\nc\nx\n)\nE\nx\nD\nF\nT\n}\nδ\nρ\n(\nr\n)\nδ\nρ\n(\nr\n′\n)\n{\\displaystyle \nf^{\\rm loc}_{\\mathrm{xc}}\\left(\\mathbf{r}, \\mathbf{r}'\\right) =\n\\frac{\\delta^{2}\\left\\{E_{\\mathrm{c}}^{\\mathrm{DFT}}+\\left(1-c_{\\rm x}\\right)\nE_{\\mathrm{x}}^{\\mathrm{DFT}}\\right\\}}{\\delta \\rho(\\mathbf{r}) \\delta\n\\rho\\left(\\mathbf{r}'\\right)}\n}\n,\n\nwhere\nc\nx\n{\\displaystyle c_{\\rm x}}\nis the fraction of the exchange interaction set by\nAEXX\n.",
    "related_tags": [
      "BSE calculations"
    ]
  },
  "LH5": {
    "default_value": "LH5 = .FALSE.",
    "description": "LH5 determines whether the output is written to the legacy files ( CHGCAR , CHG , WAVECAR ) or the vaspwave.h5 file.",
    "detailed_description": "",
    "related_tags": [
      "LWAVE",
      "LWAVEH5",
      "LCHARG",
      "LCHARGH5"
    ]
  },
  "LHARTREE": {
    "default_value": "LHARTREE = .TRUE.",
    "description": "Controls whether the bubble diagrams are included in the BSE calculation.",
    "detailed_description": "LADDER\nis used together with\nLHARTREE\n. If\nLADDER\n=\n.FALSE.\n, the ladder diagrams, i.e., the exchange terms related to\nW\n{\\displaystyle W}\nor the screened exchange, are not included.\nIf\nLHARTREE\n=\n.FALSE.\n, the Hartree diagrams or bubble diagrams are not included. The following table summarizes all possible combinations:\n\nLHARTREE\nLADDER\n.TRUE.\n.TRUE.\nfull BSE / TDHF\n.FALSE.\n.TRUE.\nonly excitonic effects (ladders)\n.TRUE.\n.FALSE.\nrandom phase approximation (rings = bubbles only)\n.FALSE.\n.FALSE.\nindependent particle picture\n\nThe last combination can be useful for sanity checks: the results must be identical to the results obtained using\nLOPTICS\n=\n.TRUE.\nin the preceding calculations. If this is not the case, it usually implies that the one-electron\nenergies have been updated in the\nWAVECAR\nfile, or that the\nWAVEDER\nfile is not properly set up. The end of\nBSE\nexplains how to recalculate the\nWAVEDER\nfile from an existing\nWAVECAR\nfile.",
    "related_tags": [
      "LADDER",
      "LOPTICS",
      "BSE calculations"
    ]
  },
  "LHFCALC": {
    "default_value": "LHFCALC = .FALSE.",
    "description": "LHFCALC specifies whether a Hartree-Fock/DFT hybrid functional type calculation is performed.",
    "detailed_description": "If one does not specifically request a particular hybrid functional (see\nAEXX\n,\nALDAX\n,\nALDAC\n,\nAGGAX\n,\nAGGAC\n,\nAMGGAX\n,\nAMGGAC\n, and the\nlist_of_hybrid_functionals\n) VASP will default to the\nPBE0 hybrid functional\n.\n\nIt is recommended to select a \"direct optimization\" algorithm for HF/DFT hybrid functonal type calculations, i.e.,\nALGO\n=Damped (\nIALGO\n=53) or\nALGO\n=All (\nIALGO\n=58) in the\nINCAR\nfile.\n\nThe blocked-Davidson algorithm\nALGO\n=Normal is, with certain caveat, also supported, whereas calculations for the other algorithms (\nALGO\n=Fast) are not properly supported (note: no warning is printed). The blocked-Davidson algorithm (\nALGO\n=Normal) is generally rather slow, and in many cases the Pulay mixer will be unable to determine the proper ground-state. We hence recommend to select the blocked-Davidson algorithm only in combination with straight mixing or a Kerker like mixing (see the\nsection on mixing\n). The following combination have been successfully applied for small and medium sized systems\n\nLHFCALC\n= .TRUE. ;\nALGO\n= Normal ;\nIMIX\n= 1 ;\nAMIX\n= a\n\nDecrease the parameter a until convergence is reached.\n\nIn most cases, however, it is recommended to use the \"Damped\" algorithm with suitably chosen timestep. The following setup for the electronic optimization works reliably in most cases:\n\nLHFCALC\n= .TRUE. ;\nALGO\n= Damped ;\nTIME\n= 0.5\n\nIf convergence is not obtained, it is recommended to reduce the timestep\nTIME\n.",
    "related_tags": [
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "HFSCREEN",
      "LTHOMAS",
      "LRHFCALC",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "LHYPERFINE": {
    "default_value": "LHYPERFINE = .FALSE.",
    "description": "compute the hyperfine tensors at the atomic sites (available as of vasp.5.3.2).",
    "detailed_description": "To have VASP compute the hyperfine tensors at the atomic sites, set\n\nLHYPERFINE = .TRUE.\n\nMind:\nSpin-polarized calclulations\nISPIN\n= 2\nmust\nbe used.\n\nWarning:\nNoncollinear calculations\nLNONCOLLINEAR\n= .TRUE. are not currently implemented for\nLHYPERFINE\n. There is not a warning message for this, which will be added in future releases, see\nknown issues.\n\nThe hyperfine tensor A\nI\ndescribes the interaction between a nuclear spin S\nI\n(located at site\nR\nI\n) and the electronic spin distribution S\ne\n(in most cases associated with a paramagnetic defect state)\n[1]\n:\n\nE\n=\n∑\ni\nj\nS\ni\ne\nA\ni\nj\nI\nS\nj\nI\n{\\displaystyle \nE=\\sum_{ij} S^e_i A^I_{ij} S^I_j\n}\n\nIn general it is written as the sum of an isotropic part, the so-called Fermi contact term, and an anisotropic (dipolar) part.\n\nThe Fermi contact term is given by\n\n(\nA\ni\ns\no\nI\n)\ni\nj\n=\n2\n3\nμ\n0\nγ\ne\nγ\nI\n⟨\nS\nz\n⟩\nδ\ni\nj\n∫\nδ\nT\n(\nr\n)\nρ\ns\n(\nr\n+\nR\nI\n)\nd\nr\n{\\displaystyle \n(A^I_{\\mathrm{iso}})_{ij}= \\frac{2}{3}\\frac{\\mu_0\\gamma_e\\gamma_I}{\\langle S_z\\rangle}\\delta_{ij}\\int \\delta_T(\\mathbf{r})\\rho_s(\\mathbf{r}+\\mathbf{R}_I)d\\mathbf{r}\n}\n\nwhere ρ\ns\nis the spin density, μ\n0\nis the magnetic susceptibility of free space,\nγ\ne\nthe electron gyromagnetic ratio, γ\nI\nthe nuclear gyromagnetic ratio of the nucleus at\nR\nI\n, and\n⟨\nS\nz\n⟩\n{\\displaystyle \\langle S_z \\rangle}\nthe expectation value of the\nz\n-component of the total electronic spin.\n\nδ\nT\n(\nr\n) is a smeared out δ function, as described in\nthe Appendix of Ref.\n[2]\n.\n\nThe dipolar contributions to the hyperfine tensor are given by\n\n(\nA\na\nn\ni\nI\n)\ni\nj\n=\nμ\n0\n4\nπ\nγ\ne\nγ\nI\n⟨\nS\nz\n⟩\n∫\nρ\ns\n(\nr\n+\nR\nI\n)\nr\n3\n3\nr\ni\nr\nj\n−\nδ\ni\nj\nr\n2\nr\n2\nd\nr\n{\\displaystyle \n(A^I_{\\mathrm{ani}})_{ij}=\\frac{\\mu_0}{4\\pi}\\frac{\\gamma_e\\gamma_I}{\\langle S_z\\rangle}\n\\int \\frac{\\rho_s(\\mathbf{r}+\\mathbf{R}_I)}{r^3}\\frac{3r_ir_j-\\delta_{ij}r^2}{r^2} d\\mathbf{r}\n}\n\nIn the equations above\nr\n=|\nr\n|,\nr\ni\nthe i-th component of\nr\n, and\nr\nis\ntaken relative to the position of the nucleus\nR\nI\n.\n\nThe nuclear gyromagnetic ratios should be specified by means of the\nNGYROMAG\n-tag.\n\nA guide for\ncalculating the hyperfine coupling constant\nis available.\n\nMind:\nThe Zeroth Order Regular Approximation (ZORA) is used to account for the relativistic effects in the hyperfine tensor calculations.\n\nOutput\n\nAs usual, all output is written to the\nOUTCAR\nfile. VASP writes three blocks of data. The first is for the Fermi contact coupling parameter:\n\nFermi contact (isotropic) hyperfine coupling parameter (MHz)\n -------------------------------------------------------------\n  ion      A_pw      A_1PS     A_1AE     A_1c      A_tot\n -------------------------------------------------------------\n   1       ...       ...       ...       ...       ...\n  ..       ...       ...       ...       ...       ...\n\n -------------------------------------------------------------\n\nwith an entry for each ion on the\nPOSCAR\nfile.\nA\npw\n, A\n1PS\n, A\n1AE\n, and A\n1c\nare the plane wave, pseudo one-center, all-electron one-center, and one-center core contributions to the Fermi contact term, respectively.\nThe total Fermi contact term is given by A\ntot\n.\n\nImportant:\nWe have chosen\nNOT\nto include the core contributions A\n1c\nin A\ntot\n. These are important to add when comparing to experiment where they can contribute a significant proportion to the hyperfine coupling constant (up to ~50 % for\n13\nC\n[1]\n). If you want them to be included, you should add them by hand to A\ntot\n:\nA\nt\no\nt\n+\n1\nc\n=\nA\nt\no\nt\n+\nA\n1\nc\n=\n(\nA\np\nw\n+\nA\nP\nS\n+\nA\nA\nE\n)\n+\nA\n1\nc\n{\\displaystyle \nA_{tot + 1c} = A_{tot} + A_{1c} = (A_{pw} + A_{PS} + A_{AE}) + A_{1c}\n}\nCore electronic contributions to the Fermi contact term are calculated in the frozen valence approximation as proposed by Yazyev\net al.\n[3]\n.\n\nThe dipolar contributions are listed next:\n\nDipolar hyperfine coupling parameters (MHz)\n ---------------------------------------------------------------------\n  ion      A_xx      A_yy      A_zz      A_xy      A_xz      A_yz\n ---------------------------------------------------------------------\n   1       ...       ...       ...       ...       ...       ...\n  ..       ...       ...       ...       ...       ...       ...\n\n ---------------------------------------------------------------------\n\nAgain one line per ion in the\nPOSCAR\nfile.\n\nThe total hyperfine tensors are written as:\n\nTotal hyperfine coupling parameters after diagonalization (MHz)\n (convention: |A_zz| > |A_xx| > |A_yy|)\n ----------------------------------------------------------------------\n  ion      A_xx      A_yy      A_zz     asymmetry (A_yy - A_xx)/ A_zz\n ----------------------------------------------------------------------\n   1       ...       ...       ...         ...\n  ..       ...       ...       ...         ...\n\n ----------------------------------------------------------------------\n\ni.e., the tensors have been diagonalized and rearranged.\n\nMind:\nThe Fermi contact term is strongly dominated by the all-electron one-center contribution A\n1AE\n.\nUnfortunately, this particular term is quite sensitive to the number and eigenenergy of the all-electron partial waves that\nmake up the one-center basis set,\ni.e.\n, to the particulars of the PAW dataset you are using.\nAs a result, the Fermi contact term may strongly depend on the choice of PAW dataset.\n\nUnits\n\nThe Fermi contact term\nA\n{\\displaystyle A}\nis measured in following units\n\n[\nA\n]\n=\n[\nμ\n0\n]\n×\n[\ng\ne\nμ\ne\n]\n×\n[\ng\nj\nμ\nj\n]\n×\n[\n|\nψ\n(\n0\n)\n|\n2\n]\n=\nT\n2\nm\n3\nJ\n×\nJ\nT\n×\nM\nH\nz\nT\n×\n1\nm\n3\n=\nM\nH\nz\n{\\displaystyle [A]=\n\\left[\\mu_0\\right]\\times \n\\left[g_e \\mu_e\\right]\\times \n\\left[g_j \\mu_j\\right]\\times\n\\left[|\\psi(0)|^2\\right] = \n\\frac{T^2m^3}{J}\\times \n\\frac{J}{T}\\times \n\\frac{MHz}{T}\\times\n\\frac{1}{m^3} = MHz\n}\n\nwith\nμ\n0\n=\n4\nπ\n×\n10\n−\n7\nT\n2\nm\n3\nJ\n−\n1\n{\\displaystyle \\mu_0=4\\pi\\times 10^{-7} T^2 m^3 J^{-1}}\n,\ng\ne\nμ\ne\n=\n9.28476377\n×\n10\n−\n24\nJ\nT\n−\n1\n,\n|\nψ\n(\n0\n)\n|\n2\n=\n10\n30\nm\n−\n3\n{\\displaystyle g_e\\mu_e=9.28476377\\times 10^{-24} J T^{-1}, |\\psi(0)|^2=10^{30}m^{-3}}\n.\nNGYROMAG\nis given in units of MHz/T.\n\nAdvice\n\nIt is possible that your system relaxes to a non-magnetic solution, causing the hyperfine splitting to disappear (i.e. all zeros). If you think your system should be magnetic, you can enforce it using\nNUPDOWN\n, which will return the hyperfine splitting, cf. forum post:\nhttps://vasp.at/forum/viewtopic.php?t=16921\n.\nNUPDOWN\nwill change the\nTotal magnetic moment S=\nat the start of the hyperfine coupling section in the\nOUTCAR\n.\n\nImportant:\nFor some cells, the total magnetic moment S can be very small (\ngrep \" mag=\" OSZICAR\n), near zero. In the above equations, the isotropic and anisotropic components of the hyperfine coupling parameter (A\nI\niso\nand A\nI\nani\n) are calculated by dividing through by S (cf. ⟨S\nz\n⟩). To avoid division by zero, S is reset to 1 when S < 10\n-3\n.\nTotal magnetic moment S=\nis changed, changing the hyperfine coupling constants, too. These hyperfine coupling constants are likely not meaningful. In future versions of the code, there will be a warning message stating that S has been reset and the correct total magnetic moment will be printed.",
    "related_tags": [
      "NGYROMAG",
      "Calculating the hyperfine coupling constant"
    ]
  },
  "LIBMBD_ALPHA": {
    "default_value": "",
    "description": "LIBMBD_ALPHA defines the free-atom polarizabilities α 0 {\\displaystyle \\alpha_{0}} (bohr 3 {\\displaystyle ^{3}} ) used in the Tkatchenko-Scheffler and Many-body dispersion energy methods as implemented in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_ALPHA\nallows to set values for the free-atom polarizabilities\nα\n0\n{\\displaystyle \\alpha_{0}}\n(bohr\n3\n{\\displaystyle ^{3}}\n) used in the\nTkatchenko-Scheffler\nand\nMany-body dispersion energy\nmethods as implemented in the library libMBD of many-body dispersion methods\n[1]\n[2]\n[3]\n. For each atom listed in the\nPOSCAR\nfile, a value has to be provided. The values are internally passed to the first column of the libMBD input\nfree_values\ndescribed at the page\n[4]\n.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_C6AU",
      "LIBMBD_R0AU",
      "Tkatchenko-Scheffler",
      "Many-body dispersion energy"
    ]
  },
  "LIBMBD_C6AU": {
    "default_value": "",
    "description": "LIBMBD_C6AU defines the free-atom C 6 {\\displaystyle C_6} parameters ( H a r t r e e {\\displaystyle \\mathrm{Hartree}} b o h r 6 {\\displaystyle \\mathrm{bohr}^{6}} ) used in the Tkatchenko-Scheffler and Many-body dispersion energy methods as implemented in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_C6AU\nallows to set values for the free-atom\nC\n6\n{\\displaystyle C_6}\nparameters (\nH\na\nr\nt\nr\ne\ne\n{\\displaystyle \\mathrm{Hartree}}\nb\no\nh\nr\n6\n{\\displaystyle \\mathrm{bohr}^{6}}\n) used in the\nTkatchenko-Scheffler\nand\nMany-body dispersion energy\nmethods as implemented in the library libMBD of many-body dispersion methods\n[1]\n[2]\n[3]\n. For each atom listed in the\nPOSCAR\nfile, a value has to be provided. The values are internally passed to the second column of the libMBD input\nfree_values\ndescribed at the page\n[4]\n.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_ALPHA",
      "LIBMBD_R0AU",
      "Tkatchenko-Scheffler",
      "Many-body dispersion energy"
    ]
  },
  "LIBMBD_K_GRID": {
    "default_value": "LIBMBD_K_GRID = determined in libMBD according to the cell shape",
    "description": "LIBMBD_K_GRID sets the k-mesh of the collective oscillations defined in the methods available in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_K_GRID\nallows to choose the k-mesh of the collective oscillations defined in the methods available in the library libMBD of many-body dispersion methods. The three integers correspond to the number of k-points along the axes of the cell in the reciprocal space. The values are internally passed to the libMBD input\nk_grid\ndescribed at the page\n[4]\n.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_K_GRID_SHIFT"
    ]
  },
  "LIBMBD_K_GRID_SHIFT": {
    "default_value": "LIBMBD_K_GRID_SHIFT = 0.5 (default in libMBD)",
    "description": "LIBMBD_K_GRID_SHIFT sets the shift for the k-mesh of the collective oscillations defined in the methods available in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_K_GRID_SHIFT\nallows to choose a shift for the k-mesh of the collective oscillations defined in the methods available in the library libMBD of many-body dispersion methods. The value is internally passed to the libMBD input\nk_grid_shift\ndescribed at the page\n[4]\n.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_K_GRID"
    ]
  },
  "LIBMBD_MBD_A": {
    "default_value": "LIBMBD_MBD_A = 6.0",
    "description": "LIBMBD_MBD_A sets the value of the damping parameter a {\\displaystyle a} in the many-body methods as implemented in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_MBD_A\nallows to choose the value of the damping parameter\na\n{\\displaystyle a}\nin the many-body methods as implemented in the library libMBD of many-body dispersion methods\n[1]\n[2]\n[3]\n. The value is internally passed to the libMBD input\nmbd_a\ndescribed at the page\n[4]\n.\n\nMind:\nLIBMBD_MBD_A\ncan be set only if\nLIBMBD_XC\n=none.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_XC",
      "LIBMBD_MBD_BETA",
      "Many-body dispersion energy"
    ]
  },
  "LIBMBD_MBD_BETA": {
    "default_value": "LIBMBD_MBD_BETA = value that was determined for the exchange-correlation functional set with LIBMBD_XC",
    "description": "LIBMBD_MBD_BETA sets the value of the scaling factor β {\\displaystyle \\beta} (usually denoted s R {\\displaystyle s_R} ) in the many-body methods as implemented in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_MBD_BETA\nallows to choose the value of the damping parameter\nβ\n{\\displaystyle \\beta}\nin the many-body methods as implemented in the library libMBD of many-body dispersion methods\n[1]\n[2]\n[3]\n. The value is internally passed to the libMBD input\nmbd_beta\ndescribed at the page\n[4]\n.\nLIBMBD_MBD_BETA\nis the same as the\nVDW_SR\ntag that is used for the VASP implementation of the many-body methods.\n\nMind:\nLIBMBD_MBD_BETA\ncan be set only if\nLIBMBD_XC\n=none.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_XC",
      "LIBMBD_MBD_A",
      "Many-body dispersion energy"
    ]
  },
  "LIBMBD_METHOD": {
    "default_value": "LIBMBD_METHOD = mbd-rsscs (default in libMBD)",
    "description": "LIBMBD_METHOD selects one of the methods available in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_METHOD\ncan be set to a label (string) corresponding to one of the methods listed on the libMBD website (see\nmethod\nat the page\n[4]\n).\n\nMind:\nNote that the use of the mbd-nl method\n[5]\nis currently not possible, since the associated atomic polarizabilities and semilocal functional are currently not implemented in VASP.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_XC",
      "LIBMBD_TS_D",
      "LIBMBD_TS_SR",
      "LIBMBD_MBD_A",
      "LIBMBD_MBD_BETA",
      "LIBMBD_VDW_PARAMS_KIND",
      "LIBMBD_ALPHA",
      "LIBMBD_C6AU",
      "LIBMBD_R0AU",
      "LIBMBD_N_OMEGA_GRID",
      "LIBMBD_K_GRID",
      "LIBMBD_K_GRID_SHIFT",
      "LIBMBD_PARALLEL_MODE",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "LIBMBD_N_OMEGA_GRID": {
    "default_value": "LIBMBD_N_OMEGA_GRID = 15 (default in libMBD)",
    "description": "LIBMBD_N_OMEGA_GRID sets the number of points on the grid of imaginary frequencies used in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_N_OMEGA_GRID\nallows to choose the number of points on the grid of imaginary frequencies used in the library libMBD of many-body dispersion methods. The value is internally passed to the libMBD input\nn_omega_grid\ndescribed at the page\n[4]\n.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD"
    ]
  },
  "LIBMBD_PARALLEL_MODE": {
    "default_value": "LIBMBD_PARALLEL_MODE =auto (default in libMBD)",
    "description": "LIBMBD_PARALLEL_MODE selects the parallelization scheme used in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_PARALLEL_MODE\nallows to choose the parallelization scheme used in the library libMBD of many-body dispersion methods\n[1]\n[2]\n[3]\n. The value is internally passed to the libMBD input\nparallel_mode\ndescribed at the page\n[4]\n.\n\nImportant:\nThe\nLIBMBD_PARALLEL_MODE\ntag can be used only if libMBD was compiled with MPI parallelization enabled.\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD"
    ]
  },
  "LIBMBD_R0AU": {
    "default_value": "",
    "description": "LIBMBD_R0AU defines the free-atom R 0 {\\displaystyle R_0} parameters (bohr) used in the Tkatchenko-Scheffler and Many-body dispersion energy methods as implemented in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_R0AU\nallows to set values for the free-atom\nR\n0\n{\\displaystyle R_0}\nparameters (bohr) used in the\nTkatchenko-Scheffler\nand\nMany-body dispersion energy\nmethods as implemented in the library libMBD of many-body dispersion methods\n[1]\n[2]\n[3]\n. For each atom listed in the\nPOSCAR\nfile, a value has to be provided. The values are internally passed to the third column of the libMBD input\nfree_values\ndescribed at the page\n[4]\n.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_ALPHA",
      "LIBMBD_C6AU",
      "Tkatchenko-Scheffler",
      "Many-body dispersion energy"
    ]
  },
  "LIBMBD_TS_D": {
    "default_value": "LIBMBD_TS_D = 20",
    "description": "LIBMBD_TS_D sets the value of the damping parameter d {\\displaystyle d} in the Tkatchenko-Scheffler method [1] as implemented in the library libMBD of many-body dispersion methods [2] [3] [4] .",
    "detailed_description": "LIBMBD_TS_D\nallows to choose the value of the damping parameter\nd\n{\\displaystyle d}\nin the Tkatchenko-Scheffler method\n[1]\nas implemented in the library libMBD of many-body dispersion methods\n[2]\n[3]\n[4]\n. The value is internally passed to the libMBD input\nts_d\ndescribed at the page\n[5]\n.\nLIBMBD_TS_D\nis the same as the\nVDW_D\ntag that is used for the VASP implementation of the Tkatchenko-Scheffler method.\n\nMind:\nLIBMBD_TS_D\ncan be set only if\nLIBMBD_XC\n=none.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[3]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_XC",
      "LIBMBD_TS_SR",
      "Tkatchenko-Scheffler method"
    ]
  },
  "LIBMBD_TS_SR": {
    "default_value": "LIBMBD_TS_SR = value that was determined for the exchange-correlation functional set with LIBMBD_XC",
    "description": "LIBMBD_TS_SR sets the value of the scaling factor s R {\\displaystyle s_R} in the Tkatchenko-Scheffler method [1] as implemented in the library libMBD of many-body dispersion methods [2] [3] [4] .",
    "detailed_description": "LIBMBD_TS_SR\nallows to choose the value of the scaling factor\ns\nR\n{\\displaystyle s_R}\nin the Tkatchenko-Scheffler method\n[1]\nas implemented in the library libMBD of many-body dispersion methods\n[2]\n[3]\n[4]\n. The value is internally passed to the libMBD input\nts_sr\ndescribed at the page\n[5]\n.\nLIBMBD_TS_SR\nis similar to the\nVDW_SR\ntag that is used for the VASP implementation of the Tkatchenko-Scheffler method.\n\nMind:\nLIBMBD_TS_SR\ncan be set only if\nLIBMBD_XC\n=none.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[3]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "LIBMBD_XC",
      "LIBMBD_TS_D",
      "Tkatchenko-Scheffler method"
    ]
  },
  "LIBMBD_VDW_PARAMS_KIND": {
    "default_value": "LIBMBD_VDW_PARAMS_KIND =ts (default in libMBD)",
    "description": "LIBMBD_VDW_PARAMS_KIND sets the type of free-atom van der Waals parameters that are used for the methods implemented in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_VDW_PARAMS_KIND\nallows to choose the set of van der Waals parameters from either the original Tkatchenko-Scheffler method\n[4]\n(\nLIBMBD_VDW_PARAMS_KIND\n=ts) or its variant that was designed to be more accurate for systems with surface\n[5]\n(\nLIBMBD_VDW_PARAMS_KIND\n=tssurf). The value is internally passed to the libMBD input\nvdw_params_kind\ndescribed at the page\n[6]\n.\nLIBMBD_VDW_PARAMS_KIND\nis similar to the\nLTSSURF\ntag that is used for the VASP implementation of the Tkatchenko-Scheffler method.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "LIBMBD_XC": {
    "default_value": "The functional set by the GGA , METAGGA or XC tag",
    "description": "LIBMBD_XC sets the exchange-correlation functional for the setting of damping parameters used in the methods available in the library libMBD of many-body dispersion methods [1] [2] [3] .",
    "detailed_description": "LIBMBD_XC\nallows to choose the exchange-correlation functional that determines which set of damping parameters is used in the methods available in the library libMBD of many-body dispersion methods. The value is internally passed to the libMBD input\nxc\ndescribed at the page\n[4]\n.\n\nThe possible choices depend on the dispersion method selected with the\nLIBMBD_METHOD\ntag and are listed in the file mbd_damping.F90 of the libMBD source code. If\nLIBMBD_XC\n=none is chosen, then no set of damping parameters is selected and either\nLIBMBD_TS_SR\nor\nLIBMBD_MBD_BETA\nhas to be set.\n\nImportant:\nThis feature is available from VASP.6.4.3 onwards that needs to be compiled with\n-DLIBMBD\n.\n\nlibMBD is a separate library package that has to be downloaded\n[2]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.",
    "related_tags": [
      "LIBMBD_METHOD"
    ]
  },
  "LIBXC1": {
    "default_value": "",
    "description": "LIBXC1 specifies the exchange or exchange-correlation functional from the library of exchange-correlation functionals Libxc [1] [2] [3] .",
    "detailed_description": "Important:\nThis feature is available from VASP.6.3.0 onwards that needs to be compiled with\n-DUSELIBXC\n.\n\nLIBXC1\nand\nLIBXC2\ncan be set to a label (string) or number (integer) associated with a functional listed on the Libxc website\n[4]\n, e.g.,\nGGA_X_PBE\nand\n101\nfor PBE exchange. The label indicates if this is an exchange (X), correlation (C), or exchange-correlation (XC) functional, and which family it belongs to, namely LDA (LDA or HYB_LDA), GGA (GGA or HYB_GGA) or meta-GGA (MGGA or HYB_MGGA). If\nLIBXC1\ncorresponds to an exchange functional, then it can be used in combination with\nLIBXC2\nfor the correlation functional.\n\nLibxc is a separate library package that has to be downloaded\n[3]\nand compiled before VASP is compiled with the corresponding\nprecompiler options\nand\nlinks to the libraries\n.\n\nCalculations with Laplacian-dependent meta-GGA functionals and meta-GGA-based hybrid functionals are possible since VASP.6.4.0.\n\nImportant:\nTo get correct results with meta-GGA functionals (see discussion at\nLTBOUNDLIBXC\n), it is necessary to use Libxc from version 5.2.0 onwards (or the master version for the latest implemented functionals) and to\ncompile it with the option\n--disable-fhc\n.\n\nHow to\n\nThe allowed possibilities for\nLIBXC1\nand\nLIBXC2\nare the following:\n\nBoth\nLIBXC1\nand\nLIBXC2\nare specified and correspond to exchange and correlation functionals, respectively.\nOnly\nLIBXC1\nis specified and corresponds to an exchange or exchange-correlation functional.\n\nWarning:\nIf\nLIBXC1\nis an exchange-correlation functional, then\nLIBXC2\ncan not be used.\n\nLIBXC1\nand\nLIBXC2\ncan correspond to functionals of different families, e.g., a meta-GGA and a GGA, respectively.\n\nRegarding other tags in\nINCAR\nrelated to Libxc:\n\nOne also has to specify\nGGA\n= LIBXC for LDA, GGA and GGA-based hybrid functionals or\nMETAGGA\n= LIBXC for meta-GGA functionals and meta-GGA-based hybrid functionals. Note that if one of the tags (\nLIBXC1\nor\nLIBXC2\n) corresponds to a meta-GGA, while the other corresponds to a GGA or LDA, then\nMETAGGA\n= LIBXC (and not\nGGA\n= LIBXC) has to be specified.\nMany of the functionals implemented in Libxc have parameters that can be modified. This can be done via the tags\nLIBXC1_Pn\nand\nLIBXC2_Pn\n, where\nn\n=\n1\n,\n2\n,\n…\n{\\displaystyle n=1, 2, \\ldots}\n.\nThe tag\nLTBOUNDLIBXC\n, which is .FALSE. by default, allows to enforce the lower bound on the kinetic-energy density (\nτ\nσ\nW\n<\nτ\nσ\n{\\displaystyle \\tau_{\\sigma}^{\\mathrm{W}}<\\tau_{\\sigma}}\n) with\nτ\nσ\n=\nmax\n(\nτ\nσ\n,\nτ\nσ\nW\n)\n{\\displaystyle \\tau_{\\sigma}=\\max(\\tau_{\\sigma},\\tau_{\\sigma}^{\\mathrm{W}})}\nbefore\nτ\nσ\n{\\displaystyle \\tau_{\\sigma}}\nis used in a meta-GGA functional from Libxc.\n\nFor calculations with hybrid functionals (\nLHFCALC\n=True), the following provides some explanations:\n\nThe Libxc functionals whose tag starts with HYB already include the mixing parameter. Therefore, for them, the\nALDAX\n,\nALDAC\n,\nAGGAX\n,\nAGGAC\n,\nAMGGAX\n, and\nAMGGAC\ntags can not be used (more information on how to modify the mixing and screening parameters can be found at\nLIBXC1_Pn\n). However, it is still necessary to set\nAEXX\nat the proper value.\nIf the semilocal component of the hybrid functional is constructed using Libxc functionals that do not contain HYB in the tag, then\nALDAX\n,\nAGGAX\n,\nALDAC\n, and\nAGGAC\nwill be used and multiply\n\nE\nx\nL\nD\nA\n=\n∫\nϵ\nx\nL\nD\nA\n(\nn\n)\nd\n3\nr\n{\\displaystyle E_{\\mathrm{x}}^{\\mathrm{LDA}}=\\int\\epsilon_{\\mathrm{x}}^{\\mathrm{LDA}}(n)d^{3}r}\nΔ\nE\nx\nG\nG\nA\n=\n∫\n(\nϵ\nx\nG\nG\nA\n(\nn\n,\n∇\nn\n)\n−\nϵ\nx\nL\nD\nA\n(\nn\n)\n)\nd\n3\nr\n{\\displaystyle \\Delta E_{\\mathrm{x}}^{\\mathrm{GGA}}=\\int\\left(\\epsilon_{\\mathrm{x}}^{\\mathrm{GGA}}(n,\\nabla n) - \\epsilon_{\\mathrm{x}}^{\\mathrm{LDA}}(n)\\right)d^{3}r}\nE\nc\nL\nD\nA\n=\n∫\nϵ\nc\nL\nD\nA\n(\nn\n)\nd\n3\nr\n{\\displaystyle E_{\\mathrm{c}}^{\\mathrm{LDA}}=\\int\\epsilon_{\\mathrm{c}}^{\\mathrm{LDA}}(n)d^{3}r}\nΔ\nE\nc\nG\nG\nA\n=\n∫\n(\nϵ\nc\nG\nG\nA\n(\nn\n,\n∇\nn\n)\n−\nϵ\nc\nL\nD\nA\n(\nn\n)\n)\nd\n3\nr\n{\\displaystyle \\Delta E_{\\mathrm{c}}^{\\mathrm{GGA}}=\\int\\left(\\epsilon_{\\mathrm{c}}^{\\mathrm{GGA}}(n,\\nabla n) - \\epsilon_{\\mathrm{c}}^{\\mathrm{LDA}}(n)\\right)d^{3}r}\nrespectively, where\nϵ\nx\nL\nD\nA\n(\nn\n)\n=\n−\n(\n3\n/\n4\n)\n(\n3\n/\nπ\n)\n1\n/\n3\nn\n4\n/\n3\n{\\displaystyle \\epsilon_{\\mathrm{x}}^{\\mathrm{LDA}}(n)=-\\left(3/4\\right)\\left(3/\\pi\\right)^{1/3}n^{4/3}}\nand\nϵ\nc\nL\nD\nA\n(\nn\n)\n=\nϵ\nc\nG\nG\nA\n(\nn\n,\n∇\nn\n=\n0\n)\n{\\displaystyle \\epsilon_{\\mathrm{c}}^{\\mathrm{LDA}}(n)=\\epsilon_{\\mathrm{c}}^{\\mathrm{GGA}}(n,\\nabla n=0)}\n.\n\nExamples of\nINCAR\n\nPBE\n[5]\n\nGGA\n= LIBXC\nLIBXC1\n= GGA_X_PBE # or 101\nLIBXC2\n= GGA_C_PBE # or 130\n\nSCAN\n[6]\n\nMETAGGA\n= LIBXC\nLIBXC1\n= MGGA_X_SCAN # or 263\nLIBXC2\n= MGGA_C_SCAN # or 267\n\nPBEh (PBE0)\n[7]\n\nLHFCALC\n= .TRUE.\nAEXX\n= 0.25\nGGA\n= LIBXC\nLIBXC1\n= HYB_GGA_XC_PBEH # or 406\n\nSCAN0\n\nLHFCALC\n= .TRUE.\nAEXX\n= 0.25\nMETAGGA\n= LIBXC\nLIBXC1\n= MGGA_X_SCAN # or 263\nLIBXC2\n= MGGA_C_SCAN # or 267",
    "related_tags": [
      "LIBXC2",
      "LIBXC1_Pn",
      "LIBXC2_Pn",
      "LTBOUNDLIBXC",
      "GGA",
      "METAGGA",
      "LHFCALC",
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "List of hybrid functionals"
    ]
  },
  "LIBXC1_Pn": {
    "default_value": "",
    "description": "LIBXC1_Pn , where n = 1 , 2 , … {\\displaystyle n=1, 2, \\ldots} allows to specify the values of the parameters of the functional implemented in Libxc that is called with LIBXC1 .",
    "detailed_description": "For many of the functionals implemented in the library of exchange-correlation functionals Libxc\n[1]\n[2]\n[3]\nit is possible to modify the parameters if one does not want to use the default values. If a functional from Libxc has parameters that can be modified, then they are listed in\nOUTCAR\nbelow \"Parameters of Libxc functionals:\" as P\nn\n{\\displaystyle n}\n(\nn\n=\n1\n,\n2\n,\n…\n{\\displaystyle n=1, 2, \\ldots}\n).\nLIBXC1_Pn\nand\nLIBXC2_Pn\nare for the functionals called with\nLIBXC1\nand\nLIBXC2\n, respectively.\n\nAn example is given below for the GGA PBE functional\n[4]\nwhere the default parameters\nμ\n=\n0.21951\n{\\displaystyle \\mu=0.21951}\nin exchange and\nβ\n=\n0.066725\n{\\displaystyle \\beta=0.066725}\nin correlation are changed to\nμ\n=\n10\n/\n81\n≈\n0.12345679\n{\\displaystyle \\mu=10/81\\approx0.12345679}\nand\nβ\n=\n0.046\n{\\displaystyle \\beta=0.046}\nto get the PBEsol functional\n[5]\n(of course, the simpler way to use PBEsol from Libxc would be to call it directly with\nLIBXC1\n=GGA_X_PBE_SOL and\nLIBXC2\n=GGA_C_PBE_SOL).\n\nGGA\n= LIBXC\nLIBXC1\n= GGA_X_PBE # or 101\nLIBXC2\n= GGA_C_PBE # or 130\nLIBXC1_P2\n= 0.12345679\nLIBXC2_P1\n= 0.046\n\nMind:\nThe\nALDAX\n,\nALDAC\n,\nAGGAX\n,\nAGGAC\n,\nAMGGAX\n, and\nAMGGAC\ntags are ignored if the Libxc functional is an exchange-correlation functional (those with a tag that contains XC)\n\nFor Libxc functionals that are the semilocal component of a hybrid functional, i.e. those with a tag that starts with HYB (\nLHFCALC\n=.TRUE. will be set automatically if such a functional is selected), the following explains how it works for the mixing and screening parameters:\n\nMixing parameter:\nIt is usually one of the parameters\nLIBXC1_Pn\n, and can therefore be modified.\nFor HYB_GGA_XC_PBEH, HYB_GGA_XC_B1WC, HYB_GGA_XC_HSE03, HYB_GGA_XC_HSE06, HYB_GGA_XC_HSE12, and HYB_GGA_XC_HSE12S, the value of\nAEXX\n(even if not specified explicitly in\nINCAR\n) will be used and automatically passed to the corresponding parameter in Libxc. On the other hand, if this corresponding parameter (\nLIBXC1_Pn\n) is specified in\nINCAR\n, then it will be used (instead of\nAEXX\n), however note that it will be only for the semilocal component of the hybrid functional and not for the exact exchange that will still use\nAEXX\n.\nFor all hybrid functionals except those listed just above,\nAEXX\nwill not be considered for the semilocal component of the hybrid functional, but only for the exact exchange component. Therefore, a particular choice for the mixing parameter has to be done by specifying both\nAEXX\n(for the exact exchange) and the appropriate\nLIBXC1_Pn\n(for the semilocal component).\nThe\nALDAX\n,\nALDAC\n,\nAGGAX\n,\nAGGAC\n,\nAMGGAX\n, and\nAMGGAC\ntags are ignored if the Libxc functional is an hybrid functional (those with a tag that starts with HYB).\nScreening parameter:\nIt is usually one of the parameters\nLIBXC1_Pn\nif it is a screened functional, and can therefore be modified.\nFor HYB_GGA_XC_HSE03, HYB_GGA_XC_HSE06, HYB_GGA_XC_HSE12, and HYB_GGA_XC_HSE12S, the value of\nHFSCREEN\n(even if not specified explicitly in\nINCAR\n) will be used and automatically passed to the corresponding parameter in Libxc. On the other hand, if this corresponding parameter (\nLIBXC1_Pn\n) is specified in\nINCAR\n, then it will be used (instead of\nHFSCREEN\n), however note that it will be only for the semilocal component of the hybrid functional and not for the exact exchange that will still use\nHFSCREEN\n.\nFor all hybrid functionals except those listed just above,\nHFSCREEN\nwill not be considered for the semilocal component of the hybrid functional, but only for the exact exchange component. Therefore, a particular choice for the screening parameter has to be done by specifying both\nHFSCREEN\n(for the exact exchange) and the appropriate\nLIBXC1_Pn\n(for the semilocal component).",
    "related_tags": [
      "LIBXC1",
      "LIBXC2",
      "LIBXC2_Pn",
      "LTBOUNDLIBXC",
      "GGA",
      "METAGGA",
      "LHFCALC",
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC",
      "List of hybrid functionals"
    ]
  },
  "LIBXC2": {
    "default_value": "",
    "description": "LIBXC2 specifies the correlation functional from the library of exchange-correlation functionals Libxc [1] [2] [3] . LIBXC2 can be used only if the functional specified with LIBXC1 corresponds to only exchange and not to exchange and correlation.",
    "detailed_description": "A detailed explanation of how to use\nLIBXC1\nand\nLIBXC2\nand examples can be found on the\nLIBXC1\npage.\n\nRelated Tags and Sections\n\nLIBXC1\n,\nLIBXC1_Pn\n,\nLIBXC2_Pn\n,\nLTBOUNDLIBXC\n,\nGGA\n,\nMETAGGA\n,\nLHFCALC\n,\nAEXX\n,\nALDAX\n,\nALDAC\n,\nAGGAX\n,\nAGGAC\n,\nList of hybrid functionals\n\nExamples that use this tag\n\nReferences\n\n↑\nM. A. L. Marques, M. J. T. Oliveira, and T. Burnus, Comput. Phys. Commun.,\n183\n, 2272 (2012).\n↑\nS. Lehtola, C. Steigemann, M. J. T. Oliveira, and M. A. L. Marques, SoftwareX,\n7\n, 1 (2018).\n↑\nhttps://libxc.gitlab.io",
    "related_tags": []
  },
  "LIBXC2_Pn": {
    "default_value": "",
    "description": "LIBXC2_Pn , where n = 1 , 2 , … {\\displaystyle n=1, 2, \\ldots} allows to specify the values of the parameters of the functional implemented in Libxc that is called with LIBXC2 .",
    "detailed_description": "A detailed explanation on how to use\nLIBXC1_Pn\nand\nLIBXC2_Pn\nand an example can be found at the\nLIBXC1_Pn\npage.",
    "related_tags": [
      "LIBXC1",
      "LIBXC2",
      "LIBXC1_Pn",
      "LTBOUNDLIBXC",
      "GGA",
      "METAGGA",
      "LHFCALC",
      "AEXX",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "List of hybrid functionals"
    ]
  },
  "LKPOINTS_OPT": {
    "default_value": "Default: LKPOINTS_OPT = .TRUE. if KPOINTS_OPT file is present.",
    "description": "LKPOINTS_OPT controls whether VASP reads the KPOINTS_OPT file.",
    "detailed_description": "To avoid reading the\nKPOINTS_OPT\nfile without removing it from the working directory, the\nLKPOINTS_OPT\ntag can be set to\n.FALSE.\nin the\nINCAR\nfile.",
    "related_tags": [
      "KPOINTS_OPT",
      "PROCAR_OPT"
    ]
  },
  "LKPOINTS_WAN": {
    "default_value": "Default: LKPOINTS_WAN = .TRUE. if KPOINTS_WAN file is present.",
    "description": "LKPOINTS_WAN controlls whether VASP reads the KPOINTS_WAN file.",
    "detailed_description": "To avoid reading the\nKPOINTS_WAN\nfile without removing it from the working directory, the\nLKPOINTS_WAN\ntag can be set to\n.FALSE.\nin the\nINCAR\nfile.",
    "related_tags": [
      "KPOINTS_WAN"
    ]
  },
  "LKPROJ": {
    "default_value": "LKPROJ = .FALSE.",
    "description": "switches on the k -point projection scheme.",
    "detailed_description": "For\nLKPROJ\n=.TRUE., VASP will project the orbitals onto the reciprocal space of an alternative unit cell.\nThis unit cell has to be supplied in the file\nPOSCAR.prim\n, in the usual\nPOSCAR\nformat.\n\nAs a first step, the\nk\n-projection scheme determines the set {\nk′\n}, of\nk\n-points in the irreducible part of the first Brillouin zone of the structure given in\nPOSCAR.prim\n, for which\n\n⟨\nk\n′\n+\nG\n′\n|\nk\n+\nG\n⟩\n≠\n0\n{\\displaystyle \n\\langle \\mathbf{k}'+\\mathbf{G}' | \\mathbf{k}+\\mathbf{G}\\rangle \\neq 0\n}\n\nwhere\nG\nand\nG′\nare reciprocal space vectors in the reciprocal spaces of the structures specified in\nPOSCAR\nand\nPOSCAR.prim\n, respectively. As usual, the set of points {\nk\n} is specified in the\nKPOINTS\nfile.\nThe set {\nk′\n} is written to the\nOUTCAR\nfile. Look at the part of the\nOUTCAR\nfollowing\nNKPTS_PRIM\n.\n\nOnce the set {\nk′\n} has been determined VASP will compute the following\n\nK\nn\nk\nσ\nk\n′\n=\n∑\nG\nG\n′\n|\n⟨\nk\n′\n+\nG\n′\n|\nk\n+\nG\n⟩\n⟨\nk\n+\nG\n|\nψ\nn\nk\nσ\n⟩\n|\n2\n{\\displaystyle \n\\Kappa_{n\\mathbf{k}\\sigma\\mathbf{k}'}=\\sum_{\\mathbf{GG}'}\n|\\langle \\mathbf{k}'+\\mathbf{G}'| \\mathbf{k}+\\mathbf{G}\\rangle\n\\langle \\mathbf{k}+\\mathbf{G} | \\psi_{n\\mathbf{k}\\sigma}\\rangle |^2\n}\n\nand writes this information onto the\nPRJCAR\nand\nvasprun.xml\nfiles.\n\nK\nn\nk\nσ\nk′\nprovides a measure of how strongly the orbital\nΨ\n{\\displaystyle \\Psi}\nn\nk\nσ\ncontributes at the point\nk′\nin the reciprocal space of structure\nPOSCAR.prim\n.\n\nOne may, for instance, use this scheme to project the orbitals of a supercell onto the reciprocal space of a generating primitive cell.\n\nWarning:\nAt the moment the\nk\n-point projection only works with\nNPAR\n=1.\n\nMind:\nAvailable as of VASP version 6.0.0.",
    "related_tags": [
      "PRJCAR"
    ]
  },
  "LLRAUG": {
    "default_value": "LLRAUG = .FALSE.",
    "description": "LLRAUG calculates the two-center contributions to the chemical shift tensor.",
    "detailed_description": "LLRAUG\nswitches on two-center contributions to the NMR chemical shift tensor.\nThese are contributions due to the augmentation\ncurrents in other PAW spheres than the sphere with the atom for which the shift tensor is calculated.\nTypically these contributions are safely neglected.\nIt makes sense to include them for accurate calculations with hard potentials (\n*_h\n)\non systems containing also (non-hydrogen) atoms from the top rows of the periodic\ntable (B, C, N, O, F), typically with short bonds, e.g. C\n2\nH\n2\n, where\neffects up to a few ppm are possible. Effects are most significant for the H shift. For such systems using standard potentials\ntypically introduces larger inaccuracies. The two-center contributions are calculated using\na multipole expansion of the current density that is represented on the plane wave grid; as in Sec. III.A.3 of. Ref.\n[1]\n.  \nThe relevance of\nLLRAUG\nto achieve basis-set completeness for shieldings is discussed in \nRef.\n[2]\nthat compares to basis-set converged quantum chemical calculations\n[3]\n.",
    "related_tags": [
      "LCHIMAG"
    ]
  },
  "LMAXFOCK": {
    "default_value": "LMAXFOCK = 4",
    "description": "LMAXFOCK sets the maximum angular momentum quantum number L for the augmentation of charge densities in Hartree-Fock type routines.",
    "detailed_description": "In the\nPAW method\n, the difference between the charge density of the all-electron partial waves\nϕ\nβ\n{\\displaystyle \\phi_\\beta}\nand\nthe pseudo partial waves\nϕ\n~\nβ\n{\\displaystyle \\tilde \\phi_\\beta}\n\nQ\nα\nβ\n(\nr\n)\n=\nϕ\nα\n∗\n(\nr\n)\nϕ\nβ\n(\nr\n)\n−\nϕ\n~\nα\n∗\n(\nr\n)\nϕ\n~\nβ\n(\nr\n)\n{\\displaystyle \nQ_{\\alpha\\beta}({\\mathbf r})= \\phi^*_\\alpha({\\mathbf r})\\phi_\\beta({\\mathbf r})  - \\tilde \\phi^*_\\alpha({\\mathbf r})\\tilde \\phi_\\beta({\\mathbf r})\n}\n\nis usually treated on spherical grids centered at each atom\n(one-center terms inside the PAW spheres, see\nPAW method\n). To describe long range electrostatic effects, the\nmoments\nof the differences of the all-electron and pseudo charge density \nalso need to be added on the plane wave grid (compensation density, see\nPAW method\n).\nThese compensation charges exactly restore the moments of the all-electron density on the plane wave\ngrid. For the charge densities used in the Hartree and DFT term, \nthe augmentation is done exactly up to the maximum\nL\nquantum number required by the POTCAR files, \nwhereas for the Fock exchange, for reasons of efficiency, \nthe augmentation on the plane wave grid is controlled by\nLMAXFOCK\n.\n\nSpecifically, when the  exchange energy is evaluated\n\nE\nx\n=\n−\ne\n2\n2\n∑\nn\nk\n,\nm\nq\nf\nn\nk\nf\nm\nq\n×\n∫\n∫\nd\n3\nr\nd\n3\nr\n′\nψ\nn\nk\n∗\n(\nr\n)\nψ\nm\nq\n∗\n(\nr\n′\n)\nψ\nn\nk\n(\nr\n′\n)\nψ\nm\nq\n(\nr\n)\n|\nr\n−\nr\n′\n|\n{\\displaystyle \nE_{\\mathrm{x}}= -\\frac{e^2}{2}\\sum_{n\\mathbf{k},m\\mathbf{q}} \nf_{n\\mathbf{k}} f_{m\\mathbf{q}} \\times \n\\int\\int d^3\\mathbf{r} d^3\\mathbf{r}'\n\\frac{\\psi_{n\\mathbf{k}}^{*}(\\mathbf{r})\\psi_{m\\mathbf{q}}^{*}(\\mathbf{r}')\n\\psi_{n\\mathbf{k}}(\\mathbf{r}')\\psi_{m\\mathbf{q}}(\\mathbf{r})}\n{\\vert \\mathbf{r}-\\mathbf{r}' \\vert}\n}\n\nthe overlap density\nψ\nn\nk\n∗\n(\nr\n)\nψ\nm\nq\n(\nr\n)\n{\\displaystyle  \\psi_{n\\mathbf{k}}^{*}(\\mathbf{r})\\psi_{m\\mathbf{q}}(\\mathbf{r}) }\nbetween two Bloch orbitals needs to be calculated on the plane wave grid (see\nPAW method\n). The tag\nLMAXFOCK\ncontrols up to which\nL\nquantum number, the compensation charge\nn\n^\n(\nr\n)\n{\\displaystyle \\widehat{n}(\\mathbf{r})}\nis calculated on the plane wave grid (compared\nPAW method\ncompensation charge):\n\nn\n^\n(\nr\n)\n=\n∑\nα\n,\nβ\n,\nL\nM\nQ\n^\nα\n,\nβ\nL\nM\n(\nr\n)\n⟨\nψ\n~\nn\nk\n|\np\n~\nα\n⟩\n⟨\np\n~\nβ\n|\nψ\n~\nm\nk\n⟩\n.\n{\\displaystyle \n  \\widehat{n}(\\mathbf{r}) = \\sum_{\\alpha,\\beta,LM} \\widehat{Q}_{\\alpha,\\beta}^{LM}(\\mathbf{r})\\,\n              \\langle \\widetilde{\\psi}_{nk} | \\widetilde{p}_{\\alpha} \\rangle\n              \\langle \\widetilde{p}_{\\beta} | \\widetilde{\\psi}_{mk} \\rangle.\n}\n\nTo accelerate convergence with respect to\nLMAXFOCK\n, VASP uses a small trick: the contributions from the Hartree-Fock one-center terms are evaluated for the pseudo orbitals also only up to\nL\n=\nLMAXFOCK\n, whereas the one-center terms for the exact all-electron orbitals are evaluated up to the maximum required\nL\n(twice the angular quantum number of the partial wave with the highest\nl\n). The default is\nLMAXFOCK\n=4, and it might be necessary to increase this parameter, if the system contains f-electrons. Since this increases the computational load considerably (about factor 2), it is recommended to perform tests, whether the results are already reasonably converged using the default\nLMAXFOCK\n=4.\n\nTo be compatible w.r.t. old releases, VASP also reads the flag\nHFLMAX\nto the same effect as\nLMAXFOCK\n.",
    "related_tags": [
      "HFLMAX",
      "LMAXFOCKAE"
    ]
  },
  "LMAXMIX": {
    "default_value": "LMAXMIX = 2",
    "description": "LMAXMIX controls up to which l -quantum number the one-center PAW charge densities are passed through the charge density mixer and written to the CHGCAR file.",
    "detailed_description": "Higher\nl\n-quantum numbers (\nl\n>\nLMAXMIX\n) are not handled by the\ndensity mixer\n(these components of the one-center charge density are set to the value corresponding to the present orbitals). Usually, it is not necessary to increase\nLMAXMIX\n, but the following cases are exceptions:\n\nDFT+U calculations\nrequire, in many cases, an increase of\nLMAXMIX\nto 4 for\nd\n-electrons (or 6 for\nf\n-elements) to obtain fast convergence to the ground state.\n\nThe\nCHGCAR\nfile will contain the one-center PAW occupancy matrices up to\nLMAXMIX\n. When the\nCHGCAR\nfile is read and kept fixed in the course of the calculations (\nICHARG\n=11), the results will not necessarily be identical to a self-consistent run. The deviations will be large for DFT+U calculations. For the calculation of band structures within the DFT+U approach, it is strictly required to increase\nLMAXMIX\nto 4 for\nd\n-elements and to 6 for\nf\n-elements.\n\nSDFT calculations\nthat consider noncollinear magnetism often require slow mixing of the spin density up to 4 for\nd\n-elements and up to 6 for\nf\n-elements to obtain fast convergence to the ground state.",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "MAXMIX",
      "BMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC"
    ]
  },
  "LMAXPAW": {
    "default_value": "LMAXPAW = 2 l max , where l max is the maximum angular quantum number of the PAW partial waves in the POTCAR file.",
    "description": "The maximum l -quantum number for the evaluation of the one-center terms on the radial grids in the PAW method .",
    "detailed_description": "Useful settings for LMAXPAW are for instance:\n\nLMAXPAW\n= 0\n\nIn this case, only spherical terms are evaluated on the radial grid. This does not mean that aspherical terms are totally neglected, because the compensation charges are always expanded up to 2\nl\nmax\non the plane wave grid.\n\nLMAXPAW\n=-1\n\nFor\nLMAXPAW\n= -1\n, no one-center correction terms are evaluated on the radial support grid, which effectively means that the behavior of US-PP's is recovered with PAW input datasets. Usually, this allows for somewhat faster calculations, and this switch might be of interest for relaxations and molecular dynamics runs. Energies should be evaluated with the default setting for\nLMAXPAW\n. For spinpolarized calculations, results using LMAXPAW=-1 might differ significantly from conventional PAW calculations, hence the use of\nLMAXPAW\n= -1\nis not recommended for magnetic materials, spin-polarized molecules or atoms.\n\nExamples that use this tag",
    "related_tags": []
  },
  "LMAXTAU": {
    "default_value": "Default: LMAXTAU = 6 if LASPH =.TRUE. | = 0 else",
    "description": "LMAXTAU is the maximum l -quantum number included in the PAW one-center expansion of the kinetic energy density.",
    "detailed_description": "The PAW one-center expansion of the density has component up to and including\nL\n=2*\nl\nmax\n, where\nl\nmax\nis the\nl\n-quantum number of the partial waves on the\nPOTCAR\nfile, with the highest angular moment.\nIf the PAW one-center expansion of the density has component up to\nL\n, then the one-center expansion of the kinetic energy density has components up to\nL\n+2.\n\nThis means that as a rule of thumb, for\ns\n-elements:\nLMAXTAU\n=2, for\np\n:\nLMAXTAU\n=4, and for\nd\n:\nLMAXTAU\n=6.\nIf you are willing to live with the computational costs, the default for\nLMAXTAU\nshould be safe in all cases, except those involving\nf\n-elements.",
    "related_tags": [
      "METAGGA",
      "CMBJ",
      "CMBJA",
      "CMBJB",
      "LASPH",
      "LMIXTAU"
    ]
  },
  "LMIXTAU": {
    "default_value": "LMIXTAU = .FALSE.",
    "description": "send the kinetic-energy density through the density mixer as well.",
    "detailed_description": "In many cases, the\ndensity-mixing scheme\nworks well enough without passing the kinetic-energy density through the mixer. Therefore VASP uses\nLMIXTAU\n=.FALSE. per default. However, when the self-consistency cycle fails to converge for one of the algorithms exploiting\ndensity mixing\n, e.g,\nIALGO\n=38 or 48, we recommend setting\nLMIXTAU\n=.TRUE..",
    "related_tags": [
      "METAGGA",
      "LMAXTAU"
    ]
  },
  "LMODELHF": {
    "default_value": "LMODELHF = .FALSE.",
    "description": "LMODELHF selects dielectric-dependent hybrid functionals with full exchange in the short-range, and AEXX in the long-range.",
    "detailed_description": "LMODELHF\n=.TRUE. selects the range separated hybrid functional suggested in Ref.\n[1]\nand Ref.\n[2]\nunder the name dielectric-dependent hybrid functionals (DDH) and  doubly screened hybrid (DSH) functionals, respectively. These two hybrid functionals are both based on a common model for the dielectric function, but differ in the way how the range-separation parameters are obtained from first principles calculations. Their connection and performance have been discussed for instance in Ref.\n[3]\n. In principle,\nthey can be considered to be a smartly constructed approximation to COH-SEX (local Coulomb hole plus screened exchange),\nalbeit fulfilling many important constraints that the exact exchange correlation functional must observe.\n\nThe corresponding functional has been available in VASP since VASP.5.2 released in 2009 (before the two publications), although the gradient contribution had been erroneously implemented in all VASP.5 releases and is only correct in VASP.6. The related bug fix has been made available by the authors of Ref.\n[2]\n. The nonlocal exchange part of the functional has also been used and documented in Ref.\n[4]\nand is covered in\nImproving the dielectric function\n.\n\nTypically the user will need to set the following tags in the INCAR file:\n\nLHFCALC\n= .TRUE.\nLMODELHF\n= .TRUE.\nHFSCREEN\n= 1.26\nAEXX\n= 0.1\n\nIn this case,\nAEXX\nspecifies the amount of exact exchange in the long range, that is for short wave vectors (\nG\n→\n0\n{\\displaystyle  \\mathbf{G} \\to 0 }\n). In the short range, that is for large wave vectors, always the full nonlocal exchange is used. The\nHFSCREEN\ndetermines how quickly the nonlocal exchange changes from\nAEXX\nto 1.\n\nMind:\nIf\nLMODELHF\n=.TRUE., then\nLHFCALC\n=.TRUE. is automatically set.\n\nSpecifically, in VASP, the  Coulomb kernel\n4\nπ\ne\n2\n/\n(\nq\n+\nG\n)\n2\n{\\displaystyle  4 \\pi e^2 / (\\mathbf{q}+\\mathbf{G})^2}\nin the exact exchange is multiplied by a model for the dielectric function\nϵ\n−\n1\n(\nq\n+\nG\n)\n{\\displaystyle  \\epsilon^{-1} (\\mathbf{q}+\\mathbf{G})}\n:\n\nϵ\n−\n1\n(\nq\n+\nG\n)\n=\n1\n−\n(\n1\n−\nε\n∞\n−\n1\n)\nexp\n(\n−\n|\nq\n+\nG\n|\n2\n4\nμ\n2\n)\n{\\displaystyle  \\epsilon^{-1} (\\mathbf{q}+\\mathbf{G})=1-(1-{{\\varepsilon}_{\\infty}^{-1}})\\text{exp}(-\\frac{|\\mathbf{q+G}|^2}{4{\\mu}^2})}\n.\n\nwhere\nμ\n{\\displaystyle  \\mu  }\ncorresponds to\nHFSCREEN\n, and\nε\n∞\n−\n1\n{\\displaystyle  {{\\varepsilon}_{\\infty}^{-1}} }\nis specified by\nAEXX\n. In real space this correspond to a Coulomb kernel\n\nV\n(\nr\n)\n=\n(\n1\n−\n(\n1\n−\nε\n∞\n−\n1\n)\nerf\n(\nμ\nr\n)\n)\ne\n2\nr\n{\\displaystyle  V(r) =(1-(1-{{\\varepsilon}_{\\infty}^{-1}})\\text{erf}( {\\mu} r)) \\frac{e^2}{r} }\n.\n\nThe remaining part of the exchange is handled by an appropriate semi-local exchange correlation functional. For further detail we refer to the literature listed below.\n\nTypical values for\nHFSCREEN\nare listed in the table below\n\nAlP  1.24\nAlAs 1.18\nAlSb 1.13\nBN   1.7\nCdO  1.34\nCdS  1.19\nCdSe 1.18\nCdTe 1.07\nC    1.70\nGaN  1.39\nGaP  1.24\nGaAs 1.18\nGaSb 1.12\nGe   1.18\nInP  1.14\nInAs 1.09\nInSb 1.05\nLiF  1.47\nMgO  1.39\nSiC  1.47\nSi   1.26\nZnO  1.34\nZnS  1.27\nZnSe 1.20\nZnTe 1.12\n\nThese values have been obtained from fits of the dielectric function using the Nanoquanta kernel and partially self-consistent GW calculations as used in Ref.\n[5]\n. The values can be also estimated from simple dimensional scaling relations of the valence electron density. Furthermore band gap predictions are not very sensitive to the choice of\nHFSCREEN\n.",
    "related_tags": [
      "LHFCALC",
      "HFSCREEN",
      "AEXX",
      "Thomas-Fermi screening",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "LMONO": {
    "default_value": "LMONO = .FALSE.",
    "description": "LMONO switches on monopole-monopole corrections for the total energy.",
    "detailed_description": "The flag switches on monopole corrections for charged systems. The correction is calculated only a posteriori for the total energy.  No correction to the potential is calculated.\n\nTip:\nIf corrections for the potential are desired as well, please use\nLDIPOL\ninstead (when using\nLDIPOL\n, VASP automatically determines whether the system is charged and activates the monopole corrections automatically).\n\nThe primary use of this flag is for defect calculations in charged supercells, as well\nas charged 0D systems (molecules and atoms). VASP also automatically calculates\ncorrections to the total energy related to repeated dipoles (\nIDIPOL\n=4). \nThe user then needs to decide whether\nthose are sensible or not. Specifically, for super cells using periodic boundary conditions, \nit is often not possible to determine the dipole at the defect site accurately,\nwhereas for 0D systems (i.e. atoms and molecules) the dipole can be determined \naccurately.",
    "related_tags": [
      "Monopole Dipole and Quadrupole corrections",
      "NELECT",
      "EPSILON",
      "IDIPOL",
      "DIPOL",
      "LDIPOL",
      "EFIELD"
    ]
  },
  "LMP2LT": {
    "default_value": "Default: LMP2LT = .FALSE.",
    "description": "LMP2LT selects a Laplace transformed MP2 algorithm.",
    "detailed_description": "If\nLMP2LT\n=.TRUE. and\nALGO\n=ACFTDRK is set, a quartic scaling Laplace transformed MP2 algorithm is selected.\n[1]\n\nThis tag should be used in combination with\nKPAR\nto tweak parallelization as described in this\ntutorial\n.",
    "related_tags": [
      "NOMEGA",
      "ALGO",
      "LSMP2LT",
      "KPAR",
      "↑",
      "T. Schäfer, B. Ramberger, and G. Kresse, J. Chem. Phys. 146 , 104101 (2017)."
    ]
  },
  "LNABLA": {
    "default_value": "LNABLA = .FALSE.",
    "description": "LNABLA =.TRUE. evaluates the transversal expression for the frequency dependent dielectric matrix.",
    "detailed_description": "Usually VASP uses the\nlongitudinal expression for the frequency dependent dielectric matrix\n.\nIt is however possible to switch to the computationally somewhat simpler transversal expressions by selecting\nLNABLA\n=.TRUE. (Eqs. 17 and 20 in Ref.\n[1]\n).\nIn this simplification the imaginary part of the macroscopic dielectric function is given by\n\nϵ\nα\nβ\n(\n2\n)\n(\nω\n)\n=\n4\nπ\n2\ne\n2\nℏ\n4\nΩ\nω\n2\nm\ne\n2\nl\ni\nm\nq\n→\n0\n∑\nc\n,\nv\n,\nk\n2\nw\nk\nδ\n(\nϵ\nc\nk\n+\nq\n−\nϵ\nv\nk\n−\nω\n)\n×\n⟨\nu\nc\nk\n|\ni\n∇\nα\n−\nk\nα\n|\nu\nv\nk\n⟩\n⟨\nu\nc\nk\n|\ni\n∇\nβ\n−\nk\nβ\n|\nu\nv\nk\n⟩\n∗\n.\n{\\displaystyle \n\\epsilon^{(2)}_{\\alpha \\beta} (\\omega) = \\frac{4 \\pi^2 e^2  \\hbar^4}{\\Omega \\omega^2 m_e^2} \n \\mathrm{lim}_{\\mathbf{q} \\rightarrow 0} \\sum_{c,v, \\mathbf{k}} 2 w_\\mathbf{k} \n  \\delta( \\epsilon_{c\\mathbf{k+q}} - \\epsilon_{v\\mathbf{k}} - \\omega)  \n  \\times  \\langle u_{c\\mathbf{k}} | i{\\mathbf{\\nabla}_{\\alpha} - \\mathbf{k}}_{\\alpha} | u_{v\\mathbf{k}} \\rangle\n             \\langle u_{c\\mathbf{k}} | i{\\mathbf{\\nabla}_{\\beta}  - \\mathbf{k}}_{\\beta}  | u_{v\\mathbf{k}} \\rangle^*.\n}\n\nExcept for the purpose of testing, there is however hardly ever a reason\nto use the transversal expression, since it is less accurate.",
    "related_tags": [
      "LOPTICS",
      "CSHIFT"
    ]
  },
  "LNICSALL": {
    "default_value": "LNICSALL = .FALSE.",
    "description": "LNICSALL =.TRUE. calculates the NICS at the positions on the fine FFT grid NGXF x NGYF x NGZF .",
    "detailed_description": "Warning: Not yet released!\nThis page contains information about a feature that will be available in a future \nrelease of VASP. In other words, currently you cannot use it even with the latest version of VASP. The information may change significantly until it is released.\n\nLNICSALL\n=.TRUE. ensures that the FFT grid\nNGXF\nx\nNGYF\nx\nNGZF\nis used to calculate the NICS (nucleus-independent chemical shift) points. These chemical shieldings will be printed to\nNICS\n.\n\nMind:\nIf\nLNICSALL\n= True\nis set, and\nPOSNICS\nis also present,\nLNICSALL\nwill take precedent.",
    "related_tags": [
      "LCHIMAG",
      "NUCIND",
      "NICS"
    ]
  },
  "LNMR_SYM_RED": {
    "default_value": "LNMR_SYM_RED = .FALSE.",
    "description": "discard symmetry operations that are not consistent with the way k -space derivatives are calculated in the linear-response calculations of chemical shifts.",
    "detailed_description": "The star on which the\nk\n-space derivative is calculated is oriented along the cartesian directions in\nk\nspace. If the symmetry operations in\nk\nspace do not map this star onto itself, erroneous results can be obtained. To check for such operations, set\nLNMR_SYM_RED\n=.TRUE.. VASP then disregards such operations, and the resulting first Brillouin zone (IBZ) is larger. This is only relevant if the use of symmetry is switched on, i.e.\nISYM\n> 0\n. In case of any doubt, set\nLNMR_SYM_RED\n=.TRUE.\n\nWarning:\nIt matters how the real-space-lattice vectors are set up relative to the cartesian coordinates in the\nPOSCAR\nfile.\n\nIt determines the orientation of the\nk\n-space star and, hence, can affect the efficiency via the number of\nk\n-points in the IBZ.",
    "related_tags": [
      "LCHIMAG",
      "DQ",
      "ICHIBARE",
      "NLSPLINE"
    ]
  },
  "LNOAUGXC": {
    "default_value": "LNOAUGXC = .FALSE.",
    "description": "LNOAUGXC specifies if a METAGGA functional is evaluated with a density that is augmented or not.",
    "detailed_description": "The Kohn-Sham kinetic-energy density\n\nτ\nσ\n=\n1\n2\n∑\ni\n∇\nψ\ni\nσ\n∗\n⋅\n∇\nψ\ni\nσ\n{\\displaystyle \\tau_{\\sigma}=\\frac{1}{2}\\sum_{i}\\nabla\\psi_{i\\sigma}^{*}\\cdot\\nabla\\psi_{i\\sigma}}\n\nshould, in principle, be larger than the von Weizsäcker kinetic-energy density\n[1]\n\nτ\nσ\nW\n=\n|\n∇\nn\nσ\n|\n2\n8\nn\nσ\n.\n{\\displaystyle \\tau_{\\sigma}^{\\textrm{W}}=\\frac{\\left\\vert\\nabla n_{\\sigma}\\right\\vert^{2}}{8 n_{\\sigma}}.}\n\nHowever, this may not always be the case, particularly within the PAW spheres, when the pseudo density is augmented with the compensation charge. If\nLNOAUGXC\n=.TRUE. is set in the\nINCAR\nfile, then the pseudo density is not augmented, which should alleviate the breaking of the condition\nτ\nσ\nW\n<\nτ\nσ\n{\\displaystyle \\tau_{\\sigma}^{\\textrm{W}}<\\tau_{\\sigma}}\n.\n\nA violation of\nτ\nσ\nW\n<\nτ\nσ\n{\\displaystyle \\tau_{\\sigma}^{\\textrm{W}}<\\tau_{\\sigma}}\ncan make the calculations unstable, in particular with the TPSS family of functionals.\n\nMind:\nThis tag is available since VASP.6.5.0 and is a replacement of the compiler option\n-DnoAugXCmeta\nthat was available until VASP.6.4.3.\nThis option may negatively affect the results, therefore it should be used only for functionals, e.g., TPSS, for which the breaking of the condition\nτ\nσ\nW\n<\nτ\nσ\n{\\displaystyle \\tau_{\\sigma}^{\\textrm{W}}<\\tau_{\\sigma}}\nmay lead to numerical problems.",
    "related_tags": [
      "METAGGA",
      "LTBOUNDLIBXC"
    ]
  },
  "LNONCOLLINEAR": {
    "default_value": "Default: LNONCOLLINEAR = .False. | = .True. if spin-orbit coupling is included ( LSORBIT =.True.)",
    "description": "Switch on noncollinear magnetic calculations.",
    "detailed_description": "For noncollinear magnetic calculations, set\nLNONCOLLINEAR\n= True in the\nINCAR\nfile and use the\nvasp_ncl\nexecutable. The electronic minimization treats the full 2x2 spin density\n[1]\n\nn\nσ\nσ\n′\n(\nr\n)\n=\n∑\nn\n=\n1\nN\nψ\nn\nσ\n(\nr\n)\nψ\nn\nσ\n′\n∗\n(\nr\n)\n,\n{\\displaystyle \nn_{\\sigma\\sigma'}(\\mathbf{r}) = \\sum_{n=1}^N \\psi_{n\\sigma}(\\mathbf{r})\\psi^*_{n\\sigma'}(\\mathbf{r}),\n}\n\nwhich is written to the\nCHGCAR\nfile. In spinor space, the part of the spin density proportional to the 2x2 unit matrix corresponds to the charge density, and the part proportional to the vector of Pauli matrices is the magnetization density.\nThis enables the consideration of noncollinear magnetic structures within spin-density-functional theory.\nMAGMOM\nsets the initial magnetic moments. Write the final magnetic moments by setting\nLORBIT\n.\n\nIt is possible to\nrestart a noncollinear calculation\nfrom a previous nonmagnetic calculation (\nISPIN\n=1 and\nLNONCOLLINEAR\n=F) or spin-polarized calculation (\nISPIN\n=2) by reading\nWAVECAR\nor\nCHGCAR\nfiles. The magnetization of the spin-polarized calculation is interpreted to point along\nSAXIS\n(default: Cartesian direction\nz\n^\n{\\displaystyle \\hat z}\n). It is not possible to rotate the magnetic moment locally on selected atoms when restarting with a magnetization density. The magnetic configuration can globally be rotated with respect to the lattice by restarting with a different\nSAXIS\n.\n\nIn practice, we recommend performing noncollinear calculations in two steps:\n\nFirst, calculate the nonmagnetic ground state and generate a\nWAVECAR\nand a\nCHGCAR\nfile.\nSecond, read the\nWAVECAR\nand\nCHGCAR\nfile, and supply initial magnetic moments using the\nMAGMOM\ntag.\n\nWe recommend setting\nGGA_COMPAT\n= False and\nLASPH\n= True for noncollinear calculations since this improves the numerical precision of calculations using the generalized-gradient approximation (GGA).\n\nConsider setting\nAMIX_MAG\nand\nBMIX_MAG\nfor better convergence when using\ndensity mixing\n.\n\nThe\nI_CONSTRAINED_M\ntag can constrain the on-site magnetic moments.\n\nSupported as of VASP.4.5.\n\nImportant:\nFor noncollinear calculations\nISPIN\nis ignored. In VASP 6.5.0, the calculation will exit with an error message if\nISPIN\n=2 and\nMAGMOM\nis used in combination with the\nLNONCOLLINEAR\n=.TRUE.",
    "related_tags": [
      "MAGMOM",
      "LSORBIT",
      "SAXIS",
      "GGA_COMPAT",
      "LASPH",
      "AMIX_MAG",
      "BMIX_MAG",
      "↑",
      "Hobbs, D., G. Kresse, and J. Hafner, Fully unconstrained noncollinear magnetism within the projector augmented-wave method. , Phys. Rev. B 62 , 11556 (2000)."
    ]
  },
  "LOCAL_POTENTIAL": {
    "default_value": "PLUGINS/LOCAL_POTENTIAL = .False.",
    "description": "PLUGINS/LOCAL_POTENTIAL calls the Python plugin for the local potential interface for each SCF step",
    "detailed_description": "When\nPLUGINS/LOCAL_POTENTIAL\n=.TRUE., VASP calls the\nlocal_potential\nPython function at the end of each SCF step. \nThe primary use-case of this tag is to add a quantity on the real space grid to the local potential and a scalar quantity to the total energy of a VASP calculation through a Python plugin.\n\nExpected inputs\n\nThe\nlocal_potential\nPython function expects the following inputs,\n\ndef\nlocal_potential\n(\nconstants\n,\nadditions\n):\n\nwhere\nconstants\nand\nadditions\nand\nPython dataclasses\n.\nThe\nconstants\ndataclass consists of the following inputs, listed here with their associated\ndatatypes\n\n@dataclass\n(\nfrozen\n=\nTrue\n)\nclass\nConstantsLocalPotential\n:\nENCUT\n:\nfloat\nNELECT\n:\nfloat\nshape_grid\n:\nIntArray\nnumber_ions\n:\nint\nnumber_ion_types\n:\nint\nion_types\n:\nIndexArray\natomic_numbers\n:\nIntArray\nlattice_vectors\n:\nDoubleArray\npositions\n:\nDoubleArray\nZVAL\n:\nDoubleArray\ncharge_density\n:\nOptional\n[\nDoubleArray\n]\n=\nNone\nhartree_potential\n:\nOptional\n[\nDoubleArray\n]\n=\nNone\nion_potential\n:\nOptional\n[\nDoubleArray\n]\n=\nNone\ndipole_moment\n:\nOptional\n[\nDoubleArray\n]\n=\nNone\n\nNote that the\nINCAR\ntags are capitalized.\nshape_grid\nis a three dimensional integer array which stores the shape of the real space grid,\nNGXF\n,\nNGYF\nand\nNGZF\n,\nnumber_ions\nis the total number of ions listed in the\nPOSCAR\nfile,\nnumber_ion_types\nis the number of ion corresponding to each ion type in the convention of the\nPOSCAR\nfile,\nion_types\nstores the total number of ion types,\natomic_numbers\ncontains the atomic number for each atom type,\nlattice_vectors\nand\npositions\ncontain the lattice vectors and positions of the current SCF step\ncharge_density\n,\nhartree_potential\n,\nion_potential\ncontains the charge density, the hartree potential and the ion potential respectively on the real space grid.\ndipole_moment\nstores an array with three elements consisting of the dipole moment along x, y and z cartesian directions.\n\nMind:\nThe dipole moment is provided only if\nLDIPOL\n=.TRUE.\n\nThe\nadditions\ndataclass consists of the following modifiable outputs\n\n@dataclass\nclass\nAdditionsLocalPotential\n:\ntotal_energy\n:\nfloat\ntotal_potential\n:\nDoubleArray\n\nModifying quantities\n\nModify the quantities listed in additions by adding to them. For example, if you wanted to add one to every real space local potential grid point,\n\nimport\nnumpy\nas\nnp\ndef\nlocal_potential\n(\nconstants\n,\nadditions\n)\nadditions\n.\ntotal_potential\n+=\nnp\n.\nones\n(\nconstants\n.\nshape_grid\n)\n\nWarning:\nYou should not make modifications to quantities in\nconstants\n. We implemented some safeguards to prevent accidental modifications. Intentional changes will lead to erratic behavior because we may change the VASP code assuming these quantities are constant.",
    "related_tags": [
      "Plugins",
      "PLUGINS/FORCE_AND_STRESS",
      "PLUGINS/OCCUPANCIES",
      "PLUGINS/STRUCTURE"
    ]
  },
  "LOCPROJ": {
    "default_value": "LOCPROJ = None",
    "description": "The LOCPROJ tag specifies local functions on which the orbitals are projected. These projections are written to the PROJCAR file, LOCPROJ file , and vasprun.xml file.",
    "detailed_description": "Disambiguation\nMay also refer to\nLOCPROJ file\n.\n\nWhen the\nLOCPROJ\ntag is set, VASP performs the projection of the Kohn-Sham orbitals\n|\nψ\nn\nk\n⟩\n{\\displaystyle |\\psi_{n\\mathbf{k}}\\rangle}\nonto a localized orbitals basis\n|\nβ\nl\nm\nα\n⟩\n{\\displaystyle |\\beta^\\alpha_{lm}\\rangle}\nwhich can be written as\n\nP\nl\nm\nn\nk\nα\n≡\n⟨\nβ\nl\nm\nα\n|\nS\n|\nψ\nn\nk\n⟩\n=\n⟨\nβ\nl\nm\nα\n|\nψ\nn\nk\n⟩\n⏟\nP\nl\nm\nn\nk\nSOFT\n,\nα\n+\n∑\ni\nj\n⟨\nβ\nl\nm\nα\n|\np\n~\ni\n⟩\nQ\ni\nj\n⟨\np\n~\nj\n|\nψ\nn\nk\n⟩\n⏟\nP\nl\nm\nn\nk\nAUG\n,\nα\n.\n{\\displaystyle \nP^\\alpha_{lmn\\mathbf{k}} \n\\equiv \\langle \\beta_{lm}^{\\alpha}|S|\\psi_{n\\mathbf{k}}\\rangle\n= \\underbrace{\\langle \\beta_{lm}^{\\alpha}|\\psi_{n\\mathbf{k}}\\rangle}_{P^{\\text{SOFT},\\alpha}_{lmn\\mathbf{k}}} + \n\\underbrace{\\sum_{ij} \\langle \\beta^\\alpha_{lm}|\\tilde{p}_i\\rangle Q_{ij} \\langle \\tilde{p}_j | \\psi_{n\\mathbf{k}}\\rangle}_{P^{\\text{AUG},\\alpha}_{lmn\\mathbf{k}}}.\n}\n\nHere, the two terms on the right-hand side are called soft and augmentation part, respectively.\nS\n{\\displaystyle S}\nis the overlap matrix,\n\nS\n=\n1\n+\n∑\ni\nj\n|\np\n~\ni\n⟩\nQ\ni\nj\n⟨\np\n~\nj\n|\n.\n{\\displaystyle S = 1+\\sum_{ij} |\\tilde{p}_i\\rangle Q_{ij} \\langle \\tilde{p}_j|.}\n\nThe radial and the angular part of\nβ\nl\nm\nα\n(\nr\n)\n{\\displaystyle \\beta^\\alpha_{lm}(\\mathbf{r})}\nare described by the\nLOCPROJ\ntag, which comprises three parts separated by colons that are denoted as\n<sites>\n,\n<functions-Ylm-specs>\n, and\n<functions-radial-specs>\n. For instance, to perform the projection onto a hydrogen-like\n1s\nfunction on the first ionic position specified in the\nPOSCAR\nfile, the tag reads\n\nLOCPROJ = 1 : s : Hy\n\nSpecifying the local basis\n\n<sites>\n: The sites on which the local functions are centered.\n\nIt is specified either using the index of the ionic positions as defined in the\nPOSCAR\nfile, or in terms of direct coordinates of the real space lattice. For instance,\n1 2 6-8\nwill select sites 1, 2, 6, 7, and 8 as defined in the\nPOSCAR\nfile. On the other hand,\n(0.5, 0, 0)\nspecifies the position in terms of direct coordinates of the real space lattice. The modes of the specification can be mixed as well, e.g.,\n1 (0.5, 0, 0) 8\n.\n\n<functions-Ylm-specs>\n: The angular character of the local functions on the specified sites.\n\nPossible specifications are presented in the table below.\n\ns\np\npy\npz\npx\nd\ndxy\ndyz\ndz2\ndxz\ndx2-y2\nf\nfy(3x2-y2)\nfxyz\nfyz2\nfz3\nfxz2\nfz(x2-y2)\nfx(x2-3y2)\nsp\nsp-1\nsp-2\nsp2\nsp2-1\nsp2-2\nsp2-3\nsp3\nsp3-1\nsp3-2\nsp3-3\nsp3-4\nsp3d\nsp3d-1\nsp3d-2\nsp3d-3\nsp3d-4\nsp3d-5\nsp3d2\nsp3d2-1\nsp3d2-2\nsp3d2-3\nsp3d2-4\nsp3d2-5\nsp3d2-6\n\nFor more details, have a look at the section on\nangular functions\n. These functions are consistent with the definition of the\ninitial guesses\nused by\nWANNIER90\n(see section 3.4 of the\nWANNIER90 manual\n).\n\nIt is possible to select multiple characters by creating a list separated by spaces, e.g.,\np sp-1 dxy\nperforms a projection for all\np\nfunctions (≡\np\nx\n,\np\ny\n, and\np\nz\n), an\nsp\n-1 function, and a\nd\nxy\nfunction on all sites specified by\n<sites>\n.\n\n<functions-radial-specs>\n: The radial dependency of the local functions.\n\nThere are three options:\nPr\n: use the PAW projectors\nPs\n: use the PAW pseudo partial waves\nHy\n: use hydrogen-like (Slater type) functions (see section 3.4 of the\nWANNIER90 manual\n)\n\nMind:\nFor\nPr\nor\nPs\n, which are radial functions derived from the PAW datasets, one can only specify spherical harmonics with\nthe same angular moment l\nin the\n<functions-Ylm-specs>\npart. This means,\ns\n,\np\n,\nd\n,\nf\n, and/or their respective separate constituents.\n\nThe radial specifiers can optionally be modified using the following modification statements:\nPr\n[\nn\nth\n-of-l\n[\nspecies-number\n] ]\nn\nth\n-of-l\n: Uses the radial function of the\nn\nth\nprojector with the angular moment specified in\n<functions-Ylm-specs>\n. The local basis of our PAW datasets typically contains 2 projectors per angular moment. By default, the projector that corresponds to the highest bound state of the relevant angular moment will be used.\n\nspecies-number\n: Specifies from which PAW dataset in the current\nPOTCAR\nfile the radial functions should be derived. When the positions of the local functions are specified using the ionic site indices of the\nPOSCAR\nfile, the code will default to the corresponding atomic types.\n\nPs\n[\nn\nth\n-of-l\n[\nspecies-number\n] ]\nn\nth\n-of-l\n: Uses the radial function of the\nn\nth\npseudo partial wave with the angular moment specified in\n<functions-Ylm-specs>\n. The local basis of our PAW datasets typically contains 2 pseudo partial waves per angular moment. By default, the pseudo partial wave that corresponds to the highest bound state of the relevant angular moment is used.\n\nspecies-number\n: Specifies from which PAW dataset in the current\nPOTCAR\nfile the radial functions should be derived. When the positions of the local functions are specified using the ionic site indices of the\nPOSCAR\nfile, the default is the corresponding atomic type.\n\nHy\n[\nn\n[\nα\n] ]\nn\n: Main quantum number of the hydrogen-like radial functions. Default:\nn=1\n.\nα\n: controls the diffusivity of the\nradial functions\n(\nα=Z/a\n0\nin Å\n-1\n). Default:\nα\n=1.0 Å\n-1\n.\n\nn\ns type Hydrogen radial wave functions\nn\n{\\displaystyle n}\nR\n(\nr\n)\n{\\displaystyle R(r)}\n1\n{\\displaystyle 1}\n2\nα\n3\n/\n2\nexp\n⁡\n(\n−\nα\nr\n)\n{\\displaystyle 2\\alpha^{3/2}\\exp(-\\alpha r)}\n2\n{\\displaystyle 2}\n1\n2\n2\nα\n3\n/\n2\n(\n2\n−\nα\nr\n)\nexp\n⁡\n(\n−\nα\nr\n/\n2\n)\n{\\displaystyle \\frac{1}{2\\sqrt 2}\\alpha^{3/2}(2-\\alpha r)\\exp(-\\alpha r /2)}\n3\n{\\displaystyle 3}\n4\n27\nα\n3\n/\n2\n(\n1\n−\n2\nα\nr\n/\n3\n+\n2\nα\n2\nr\n2\n/\n27\n)\nexp\n⁡\n(\n−\nα\nr\n/\n3\n)\n{\\displaystyle {\\sqrt \\frac{4}{27}}\\alpha^{3/2}(1-2\\alpha r/3+2\\alpha^2 r^2/27)\\exp(-\\alpha r /3)}\n\nThis is consistent with the definition of the\ninitial guesses\nused by\nWANNIER90\n(section 3.4 of the\nWANNIER90 manual\n).\n\nImportant:\nDifferent projections have to be specified in multiple lines, as the\nLOCPROJ\ntag can only be set once.\n\nFor instance,\n\nLOCPROJ = \"1 : s : Hy 2\n           1 3 : dxy : Ps 2 3\"\n\nperforms the projection onto a hydrogen-like\n2s\nfunction and a\nd\nxy\npseudo partial wave (2\nnd\nd\nchannel of atomic species 3) on ionic site 1, and a\nd\nxy\npseudo partial wave (identical type) on site 3.\n\nDeprecated:\nFor VASP versions <= 6.1.x, multiple occurrences of the\nLOCPROJ\ntag are allowed and taken into account.\n\nFor other tags, the second instance of a tag in the\nINCAR\nis normally ignored. However, here\n\nLOCPROJ = 1 : s : Hy 2\nLOCPROJ = 1 3 : dxy : Ps 2 3\n\nis possible.\n\nExample for LOCPROJ tag\n\nAs mentioned above, to put a hydrogen-like\n1s\nfunction on the first ionic position specified in the\nPOSCAR\nfile, the tag reads\n\nLOCPROJ = 1 : s : Hy\n\nin the\nINCAR\nfile. To change this into a\n2s\nfunction, specify\n\nLOCPROJ = 1 : s : Hy 2\n\nTo project the orbitals onto the PAW projectors of the valence atomic\nd\nxy\n-states of the atoms on sites 1 and 3, write\n\nLOCPROJ = 1 3 : dxy : Pr\n\nThis will only work if the atoms on these sites have valence atomic\nd\n-states. Otherwise, the necessary projectors will not be available in the relevant PAW datasets, and the code will exit in error at startup.\n\nTo forcibly use the radial function of the second\nd\nchannel, write\n\nLOCPROJ = 1 3 : dxy : Pr 2\n\nAgain, provided the PAW dataset(s) contain more than one\nd\nchannel.\nSimilarly, one can project onto the pseudo partial waves of the second\nd\nchannel in the PAW dataset(s) by writing\n\nLOCPROJ = 1 3 : dxy : Ps 2\n\nTo project onto the functions of the third PAW dataset in the\nPOTCAR\nfile, specify\n\nLOCPROJ = 1 3 : dxy : Ps 2 3\n\nLOCPROJ\nfile\n\nThe\nLOCPROJ\nfile contains information about the projections of the Bloch states onto the localized orbitals specified with the\nLOCPROJ\ntag described above.\n\nThe file contains a header with the information about all projections:\n\nISITE: Index of the site in the\nPOSCAR\nfile.\nR: Position in fractional coordinates.\nRadial type: Is one of \"PAW projector\",\"PS partial wave\", \"Hydrogen-like\" depending on the choice of\nPr\n,\nPs\nor\nHy\n, respectively.\nAngular type: Angular character of the local functions, as presented in the table above in\n<functions-Ylm-specs>\n.\n\nEach Kohn-Sham orbital is identified by the spin, k point, band index, eigenvalue, and occupation.\nFor each of these Kohn-Sham orbitals, VASP writes the real and imaginary part of the projection onto localized orbitals\n⟨\nβ\nl\nm\nα\n|\nS\n|\nψ\nn\nk\n⟩\n{\\displaystyle \\langle \\beta_{lm}^{\\alpha}|S|\\psi_{n\\mathbf{k}}\\rangle}\n. Note that for\nvasp_gam\nonly the real part exists.",
    "related_tags": [
      "LORBIT",
      "PROJCAR"
    ]
  },
  "LOPTICS": {
    "default_value": "LOPTICS = .FALSE.",
    "description": "LOPTICS =.TRUE. calculates the frequency dependent dielectric matrix after the electronic ground state has been determined.",
    "detailed_description": "The imaginary part is determined by a summation over empty states using the equation:\n\nϵ\nα\nβ\n(\n2\n)\n(\nω\n)\n=\n4\nπ\n2\ne\n2\nΩ\nl\ni\nm\nq\n→\n0\n1\nq\n2\n∑\nc\n,\nv\n,\nk\n2\nw\nk\nδ\n(\nϵ\nc\nk\n−\nϵ\nv\nk\n−\nω\n)\n×\n⟨\nu\nc\nk\n+\ne\nα\nq\n|\nu\nv\nk\n⟩\n⟨\nu\nv\nk\n|\nu\nc\nk\n+\ne\nβ\nq\n⟩\n{\\displaystyle \n\\epsilon^{(2)}_{\\alpha \\beta}\\left(\\omega\\right) = \\frac{4\\pi^2 e^2}{\\Omega} \n\\mathrm{lim}_{q \\rightarrow 0} \\frac{1}{q^2} \\sum_{c,v,\\mathbf{k}} 2 w_\\mathbf{k} \\delta( \\epsilon_{c\\mathbf{k}} - \\epsilon_{v\\mathbf{k}} - \\omega)\n  \\times   \\langle u_{c\\mathbf{k}+\\mathbf{e}_\\alpha q}  | u_{v\\mathbf{k}} \\rangle \n             \\langle u_{v\\mathbf{k}} | u_{c\\mathbf{k}+\\mathbf{e}_\\beta q} \\rangle\n}\n\nhere the indices\nc\nand\nv\nrefer to conduction and valence band states respectively, and\nu\nc\nk\nis the cell periodic part of the orbitals at the k-point\nk\n. The real part of the dielectric tensor  ε\n(1)\nis obtained by the usual Kramers-Kronig\ntransformation\n\nϵ\nα\nβ\n(\n1\n)\n(\nω\n)\n=\n1\n+\n2\nπ\nP\n∫\n0\n∞\nϵ\nα\nβ\n(\n2\n)\n(\nω\n′\n)\nω\n′\nω\n′\n2\n−\nω\n2\n+\ni\nη\nd\nω\n′\n{\\displaystyle \n\\epsilon^{(1)}_{\\alpha \\beta} (\\omega) = 1 + \\frac{2}{ \\pi} P \\int_0^{\\infty} \n \\frac{ \\epsilon^{(2)}_{\\alpha \\beta} (\\omega') \\omega'}{ \\omega'^2- \\omega^2 + i \\eta } d \\omega'\n}\n\nwhere\nP\ndenotes the principle value. The method is explained in detail in the paper by Gajdoš\net al.\n(see Eqs. 15, 29, and 30).\n[1]\nThe complex shift η is determined by the parameter\nCSHIFT\n.\n\nNote that local field effects, i.e. changes of the cell periodic part of the potential are neglected in this approximation.  These can be evaluated using either the implemented density functional perturbation theory (\nLEPSILON\n=.TRUE.), or the GW routines.\n\nThe method selected using\nLOPTICS\n=.TRUE. requires an appreciable number of empty conduction band states. Reasonable results are usually only obtained, if the parameter\nNBANDS\nis roughly doubled or tripled in the\nINCAR\nfile with respect to the VASP default.\nFurthermore it is emphasized that the routine works properly even for\nHF and screened exchange type calculations and hybrid functionals\n. In this case, finite differences are used to determine the derivatives of the Hamiltonian with respect to\nk\n.\n\nNote that the number of frequency grid points is determined by the parameter\nNEDOS\n. In many cases it is desirable to increase this parameter significantly from its default value. Values around\nNEDOS\n=2000 are strongly recommended.\n\nVASP posses multiple other routines to calculate the frequency dependent dielectric function.\nSpecifically, one can use\nALGO\n= TDHF (Casida/\nBSE calculations\n),\nALGO\n= GW (\nGW calculations\n) and\nALGO\n= TIMEEV (\nTime Evolution\n: apply a delta kick and follow the induced dipoles).\nCompared to\nLOPTICS\n=.TRUE., all those routines have the advantage to include\neffects beyond the independent particle approximation, however, they are usually\nalso much more expensive than\nLOPTICS\n=.TRUE.\n\nSpectral broadening\n\nThe dielectric function calculated with\nLOPTICS\nincludes broadening due to the smearing method\nISMEAR\nand the Lorentzian broadening due to the complex shift in the Kramers-Kronig transformation. For example, the combination of\nLOPTICS\n=.TRUE.  and\nISMEAR\n=0  produces the dielectric function broadened by a Gaussian with the width\nSIGMA\nand a Lorentzian with the width\nCSHIFT\n. To avoid using two different broadening methods simultaneously and only include the Lorentzian broadening, one should set\nSIGMA\nto a much smaller value than\nCSHIFT\n.\n\nNote, that the imaginary part of the dielectric function is also broadened by the Lorentzian as long as\nCSHIFT\nis not too small, in which case a warning is printed. This means that first a Gaussian broadening is added directly when the imaginary part of the dielectric function is calculated, and successively afterwards a Loretzian broadening is applied. Mind, that this especially affects the life time, i.e. long tails of the transitions, and can influence the dielectric function significantly and produce artifacts if the cut-off frequency\nOMEGAMAX\nis chosen close to a large transition element.\n\nWarning:\nNote that\nLOPTICS\n= .TRUE. with\nISMEAR\n= -2 is currently not supported.\n\nMind:\nFurthermore the combination of\nLOPTICS\n= .TRUE. and\nISMEAR\nselecting the tetrahedron method is only supported as of VASP 6.3.",
    "related_tags": [
      "CSHIFT",
      "LNABLA",
      "LEPSILON",
      "Time Evolution",
      "WPLASMAI"
    ]
  },
  "LORBIT": {
    "default_value": "LORBIT = 0",
    "description": "Selects a projection method onto local quantum numbers ( l m {\\displaystyle lm} ) and writes PROCAR / PROOUT file.",
    "detailed_description": "When\nLORBIT\nis set, VASP performs a post-processing step of the Kohn-Sham (KS) orbitals to decompose the KS orbitals into local quantum numbers (\nl\nm\n{\\displaystyle lm}\n) and obtain local properties, e.g., the on-site charge density or on-site magnetic moments due to the spin degrees of freedom. The decomposition is achieved by means of one of several projection methods selected by\nLORBIT\n. All these projections rely on the fact that most of the charge density is close to the ion center, and interstitial regions separate them well. This is merely a qualitative approach in contrast to performing a\nwannierization\nin order to obtain a localized basis, but often it serves as a good estimate.\n\nTip:\nAs this is a post-processing step,\nLORBIT\ncan be added/changed when restarting a converged calculation. To this end, set\nALGO\n=None and the desired\nLORBIT\n, and restart from\nWAVECAR\n.\n\nFor VASP version < 6 with\nLORBIT\n>= 11 and\nISYM\n= 2, see\nknown issues\n.\n\nProjection methods\n\nSee the table for an overview:\n\nLORBIT\nRWIGS\ntag\nfiles written\n0\nrequired\nDOSCAR\nand\nPROCAR\n1\nrequired\nDOSCAR\nand\nlm\n-decomposed\nPROCAR\n2\nrequired\nDOSCAR\nand\nlm\n-decomposed\nPROCAR\n+ phase factors\n5\nrequired\nDOSCAR\nand\nPROOUT\n10\nignored\nDOSCAR\nand\nPROCAR\n11\nignored\nDOSCAR\nand\nlm\n-decomposed\nPROCAR\n12\nignored\nDOSCAR\nand\nlm\n-decomposed\nPROCAR\n+ phase factors (not recommended)\n13\nignored\nDOSCAR\nand\nlm\n-decomposed\nPROCAR\n+ phase factors, choose best projector for each band (not recommended)\n14\nignored\nDOSCAR\nand\nlm\n-decomposed\nPROCAR\n+ phase factors, choose single projector for interval\nEMIN\n,\nEMAX\n\nFor\nLORBIT\n< 10\n\nThe projection is onto spherical harmonics at each ionic site within a sphere defined by\nRWIGS\n. The radius must be specified for each atomic species, and there is some uncertainty introduced depending on the size of the sphere.\n\nFor\nLORBIT\n>= 10\n\nThe projection uses the projector functions that are provided by the\nPAW method\n. This is, of course, still a qualitative approach because also, for the PAW projectors, the radius was somehow defined, and it is not guaranteed to be the best choice for that particular system as it depends on the chemical composition and crystal or molecular structure.\n\nPhase factors\n\nFor\nLORBIT\n>=12:\nThe\nphase factors\nwritten by VASP can usually only be used as a qualitative measure of the projection of the orbitals into the atomic sphere. The main issue is that most VASP\nPOTCAR\nfiles have two or three projectors per\nl\n{\\displaystyle l}\n-quantum number, and projecting an orbital onto two projectors will yield two complex numbers. VASP combines these two numbers into a single number. The precise algorithms differ in different versions of VASP, and we recommend that you inspect the source code for more details. From vasp.6 onward, an improved scheme has been implemented and can be selected using\nLORBIT\n=14. In this case, VASP first selects a single projector for each\nl\n{\\displaystyle l}\n-quantum number by linearly combining all projectors with the same\nl\n{\\displaystyle l}\n-quantum number. This is done in such a way that the new projector is optimally chosen to represent the calculated orbitals in the energy interval specified by\nEMAX\nand\nEMIN\n. In the second step, VASP projects onto these optimized projectors, yielding a single complex number for each orbital, site and\nl\n{\\displaystyle l}\n-quantum number, which is written to the\nPROCAR\nfile. For details we also refer to\n[1]\n.\nLORBIT\n=12 should no longer be used except for qualitative calculations. LORBIT=13 chooses the projectors also automatically, but allows for different optimal linear combinations for each orbital.\nNote that this is generally not desirable, since the  resultant projection is not compatible with the required properties of a projection operator (a projection operator needs to use energy and orbital independent projectors).\nHence, do not use\nLORBIT\n=13 for anything but a qualitative analysis.\n\nLORBIT\n=13 and\nLORBIT\n=14 are only supported by version >=5.4.4.\n\nOn-site partial charge densities and magnetization\n\nThe partial charge densities can be found in the\nOUTCAR\n\ntotal charge     \n\n# of ion       s       p       d       tot\n------------------------------------------\n    1        1.514   0.000   0.000   1.514\n    2        0.123   0.345   0.000   0.468\n\nHere, the first column corresponds to the ion index\nα\n{\\displaystyle \\alpha}\n, the s, p, d,... columns correspond to the partial charges for\nl\n=\n0\n,\n1\n,\n2\n,\n⋯\n{\\displaystyle l=0,1,2,\\cdots}\ndefined as\n\nρ\nα\nl\n=\n1\nN\nk\n∑\nn\nk\nf\nn\nk\n∑\nm\n=\n−\nl\nl\n|\n⟨\nY\nl\nm\nα\n|\nϕ\nn\nk\n⟩\n|\n2\n{\\displaystyle \\rho_{\\alpha l}=\\frac{1}{N_{\\bf k}} \\sum_{n{\\bf k}}f_{n{\\bf k}} \\sum_{m=-l}^{l}|\\langle Y_{lm}^{\\alpha}|\\phi_{n\\mathbf{k}}\\rangle|^2\n}\n\nThe\n⟨\nY\nl\nm\nα\n|\nϕ\nn\nk\n⟩\n{\\displaystyle \\langle Y_{lm}^{\\alpha}|\\phi_{n\\mathbf{k}}\\rangle}\nare obtained from the projection of the (occupied) KS orbitals\n|\nϕ\nn\nk\n⟩\n{\\displaystyle |\\phi_{n{\\bf k}}\\rangle}\nonto spherical harmonics that are non zero within spheres of a radius\nRWIGS\ncentered at ion\nα\n{\\displaystyle \\alpha}\nand the last column is the sum\n∑\nl\nρ\nα\nl\n{\\displaystyle \\sum_{l}\\rho_{\\alpha l}}\n.\n\nNote that depending on the system, an \"f\" column is written as well.\n\nIn case of spin-polarized magnetic calculations (\nISPIN\n=2), the partial magnetization densities are written to the\nOUTCAR\n\nmagnetization (x)\n \n# of ion       s       p       d       tot\n------------------------------------------\n    1        0.000   0.000   0.000   0.000\n    2        0.000   0.245   0.000   0.245\n\nHere, the magnetization density is calculated from the difference in the up and down spin channel\nm\nz\nα\nl\n=\nρ\nα\nl\n↑\n−\nρ\nα\nl\n↓\n{\\displaystyle m^{\\alpha l}_z = \\rho_{\\alpha l}^{\\uparrow}-\\rho_{\\alpha l}^{\\downarrow}\n}\nAlthough the direction of the magnetization densities is meaningless in a spin-polarized calculation (no spin-orbit coupling, see\nLSORBIT\n), here the projection axis is the z-axis. This is consistent withe the behavior upon restarting a noncollinear calculation from a spin-polarized one with default\nSAXIS\n.\n\nIn case of noncollinear calculations (\nLNONCOLLINEAR\n=.TRUE.), the lines after \"total charge\" correspond to the diagonal average\n\nρ\nα\nl\n↑\n↑\n−\nρ\nα\nl\n↓\n↓\n2\n{\\displaystyle  \\frac{\\rho_{\\alpha l}^{\\uparrow\\uparrow} - \\rho_{\\alpha l}^{\\downarrow \\downarrow}}{2} }\nof the density tensor\n\nρ\nα\nl\n=\n(\nρ\nα\nl\n↑\n↑\nρ\nα\nl\n↑\n↓\nρ\nα\nl\n↓\n↑\nρ\nα\nl\n↓\n↓\n)\n,\n{\\displaystyle \n\\rho_{\\alpha l} = \\left(\\begin{matrix}\n  \\rho_{\\alpha l}^{\\uparrow \\uparrow }   &  \\rho_{\\alpha l}^{\\uparrow \\downarrow}     \\\\\n  \\rho_{\\alpha l}^{\\downarrow \\uparrow}  &  \\rho_{\\alpha l}^{\\downarrow \\downarrow}   \\\\\n \\end{matrix}\\right), \n}\n\nwhich is determined from the projected components\n\nρ\nα\nl\nμ\nν\n=\n1\nN\nk\n∑\nn\nk\nf\nn\nk\n∑\nm\n=\n−\nl\nl\n⟨\nχ\nn\nk\nμ\n|\nY\nl\nm\nα\n⟩\n⟨\nY\nl\nm\nα\n|\nχ\nn\nk\nν\n⟩\n{\\displaystyle \n\\rho^{\\mu\\nu}_{\\alpha l} = \\frac{1}{N_{\\bf k}} \\sum_{n{\\bf k}}f_{n{\\bf k}} \\sum_{m=-l}^{l} \n\\langle \\chi_{n {\\bf k}}^\\mu | Y_{lm}^\\alpha \\rangle\n\\langle  Y_{lm}^\\alpha | \\chi_{n {\\bf k}}^\\nu \\rangle \n}\n\nof the spinor\n|\nΨ\nn\nk\n⟩\n=\n(\nχ\nn\nk\n↑\nχ\nn\nk\n↓\n)\n{\\displaystyle |\\Psi_{n{\\bf k}}\\rangle=\\left(\\begin{matrix}\\chi_{n{\\bf k}}^\\uparrow \\\\\\chi_{n{\\bf k}}^\\downarrow \\end{matrix}\\right)}\n\nSimilarly, the lines after \"magnetization (x)\", \"magnetization (y)\", and \"magnetization (z)\"correspond to the partial magnetization density\n\nm\nα\nl\nj\n=\n1\n2\n∑\nμ\n,\nν\n=\n1\n2\nσ\nμ\nν\nj\nρ\nα\nl\nμ\nν\n.\n{\\displaystyle \nm_{\\alpha l}^j = \\frac{1}{2}\\sum_{\\mu,\\nu=1}^2 \\sigma^j_{\\mu \\nu} \\rho_{\\alpha l}^{\\mu \\nu}.\n}\n\nprojected onto Pauli matrices\n{\nσ\n1\n{\\displaystyle \\{\\sigma_1}\n,\nσ\n2\n{\\displaystyle \\sigma_2}\n,\nσ\n3\n}\n{\\displaystyle \\mathbf{\\sigma}_3\\}}\n. By default, this corresponds to Cartesian directions\nσ\n1\n=\nx\n^\n{\\displaystyle \\sigma_1=\\hat x}\n,\nσ\n2\n=\ny\n^\n{\\displaystyle \\sigma_2 =\\hat y}\n,\nσ\n3\n=\nz\n^\n{\\displaystyle \\sigma_3 = \\hat z}\n, but the orientation can be changed using\nSAXIS\n.\n\nReferences\n\n↑\nM. Schüler, O.E. Peil, G.J. Kraberger, R. Pordzik, M. Marsman, G. Kresse, T.O. Wehling, and M. Aichhorn, J. Phys.: Condens. Matter\n30\n, 475901 (2018).",
    "related_tags": [
      "RWIGS",
      "PROCAR",
      "PROOUT",
      "DOSCAR"
    ]
  },
  "LORBMOM": {
    "default_value": "LORBMOM = .FALSE.",
    "description": "LORBMOM specifies whether the orbital moments are written out or not (in a calculation using LSORBIT =.TRUE.).",
    "detailed_description": "If\nLORBMOM\n=.TRUE. is set VASP will  use the projectors of the PAW potentials to calculate the\norbital moment within the PAW spheres, and write them to the\nOUTCAR\nfile.",
    "related_tags": [
      "LSORBIT",
      "LORBIT"
    ]
  },
  "LPARD": {
    "default_value": "LPARD = .FALSE.",
    "description": "Determines whether partial (band and/or k -point-decomposed) charge densities are evaluated.",
    "detailed_description": "An\nLPARD\nrun is a postprocessing step that requires a pre-converged calculation. It writes the partial density, or multiple partial charge densities, to one\nPARCHG\nfile or several PARCHG.*.* files, depending on the setting of\nLSEPB\nand\nLSEPK\n.\nIf\nLPARDH5\n= .TRUE., the output is redirected from\nPARCHG\nto\nvaspout.h5\n.\n\nWarning:\nThe orbitals read from the\nWAVECAR\nfile must be converged in a prior VASP run.\n\nWarning:\nLPARD\nis not supported for noncollinear calculations (\nLNONCOLLINEAR\n=true).\n\nThere are various ways to divide the partial charge density. You can pick the contributing bands either by index (refer to\nNBMOD\nand\nIBAND\n) or by energy range (refer to\nEINT\n), and select contributing\nk\npoints through\nKPUSE\n.\n\nMind:\nIf only the\nLPARD\ntag is set, without any other tags to specify the separation of charge, then the\nNBMOD\ntag defaults to -1. The valence charge density (without the augmentation charges) is then written to the\nCHGCAR\nfile, and no other partial charge output is generated.",
    "related_tags": [
      "IBAND",
      "EINT",
      "NBMOD",
      "KPUSE",
      "LSEPB",
      "LSEPK",
      "LPARDH5",
      "PARCHG",
      "vaspout.h5",
      "Band-decomposed charge densities"
    ]
  },
  "LPARDH5": {
    "default_value": "LPARDH5 = .FALSE.",
    "description": "LPARDH5 determines whether the partial charges are written to PARCHG or vaspout.h5 .",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nPartial charges\ncan be calculated as a postprocessing step when\nLPARD\n= .TRUE.. The output is written to one or several\nPARCHG\nfiles if\nLPARDH5\n=.FALSE., and to\nvaspout.h5\nif\nLPARDH5\n=.TRUE.. If\nNBMOD\n= -1, the setting of\nLPARD\nis irrelevant. Instead of a\nPARCHG\nfile, or a partial_charges group in the\nvaspout.h5\nhdf5 file, a\nCHGCAR\nfile\nwithout\naugmentation charges will be written.\n\nIf the output is redirected to\nvaspout.h5\n,\npy4vasp\ncan be used to analyze the partial charge density and to simulate STM pictures.",
    "related_tags": [
      "LPARD",
      "LWAVEH5",
      "LCHARGH5",
      "IBAND",
      "EINT",
      "NBMOD",
      "KPUSE",
      "LSEPB",
      "LSEPK",
      "PARCHG",
      "band-decomposed charge densities"
    ]
  },
  "LPEAD": {
    "default_value": "LPEAD = .FALSE.",
    "description": "for LPEAD =.TRUE., the derivative of the cell-periodic part of the orbitals w.r.t. k , |∇ k u n k ⟩, is calculated using finite differences (\"perturbation expansion after discretization\" (PEAD) [1] [2] ).",
    "detailed_description": "The derivative of the cell-periodic part of the orbitals w.r.t.\nk\n,\nk\n, |∇\nk\nu\nn\nk\n⟩, may be written as:\n\n|\n∇\nk\nu\n~\nn\nk\n⟩\n=\n∑\nn\n≠\nn\n′\n|\nu\n~\nn\n′\nk\n⟩\n⟨\nu\n~\nn\n′\nk\n|\n∂\n[\nH\n(\nk\n)\n−\nϵ\nn\nk\nS\n(\nk\n)\n]\n∂\nk\n|\nu\n~\nn\nk\n⟩\nϵ\nn\nk\n−\nϵ\nn\n′\nk\n{\\displaystyle \n|\\mathbf{\\nabla_{k}} \\tilde{u}_{n\\mathbf{k}} \\rangle =\n\\sum_{n\\neq n'}\n\\frac{| \\tilde{u}_{n'\\mathbf{k}} \\rangle \\langle \\tilde{u}_{n'\\mathbf{k}} |\n\\frac{\\partial\\left[H(\\mathbf{k})-\\epsilon_{n\\mathbf{k}}S(\\mathbf{k})\\right]}{\\partial \\mathbf{k}}\n| \\tilde{u}_{n\\mathbf{k}} \\rangle}{\\epsilon_{n\\mathbf{k}}-\\epsilon_{n'\\mathbf{k}}}\n}\n\nwhere H(\nk\n) and S(\nk\n) are the Hamiltonian and overlap operator for the cell-periodic part of the orbitals, and the sum over\nn\n´ must include a sufficiently large number of unoccupied states.\n\nIt may also be found as the solution to the following linear Sternheimer equation (see\nLEPSILON\n):\n\n[\nH\n(\nk\n)\n−\nϵ\nn\nk\nS\n(\nk\n)\n]\n|\n∇\nk\nu\n~\nn\nk\n⟩\n=\n−\n∂\n[\nH\n(\nk\n)\n−\nϵ\nn\nk\nS\n(\nk\n)\n]\n∂\nk\n|\nu\n~\nn\nk\n⟩\n{\\displaystyle \n\\left[H(\\mathbf{k})-\\epsilon_{n\\mathbf{k}}S(\\mathbf{k})\\right]\n|\\mathbf{\\nabla_{k}} \\tilde{u}_{n\\mathbf{k}} \\rangle\n=-\\frac{\\partial\\left[H(\\mathbf{k})-\\epsilon_{n\\mathbf{k}}S(\\mathbf{k})\\right]}\n{\\partial \\mathbf{k}}|\\tilde{u}_{n\\mathbf{k}} \\rangle\n}\n\nAlternatively one may compute\n∇\nk\nu\n~\nn\nk\n{\\displaystyle \\nabla_{\\mathbf{k}} \\tilde{u}_{n\\mathbf{k}}}\nfrom finite differences (\nLPEAD\n=.TRUE.):\n\n∂\n|\nu\n~\nn\nk\nj\n⟩\n∂\nk\n=\ni\ne\n2\nΔ\nk\n∑\nm\n=\n1\nN\n[\n|\nu\n~\nm\nk\nj\n+\n1\n⟩\nS\nm\nn\n−\n1\n(\nk\nj\n,\nk\nj\n+\n1\n)\n⟩\n−\n|\nu\n~\nm\nk\nj\n−\n1\n⟩\nS\nm\nn\n−\n1\n(\nk\nj\n,\nk\nj\n−\n1\n)\n⟩\n]\n{\\displaystyle \n\\frac{\\partial | \\tilde{u}_{n\\mathbf{k}_j} \\rangle}{\\partial k}=\n\\frac{ie}{2\\Delta k} \\sum^N_{m=1}\n\\left[ | \\tilde{u}_{m\\mathbf{k}_{j+1}} \\rangle\nS^{-1}_{mn}(\\mathbf{k}_j,\\mathbf{k}_{j+1})\\rangle -\n| \\tilde{u}_{m\\mathbf{k}_{j-1}} \\rangle\nS^{-1}_{mn}(\\mathbf{k}_j,\\mathbf{k}_{j-1})\\rangle\\right]\n}\n\nwhere\nm\nruns over the\nN\noccupied bands of the system, Δ\nk\n=\nk\nj+1\n-\nk\nj\n, and\n\nS\nn\nm\n(\nk\nj\n,\nk\nj\n+\n1\n)\n=\n⟨\nu\n~\nn\nk\nj\n|\nu\n~\nm\nk\nj\n+\n1\n⟩\n{\\displaystyle \nS_{nm}(\\mathbf{k}_j,\\mathbf{k}_{j+1})=\n\\langle \\tilde{u}_{n\\mathbf{k}_{j}}| \\tilde{u}_{m\\mathbf{k}_{j+1}}\\rangle\n}\n.\n\nAs mentioned in the context of\nthe self-consistent response to finite electric fields\none may derive analoguous expressions for |∇\nk\nu\nn\nk\n⟩ using higher-order finite difference approximations.\n\nWhen\nLPEAD\n=.TRUE., VASP will compute |∇\nk\nu\nn\nk\n⟩ using the aforementioned finite difference scheme. The order of the finite difference approximation can be specified by means of the\nIPEAD\n-tag (default:\nIPEAD\n=4).\n\nThese tags may be used in combination with\nLOPTICS\n=.TRUE. and\nLEPSILON\n=.TRUE..\n\nN.B. Please note that\nLPEAD\n= .TRUE.\nis not supported for metallic systems\n.",
    "related_tags": [
      "IPEAD",
      "LEPSILON",
      "LOPTICS",
      "LCALCEPS",
      "EFIELD_PEAD",
      "Berry phases and finite electric fields"
    ]
  },
  "LPHON_DISPERSION": {
    "default_value": "Default: LPHON_DISPERSION = .FALSE.",
    "description": "LPHON_DISPERSION requests the calculation of the phonon dispersion along the q-point path supplied in file QPOINTS (same format as KPOINTS ).",
    "detailed_description": "After the computation of the force constants using finite differences (\nIBRION\n=5,6) or density-functional perturbation theory (\nIBRION\n=7,8) on a supercell it is possible to compute the phonon dispersion for the equivalent primitive cell determined by VASP by setting\nLPHON_DISPERSION\n=.TRUE.\n\nMind:\nOnly available as of VASP 6.3.2.",
    "related_tags": [
      "QPOINTS",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF"
    ]
  },
  "LPHON_POLAR": {
    "default_value": "LPHON_POLAR = .FALSE.",
    "description": "LPHON_POLAR includes dipole-dipole corrections in the computation of the phonon dispersion. For this mode, PHON_DIELECTRIC and PHON_BORN_CHARGES must also be set.",
    "detailed_description": "If the material is non-metallic and polar (i.e. two or more atoms in the unit cell carry nonzero Born effective charge tensors), a special treatment of the long-range dipole-dipole interaction is required to obtain a smooth phonon dispersion.\nThis is activated by setting\nLPHON_POLAR\n=.TRUE. and supplying the static dielectric tensor (\nPHON_DIELECTRIC\n) and the Born-effective charges (\nPHON_BORN_CHARGES\n) which can be obtained in a separate VASP calculation using the\nLEPSILON\nor\nLCALCEPS\ntag. \nThe dipole-dipole part of the interatomic force-constants is evaluated using an Ewald summation with the number of\nG\n{\\displaystyle \\mathbf{G}}\nvectors determined by the cutoff length (\nPHON_G_CUTOFF\n).\n\nIn the case of metals, the dielectric function is infinite, for nonpolar semiconductors the Born effective charges are zero which in both cases means that the\nlong-range interatomic force-constants\nare zero and this dipole-dipole correction does not need to be applied.\n\nMind:\nOnly available as of VASP 6.3.2.",
    "related_tags": [
      "QPOINTS",
      "LPHON_DISPERSION",
      "PHON_NWRITE",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF"
    ]
  },
  "LPHON_READ_FORCE_CONSTANTS": {
    "default_value": "Default: LPHON_READ_FORCE_CONSTANTS = .FALSE.",
    "description": "LPHON_READ_FORCE_CONSTANTS read the force constants from a vaspin.h5 file containing the force constants computed with a previous VASP run.",
    "detailed_description": "After the computation of the force constants using finite-differences (\nIBRION\n=5,6) or density-functional perturbation theory (\nIBRION\n=7,8) on a supercell the force constants are written to the vaspout.h5 file.\nTo plot the phonon dispersion on a different path the user can modify the\nQPOINTS\nfile and read the force constants computed previously (i.e. without performing the finite-differences computations on supercells again).\nTo do so copy vaspout.h5 to vaspin.h5 and set\nLPHON_READ_FORCE_CONSTANTS\n=.TRUE. in the\nINCAR\nfile.\nNote that when this is set only the phonon dispersion is performed and then VASP quits without running any additional calculation specified in the\nINCAR\nfile.\n\nMind:\nOnly available as of VASP 6.4.0.",
    "related_tags": [
      "QPOINTS",
      "LPHON_DISPERSION",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF"
    ]
  },
  "LPLANE": {
    "default_value": "LPLANE = .TRUE.",
    "description": "LPLANE switches on the plane-wise data distribution in real space.",
    "detailed_description": "For\nLPLANE\n=.TRUE., the data distribution in real space is done plane wise.\nAny combination of\nNPAR\nand\nLPLANE\ncan be used.\n\nGenerally,\nLPLANE\n=.TRUE. reduces the communication band width during the FFT's, but at the same time it unfortunately worsens the load balancing on massively parallel machines.\nLPLANE\n=.TRUE. should only be used if\nNGZ\nis at least 3×(number of nodes)/\nNPAR\n, and optimal load balancing is achieved if\nNGZ\n=\nn\n×\nNPAR\n, where\nn\nis an arbitrary integer.\n\nIf\nLPLANE\n=.TRUE. and if the real space projector functions (\nLREAL\n=.TRUE. or ON or AUTO) are used, it might be necessary to check the lines following\n\nreal space projector functions\n total allocation   :\n max/ min on nodes  :\n\nThe\nmax/ min\nvalues should not differ too much, otherwise the load balancing might worsen as well.\n\nThe optimum settings for\nNPAR\nand\nLPLANE\ndepend strongly on the type of machine you are using.\nSome recommended setups:\n\nLINUX cluster linked by Infiniband, modern multicore machines:\n\nOn a LINUX cluster with multicore machines linked by a fast network we recommend to set\n\nLPLANE = .TRUE.\nNCORE  = number of cores per node (e.g. 4 or 8)\nLSCALU = .FALSE.\nNSIM   = 4\n\nIf very many nodes are used, it might be necessary to set\nLPLANE\n=.FALSE., but usually this offers very little advantage. For long runs (\ne.g.\nmolecular dynamics), we recommend to optimize\nNPAR\nby trying short runs for different settings.\n\nLINUX cluster linked by 1 Gbit Ethernet, and LINUX clusters with single cores:\n\nOn a LINUX cluster linked by a relatively slow network,\nLPLANE\nmust be set to .TRUE., and the\nNPAR\nflag should be equal to the number of cores:\n\nLPLANE = .TRUE.\nNCORE  = 1\nLSCALU = .FALSE.\nNSIM   = 4\n\nMind that you need at least a 100 Mbit full duplex network, with a fast switch offering at least 2 Gbit switch capacity to find usefull speedups. Multi-core machines should be always linked by an Infiniband, since Gbit is too slow for multi-core machines.\n\nMassively parallel machines (Cray, Blue Gene):\n\nOn many massively parallel machines one is forced to use a huge number of cores. In this case load balancing problems and problems with the communication bandwidth are likely to be experienced. In addition the local memory is fairly small on some massively parallel machines; too small keep the real space projectors in the cache with any setting. Therefore, we recommend to set\nNPAR\non these machines to √\n# of cores\n(explicit timing can be helpful to find the optimum value). The use of\nLPLANE\n=.TRUE. is only recommended if the number of nodes is significantly smaller than\nNGX\n,\nNGY\nand\nNGZ\n.\n\nIn summary, the following setting is recommended\n\nLPLANE = .FALSE.\nNPAR   = sqrt(number of cores)\nNSIM   = 1",
    "related_tags": [
      "NPAR",
      "NCORE",
      "LSCALU",
      "NSIM",
      "KPAR",
      "LSCALAPACK",
      "LSCAAWARE"
    ]
  },
  "LPOSNICS": {
    "default_value": "Default: LPOSNICS = .TRUE. if POSNICS file is present.",
    "description": "LPOSNICS controls if VASP reads the POSNICS file.",
    "detailed_description": "Warning: Not yet released!\nThis page contains information about a feature that will be available in a future \nrelease of VASP. In other words, currently you cannot use it even with the latest version of VASP. The information may change significantly until it is released.\n\nTo avoid reading the\nPOSNICS\nfile without removing it from the working directory, the\nLPOSNICS\ntag can be set to\n.FALSE.\nin the\nINCAR\nfile.",
    "related_tags": [
      "LCHIMAG",
      "NUCIND",
      "POSNICS"
    ]
  },
  "LREAL": {
    "default_value": "LREAL = .FALSE.",
    "description": "LREAL determines whether the projection operators are evaluated in real-space or in reciprocal space.",
    "detailed_description": "LREAL\n=.FALSE.\nprojection done in reciprocal space\nLREAL\n=Auto or A\nprojection done in real space, fully automatic optimization of projection operators (little to no user interference required)\nLREAL\n=On or O\nprojection done in real space, projection operators are re-optimized (not recommended)\nLREAL\n=.TRUE.\nprojection done in real space, use projectors on file (not recommended)\n\nThe nonlocal part of the\npseudopotential\nrequires the evaluation of an expression:\n\n∑\ni\nj\nD\ni\nj\n|\nβ\nj\n⟩\n⟨\nβ\ni\n|\nψ\n~\nn\nk\n⟩\n{\\displaystyle \\sum_{ij}D_{ij}|\\beta_j\\rangle\\langle\\beta_i|\\tilde{\\psi}_{n\\mathbf{k}}\\rangle}\n.\n\nwhere the \"projected wavefunction character\" is defined as:\n\nC\ni\nn\nk\n=\n⟨\nβ\ni\n|\nψ\n~\nn\nk\n⟩\n=\nΩ\nN\nF\nF\nT\n∑\nr\n⟨\nβ\ni\n|\nr\n⟩\n⟨\nr\n|\nψ\n~\nn\nk\n⟩\n=\nΩ\nN\nF\nF\nT\n∑\nr\nβ\n(\nr\n)\nψ\n~\nn\nk\n(\nr\n)\n=\n∑\nG\n⟨\nβ\ni\n|\nk\n+\nG\n⟩\n⟨\nk\n+\nG\n|\nψ\n~\nn\nk\n⟩\n=\n∑\nG\nβ\n¯\n(\nk\n+\nG\n)\nC\nG\nn\nk\n{\\displaystyle \\begin{align}C_{in\\mathbf{k}}=\\langle\\beta_i|\\tilde{\\psi}_{n\\mathbf{k}}\\rangle &=\\frac{\\Omega}{N_{\\rm FFT}}\\sum_{\\mathbf{r}}\\langle\\beta_i|\\mathbf{r}\\rangle\\langle\\mathbf{r}|\\tilde{\\psi}_{n\\mathbf{k}}\\rangle=\\frac{\\Omega}{N_{\\rm FFT}}\\sum_{\\mathbf{r}}\\beta(\\mathbf{r})\\tilde{\\psi}_{n\\mathbf{k}}(\\mathbf{r}) \\\\ &=\\sum_{\\mathbf{G}}\\langle\\beta_i|\\mathbf{k}+\\mathbf{G}\\rangle\\langle\\mathbf{k}+\\mathbf{G}|\\tilde{\\psi}_{n\\mathbf{k}}\\rangle=\\sum_\\mathbf{G}\\bar\\beta(\\mathbf{k}+\\mathbf{G}) C_{\\mathbf{G}n\\mathbf{k}}\\end{align}}\n\nThis expression can be evaluated in reciprocal or real space: In reciprocal space (second line), the number of operations scales with the size of the basis set, i.e., number of plane waves. In real space (first line), the projection operators are confined to spheres around each atom. Therefore, the number of operations necessary to evaluate one C\nin\nk\ndoes not increase with the system size (usually, the number of grid points within the cutoff sphere is between 500 and 2000). One of the major obstacles to the method working in real space is that the projection operators must be optimized, i.e., all high Fourier components must be removed from the projection operators. If this is not done,\naliasing\ncan happen, i.e., the high Fourier components of the projection operators are downfolded to low Fourier components, and random noise is introduced).\n\nCurrently, VASP supports three different schemes to remove the high Fourier components from the projectors.\nLREAL\n=.TRUE. is the simplest one. For\nLREAL\n=.TRUE., the real-space projectors that the pseudopotential generation code has generated are used. This requires no user interference but is potentially very inaccurate. For the outdated\nLREAL\n=On, the real space projectors are optimized by VASP using an algorithm proposed by King-Smith et al.\n[1]\nFor the recommended\nLREAL\n=Auto, an unpublished scheme\n[2]\nis used which results in simultaneously more accurate and localized projector functions than for the King-Smith et al. method. To fine-tune the optimization procedure, the tag\nROPT\ncan and should be used, if\nLREAL\n=Auto (or\nLREAL\n=On) is used. Specifically, perform first reference calculations using\nLREAL\n=.False. and decrease\nROPT\nuntil an acceptable accuracy, e.g., 1 meV/atom, is attained. Please also check carefully the documentation for\nROPT\n.\n\nWe recommend using the real-space projection scheme for systems containing more than about 30 atoms. We also strongly recommend using only\nLREAL\n=Auto.\n\nFor\nLREAL\n=A (and\nLREAL\n=O) the projection operators are optimized by VASP on the fly (i.e. on startup). Several tags influence the optimization:\n\nENCUT\n(i.e., the energy cutoff), components beyond the energy cutoff are 'removed' from the projection operators.\n\nPREC\ntag specifies how precise the real-space projectors should be and sets the variables\nROPT\naccordingly to the following values:\n\nFor\nLREAL\n=Auto\n\nROPT\n=-5E-4\nif\nPREC\n=Normal\nROPT\n=-5E-4\nif\nPREC\n=Single or SingleN\nROPT\n=-2.5E-4\nif\nPREC\n=Accurate\nROPT\n=-0.01\nif\nPREC\n=Low\nROPT\n=-0.002\nif\nPREC\n=Medium\nROPT\n=-4E-4\nif\nPREC\n=High\n\nFor\nLREAL\n=On\n\nROPT\n=2/3\nif\nPREC\n=Low\nROPT\n=1.0\nif\nPREC\n=Medium\nROPT\n=1.5\nif\nPREC\n=High\n\nThese defaults can be superseded by specifying the\nROPT\ntag in the\nINCAR\nfile.\n\nMind:\nReal-space optimization (\nLREAL\n=Auto) always results in a small (not necessarily negligible) error. The error is usually a constant energy shift for each atom. If you are interested in energy differences, use only calculations with the same setup (i.e., same\nENCUT\n,\nPREC\n,\nLREAL\nand\nROPT\nsetting) for all calculations. For example, if you want to calculate surface or defect energies, recalculate the bulk ground-state energy with exactly the same setting you are using for the surface. Another possibility is to relax the structure using real-space projection and to perform one final total-energy calculation using\nLREAL\n=.FALSE. to get exact energies. For\nPREC\n=Normal, the errors introduced by the real-space projection are usually of the same order of magnitude as those introduced by the\nwrap-around errors\n. For\nPREC\n=Accurate errors are usually less than 1 meV/atom.\nPREC\n=Low should be used only for, say, fast\nmolecular-dynamics calculations\n, if compute resources are really an issue.\nWhen the energy cutoff\nENCUT\nis increased significantly w.r.t. their defaults, the real-space projection scheme sometimes becomes unreliable, and it might be necessary to decrease\nROPT\nto values as small as\nROPT\n=1E-4.",
    "related_tags": [
      "ROPT",
      "PREC"
    ]
  },
  "LRHFCALC": {
    "default_value": "LRHFCALC = .FALSE.",
    "description": "Switch on the decomposition of the exchange functional for the range-separated hybrid RSHXLDA or RSHXPBE functionals .",
    "detailed_description": "If\nLRHFCALC\n=.TRUE. the exchange functional is decomposed into short-range LDA (or PBE) and long-range Hartree-Fock for calculations with the range-separated hybrid RSHXLDA or RSHXPBE functionals.\n[1]\n[2]\n[3]\nThe screening parameter is specified by means of the\nHFSCREEN\ntag.\n\nThe setting of the RSHXLDA and RSHXPBE functionals is shown on the\npage listing the hybrid functionals\n.\n\nMind:\nIf\nLRHFCALC\n=.TRUE., then\nLHFCALC\n=.TRUE. is automatically set.\nIf\nLRHFCALC\n=.TRUE., then\nAEXX\n=1 is automatically set, but\nAEXX\ncan be set to another value.",
    "related_tags": [
      "LHFCALC",
      "HFSCREEN",
      "AEXX",
      "LTHOMAS",
      "list of hybrid functionals",
      "Hybrid functionals: formalism",
      "↑",
      "H. Iikura, T. Tsuneda, T. Yanai, and K. Hirao, A long-range correction scheme for generalized-gradient-approximation exchange functionals , J. Chem. Phys. 115 , 3540 (2001).",
      "I. C. Gerber and J. G. Ángyán, Hybrid functional with separated range , Chem. Phys. Lett. 415 , 100 (2005).",
      "I. C. Gerber, J. G. Ángyán, M. Marsman, and G. Kresse, Range separated hybrid density functional with long-range Hartree-Fock exchange applied to solids , J. Chem. Phys. 127 , 054101 (2007)."
    ]
  },
  "LRPA": {
    "default_value": "LRPA = .FALSE.",
    "description": "LRPA =.TRUE. includes local field effect on the Hartree level only.",
    "detailed_description": "For\nLRPA\n=.TRUE. local field effects are included on the Hartree level only. This means that cell periodic microscopic changes of the local potential related to the change of the Hartree potential are included.\n\nFor\nLRPA\n=.FALSE. changes of the Hartree\nand the exchange-correlation potential\nare included. This usually increases the dielectric constants. The final values for the dielectric tensor can be found in the\nOUTCAR\nfile after the lines.\n\nMACROSCOPIC STATIC DIELECTRIC TENSOR (including local field effects in RPA (Hartree))\n\nFor\nLRPA\n=.FALSE. the dielectric tensor is written after the lines:\n\nMACROSCOPIC STATIC DIELECTRIC TENSOR (including local field effects in DFT)\n\nThe dielectric tensor\nexcluding\nlocal field effects is always calculated (regardless of\nLRPA\n). The piezoelectric tensors and the Born effective charges as well as the ionic contributions the to dielectric tensor are only calculated for\nLRPA\n=.FALSE..\n\nWarning:\nWe recommend using the\nLRPA\ntag only in combination with\nLEPSILON\nor\nLCALCEPS\n, where the treatment of the terms beyond RPA is unambiguous. In the\nMBPT calculations\nvarious approximations beyond RPA can be used, hence more precise control of the included terms should be used via the tags\nLHARTREE\n,\nLADDER\n, and\nLFXC\n.",
    "related_tags": [
      "LEPSILON",
      "LCALCEPS",
      "LHARTREE",
      "LADDER",
      "LFXC"
    ]
  },
  "LRPAFORCE": {
    "default_value": "LRPAFORCE = .FALSE.",
    "description": "LRPAFORCE =.TRUE. calculates forces in the random-phase approximation (RPA).",
    "detailed_description": "Available as of VASP.6.1.\n\nThis tag can be optionally set in low-scaling\nRPA calculations\nor\nGW calculations\n. It allows computing the\nRPA forces\n[1]\non each ion. \nSetting\n\nALGO\n= RPAR ;  LRPAFORCE = .TRUE.\n\nor equivalently\n\nALGO\n= G0W0R ; LRPAFORCE = .TRUE.\n\ndetermines the RPA total energy with corresponding forces and the quasiparticle energies within the GW approximation.\n\nThe\nLRPAFORCE\ntag can be used in combination with the standard relaxation options\nIBRION\nand\nNSW\nas explained in the corresponding\nRPA calculations guide\n.\n\nGenerally, the energy calculated by the RPA can be quite noisy as a function of the ionic positions, in particular, if\nPRECFOCK\n= FAST and\nNMAXFOCKAE\n= 1 is set\n(these are the default values for RPA calculations). Most of the noise is related to the exact exchange energy, and we are working on methods to improve this issue.\nCurrently, to reduce the noise in the energy and forces, it is sensible to set\nPRECFOCK\n= Normal (typically doubling the execution time and memory requirement). It is also possible to set\nLMAXFOCKAE\n= -1 (which implicitly sets\nNMAXFOCKAE\n= 0). This makes the correlation energies and the related forces less noisy, but technically less accurate (i.e. part of the correlation energy will be missing at high transition energies).  \nOverall, RPA forces must be used carefully and only after extensive testing of all relevant parameters.\n\nMind:\nThe RPA stress tensor is not available.\n\nWarning:\nOnly\nISIF\n=0 is supported.",
    "related_tags": [
      "IBRION",
      "NSW",
      "ALGO",
      "NBANDS",
      "NMAXFOCKAE",
      "RPA calculations",
      "GW calculations"
    ]
  },
  "LSCAAWARE": {
    "default_value": "Default: LSCAAWARE = .TRUE. if VASP is compiled with scaLAPACK support (precompiler flag -DscaLAPACK) | = .FALSE. otherwise",
    "description": "LSCAAWARE controls the distribution of the Hamilton matrix.",
    "detailed_description": "For\nLSCAAWARE\n=.TRUE., VASP distributes the Hamilton matrix among the MPI ranks.  \nFor\nLSCAAWARE\n=.FALSE., each MPI ranks allocates the complete Hamiltonain. In both cases\nLSCALAPACK\ndecides if ScaLAPACK routines are used for diagonalization.",
    "related_tags": [
      "NPAR",
      "NCORE",
      "LPLANE",
      "NSIM",
      "KPAR",
      "LSCALU",
      "LSCALAPACK"
    ]
  },
  "LSCALAPACK": {
    "default_value": "Default: LSCALAPACK = .TRUE. if VASP is compiled with scaLAPACK support (precompiler flag -DscaLAPACK) | = .FALSE. otherwise",
    "description": "LSCALAPACK controls the use of scaLAPACK.",
    "detailed_description": "For\nLSCALAPACK\n=.TRUE., VASP uses scaLAPACK routines for the orthonormalization of the wave functions and subspace diagonalizations.\n\nThe use of scaLAPACK for the LU decomposition in the orthonormalization of the wave functions may be independently switched off (\nLSCALU\n=.FALSE.).",
    "related_tags": [
      "NPAR",
      "NCORE",
      "LPLANE",
      "NSIM",
      "KPAR",
      "LSCALU",
      "LSCAAWARE"
    ]
  },
  "LSCALER0": {
    "default_value": "LSCALER0 = .TRUE.",
    "description": "LSCALER0 decides whether to re-scale the van der Waals radii R 0 {\\displaystyle R_{0}} ( LSCALER0 = .TRUE. ) or not.",
    "detailed_description": "",
    "related_tags": [
      "IVDW",
      "Self-consistent screening in Tkatchenko-Scheffler method",
      "LVDWEXPANSION"
    ]
  },
  "LSCALU": {
    "default_value": "LSCALU = .FALSE.",
    "description": "LSCALU switches on the parallel LU decomposition (using scaLAPACK) in the orthonormalization of the wave functions.",
    "detailed_description": "For\nLSCALU\n=.TRUE. the LU decomposition in the orthormalization of the wave functions is done in parallel, using scaLAPACK routines.\nProvided, of course,\nLSCALAPACK\n=.TRUE. and VASP was compiled with scaLAPACK support (\nprecompiler flag\n: -DscaLAPACK).\n\nIn many cases, the scaLAPACK LU decomposition based is\nslower\nthan the serial LU decomposition (compare the timing\nORTHCH\nin the respective\nOUTCAR\nfiles). Hence the default is\nLSCALU\n=.FALSE.\n(subspace rotations, however, are still done using scaLAPACK).",
    "related_tags": [
      "NPAR",
      "NCORE",
      "LPLANE",
      "NSIM",
      "KPAR",
      "LSCALAPACK",
      "LSCAAWARE"
    ]
  },
  "LSCDM": {
    "default_value": "Default: LSCDM = .FALSE.",
    "description": "LSCDM switches on the selected columns of the density matrix (SCDM) method.",
    "detailed_description": "The selected columns of the density matrix (SCDM) method works by fitting a unitary matrix\nU\nm\nn\nk\n{\\displaystyle U_{mn\\mathbf{k}}}\nthat transforms \nthe basis from Bloch states\n|\nψ\nn\nk\n⟩\n{\\displaystyle |\\psi_{n\\mathbf{k}}\\rangle}\nobtained by VASP to a\nWannier basis\n|\nw\nm\nR\n⟩\n{\\displaystyle |w_{m\\mathbf{R}}\\rangle}\n.\n\n|\nw\nm\nR\n⟩\n=\n∑\nn\nk\ne\n−\ni\nk\n⋅\nR\nU\nm\nn\nk\n|\nψ\nn\nk\n⟩\n.\n{\\displaystyle \n|w_{m\\mathbf{R}}\\rangle =\n\\sum_{n\\mathbf{k}}\ne^{-i\\mathbf{k}\\cdot\\mathbf{R}}\nU_{mn\\mathbf{k}}\n|\\psi_{n\\mathbf{k}}\\rangle.\n}\n\nThis is done using a\none-shot method\nthrough a singular-value decomposition as proposed by A. Damle and L. Lin\n[1]\n.\n\nIn order to obtain a good Wannierization, a certain level of freedom should be given to the localized orbitals to adequately accommodate the Bloch states. This is controlled by the cutoff function specified by the\nCUTOFF_TYPE\ntag and related parameters\nμ\n{\\displaystyle \\mu}\n(\nCUTOFF_MU\n) and\nσ\n{\\displaystyle \\sigma}\n(\nCUTOFF_SIGMA\n).",
    "related_tags": [
      "CUTOFF_TYPE",
      "CUTOFF_MU",
      "CUTOFF_SIGMA"
    ]
  },
  "LSCK": {
    "default_value": "LSCK = .FALSE. Important: Up to vasp.6.2, the default was LSCK = .TRUE.",
    "description": "LSCK =.True. switches on the squeezed Coulomb kernel.",
    "detailed_description": "If\nLSCK\nis set to .TRUE., the squeezed Coulomb kernel is used instead of the\ncosine window\n[1]\n:\n\nv\nG\n=\n4\nπ\ne\n2\n(\nG\nm\na\nx\n−\nG\nm\ni\nn\n)\n(\nG\nm\na\nx\n−\nG\n)\n(\nG\nm\ni\nn\n2\n−\nG\n(\n2\nG\nm\ni\nn\n−\nG\nm\na\nx\n)\n)\n2\nfor\nE\nN\nC\nU\nT\nG\nW\nS\nO\nF\nT\n=\nℏ\n2\nG\nm\ni\nn\n2\n2\nm\ne\n<\nℏ\n2\nG\n2\n2\nm\ne\n<\nℏ\n2\nG\nm\na\nx\n2\n2\nm\ne\n=\nE\nN\nC\nU\nT\nG\nW\n{\\displaystyle v_{G} = 4 \\pi e^2 \\frac{\n(G_{max}-G_{min})(G_{max}-G)\n}{\n(G_{min}^2 - G(2G_{min}-G_{max}))^2\n}  \n\\qquad \\mbox{for} \\quad  \\mathrm{ENCUTGWSOFT}=\\frac{\\hbar^2G_{min}^2}{2m_e}<\\frac{\\hbar^2 G^2}{2m_e}<\\frac{\\hbar^2G_{max}^2}{2m_e}=\\mathrm{ENCUTGW}}\n\nThis kernel 'squeezes' the contributions from large wave vectors\nG\n>\nG\nm\na\nx\n{\\displaystyle G>G_{max}}\ninto the window given by\nENCUTGWSOFT\n. Effectively, this extrapolates the random-phase-approximation–correlation energy to the\nENCUTGW\n→\n∞\n{\\displaystyle \\to \\infty}\nlimit, assuming that the basis-set-incompleteness error falls off as\n1\n/\n{\\displaystyle 1/}\nENCUTGW\n3\n/\n2\n{\\displaystyle ^{3/2}}\n.",
    "related_tags": [
      "ENCUTGW",
      "GW calculations",
      "ACFDT/RPA calculations",
      "↑",
      "S. Riemelmoser, M. Kaltak, and G. Kresse, JCP 152(13) , 134103 (2020)."
    ]
  },
  "LSCSGRAD": {
    "default_value": "LSCSGRAD = .TRUE.",
    "description": "LSCSGRAD decides whether to compute gradients in the calculation of the MBD dispersion energy or the SCS contribution.",
    "detailed_description": "",
    "related_tags": [
      "IVDW",
      "Many-body dispersion energy",
      "Self-consistent screening in Tkatchenko-Scheffler method",
      "LVDWEXPANSION"
    ]
  },
  "LSELFENERGY": {
    "default_value": "LSELFENERGY = .FALSE.",
    "description": "Controls whether the frequency-dependent self-energy is calculated or not.",
    "detailed_description": "If\nLSELFENERGY\n= .FALSE.\n(default),  quasi-particle (QP) shifts are evaluated.\n\nQP shifts <psi_nk| G(iteration)W_0 |psi_nk>: iteration 1\n for sc-GW calculations column KS-energies equals QP-energies in previous step \n and V_xc(KS)=  KS-energies - (<T + V_ion + V_H > + <T+V_H+V_ion>^1  + <V_x>^1)\n \n k-point   1 :       0.0000    0.0000    0.0000\n  band No.  KS-energies  QP-energies   sigma(KS)   V_xc(KS)     V^pw_x(r,r')   Z            occupation Imag(sigma)\n \n      1      -7.1627      -8.3040     -14.5626     -12.7276     -21.6682       0.6219       2.0000       1.2037\n      2      -2.0901      -3.4347     -15.7660     -14.2799     -21.7439       0.9048       2.0000       0.6914\n      3      -2.0901      -3.4347     -15.7660     -14.2799     -21.7439       0.9048       2.0000       0.6914\n      4      -2.0901      -3.4347     -15.7660     -14.2799     -21.7439       0.9048       2.0000       0.6914\n      5       0.4603      -0.4663     -13.7603     -12.5200     -18.1532       0.7471       2.0000       0.2167\n      6       0.4603      -0.4663     -13.7603     -12.5200     -18.1532       0.7471       2.0000       0.2167\n\nIf\nLSELFENERGY\n= .TRUE.\n, the frequency dependent self-energy\n⟨\nψ\nn\nk\n|\nΣ\n(\nω\n)\n|\nψ\nn\nk\n⟩\n{\\displaystyle  \\langle \\psi_{n {\\mathbf{k}}} | \\Sigma(\\omega) |\\psi_{n {\\mathbf{k}}} \\rangle }\nis evaluated and printed to\nvasprun.xml\n. An example output looks like the following:\n\n<varray name=\"selfenergy\" >                                                                                                                                                                                                                                               \n  <v>    -150.00000000     -25.40060536       0.24429448 </v>                                                                                                                                                                                                              \n  <v>    -149.70000000     -25.40600800       0.24673910 </v>                                                                                                                                                                                                              \n  <v>    -149.40000000     -25.41141065       0.24918372 </v>                                                                                                                                                                                                              \n  <v>    -149.10000000     -25.41681330       0.25162834 </v>                                                                                                                                                                                                              \n  <v>    -148.80000000     -25.42221682       0.25406890 </v>                                                                                                                                                                                                              \n  <v>    -148.50000000     -25.42762671       0.25647992 </v>                                                                                                                                                                                                              \n  <v>    -148.20000000     -25.43303731       0.25888834 </v>\n\nTo print the self-energy is a slight extra computational effort since, within the GW algorithms, the self-energy is usually just evaluated near KS eigenenergies\nϵ\nn\nk\n{\\displaystyle \\epsilon_{nk}}\nand not the entire frequency range.\n\nMind:\nIn quartic-scaling GW the self-energy is given on the real-frequency axis, while for low-scaling GW the self-energy is given on the imaginary-frequency axis.\n\nFormat\n\nReal frequencies\n\nIf\nquartic-scaling GW algorithms\nare selected, e.g.\nALGO\n=EVGW0, the first column corresponds to points on the real-frequency axis (in eV). The second and third columns are the real and imaginary parts of the self-energy (in eV) at a given band index and\nk\npoint. To identify the band index and\nk\npoint, the ordering has to be taken from the\nOUTCAR\n: Instead of the QP shifts, a small set of self-energy points are printed to\nOUTCAR\n, similar to the following output\n\ncalculating selfenergy CALC_SELFENERGY_LINEAR between w=-150.00 150.00                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                           \nk-point   1 :       0.0000    0.0000    0.0000                                                                                                                                                                                     \n band No.  band energies     occupation                                                                                                                                                                                            \n                                                                                                                                                                                                                                   \n     1     -11.4323      2.00000  selfenergy along real axis                                                                                                                                                                       \n -150.0000000   -24.0756124     0.2065066                                                                                                                                                                                          \n -147.0000000   -24.1277845     0.2302741                                                                                                                                                                                          \n -144.0000000   -24.1803224     0.2537669                                                                                                                                                                                          \n ...\n  147.0000000   -20.3498375    -2.8348252                                                                                                                                                                                          \n  150.0000000   -20.2310127    -2.7491028                                                                                                                                                                                          \n                                                                                                                                                                                                                                   \n     2      -2.7832      2.00000  selfenergy along real axis                                                                                                                                                                       \n -150.0000000   -13.0060959     0.1938781                                                                                                                                                                                          \n -147.0000000   -13.0530569     0.2231126                                                                                                                                                                                          \n -144.0000000   -13.1030584     0.2520593 \n ...\n\nHere, the first and second band at the Gamma point are printed. \nThe line with\nselfenergy along real axis\ncontains band No., the KS energy, and the occupation of this state. \nThe output in\nvasprun.xml\nhas the same ordering of bands and\nk\npoints, i.e., the band index is always the fastest. The frequency grid cannot be controlled. It is always 1000 points in the range of -150 to 150.\n\nImaginary frequencies\n\nFor\nlow-scaling GW algorithms\n, the QP shifts are evaluated and printed to\nOUTCAR\nfor both,\nLSELFENERGY\n=T and F. For\nLSELFENERGY\n=T, the\nvasprun.xml\nfile additionally contains the self-energy for a given band index and\nk\npoint on the imaginary-frequency axis:\n\n<varray name=\"selfenergy along imaginary axis\" >                                                                                                                                                                                                                          \n  <v>       0.1570801806644298    -23.7971327349915711     -0.0179645094529067</v>                                                                                                                                                                                         \n  <v>       0.4718033117773284    -23.7968260788831572     -0.0537856829291801</v>                                                                                                                                                                                         \n  <v>       0.8108804505648752    -23.7966749072893577     -0.0932103588740998</v>                                                                                                                                                                                         \n  <v>       1.3058951128526406    -23.7949927690568188     -0.1482973553314607</v>         \n...\n\nTo identify the band index and\nk\npoint, the ordering has to be taken from the QP shifts block in the\nOUTCAR\n. The band index is faster than the\nk\npoint.\nThe imaginary frequency is selected by the Minimax routines\n[1]\n, and the number of points depends on\nNOMEGA\n.",
    "related_tags": [
      "GW calculations",
      "ALGO",
      "LFINITE_TEMPERATURE",
      "NOMEGA",
      "↑",
      "M. Kaltak and G. Kresse, Phys. Rev. B. 101 , 205145 (2020)."
    ]
  },
  "LSEPB": {
    "default_value": "LSEPB = .FALSE.",
    "description": "Specifies whether the partial charge density is summed up for all selected bands or separated and printed out in different files.",
    "detailed_description": "If\nLPARD\n= .TRUE. the partial charge density is calculated for a subset of bands selected via the\nIBAND\n,\nNBMOD\n, and\nEINT\ntags. If\nLSEPB\nis set to .TRUE., separate PARCHG.nb.ALLK or PARCHG.nb.nk files are created, dependent on the\nLSEPK\ntag. If\nLSEPB\n= .FALSE., the output is written to\nPARCHG\nor PARCHG.ALLB.nk, again depending on\nLSEPK\n.\n\nHere are four examples to illustrate the interplay of\nLSEPB\nand\nLSEPK\n. in all cases, the following settings apply, selecting three specific bands and two\nk\npoints\nIBAND\n=  9 10 11\n,\nNBMOD\n= 3\n, and\nKPUSE\n=  1 34\n:\n\nLSEPB\n= .FALSE.\n,\nLSEPK\n= .FALSE.\n\noutput files:\nPARCHG\n\nLSEPB\n= .TRUE.\n,\nLSEPK\n= .FALSE.\n\noutput files:\nPARCHG.0009.ALLK, PARCHG.0010.ALLK, PARCHG.0011.ALLK\n\nLSEPB\n= .FALSE.\n,\nLSEPK\n= .TRUE.\n\noutput files:\nPARCHG.ALLB.0001, PARCHG.ALLB.0034\n\nLSEPB\n= .TRUE.\n,\nLSEPK\n= .TRUE.\n\noutput files:\nPARCHG.0009.0001, PARCHG.0009.0034, PARCHG.0010.0001, PARCHG.0010.0034,  PARCHG.0011.0001, PARCHG.0011.0034\n\nMind:\nIf VASP 6.5.0 or later is used, the code is compiled with\nHDF5 support\n, and\nLPARDH5\n= .TRUE., all output will be redirected to the\nvaspout.h5\nfile, where it can be analyzed with\npy4vasp\n.",
    "related_tags": [
      "LPARD",
      "IBAND",
      "EINT",
      "NBMOD",
      "KPUSE",
      "LSEPK",
      "LPARDH5",
      "PARCHG",
      "vaspout.h5",
      "Band-decomposed charge densities"
    ]
  },
  "LSEPK": {
    "default_value": "LSEPK = .FALSE.",
    "description": "Specifies whether the partial charge density is summed up for all selected k points or separated and printed out in different files.",
    "detailed_description": "Mind:\nIf the\nk\npoints are separated, each\nk\npoint weight is set to 1. To get the correct results in this case it is necessary to turn off symmetry (\nISYM\n= -1) for the initial ground state calculation and the post-processing partial charge calculation in most cases. However, the correct weight of each\nk\npoint is determined from the\nKPOINTS\nfile if all contributions are summed up.\n\nIf\nLPARD\n= .TRUE. the partial charge density is calculated for a subset of bands and\nk\npoints depending on the setting of the tags\nIBAND\n,\nKPUSE\n,\nNBMOD\n, and\nEINT\n. If\nLSEPK\nis set to .TRUE., separate PARCHG.ALLB.nk or PARCHG.nb.nk files are created, dependent on the\nLSEPB\ntag. If\nLSEPK\n= .FALSE., the output is written to\nPARCHG\nor PARCHG.nb.ALLK, again depending on\nLSEPB\n.\n\nHere are four examples to illustrate the interplay of\nLSEPB\nand\nLSEPK\n. in all cases, the following settings apply, selecting three specific bands and two\nk\npoints\nIBAND\n=  9 10 11\n,\nNBMOD\n= 3\n, and\nKPUSE\n=  1 34\n:\n\nLSEPB\n= .FALSE.\n,\nLSEPK\n= .FALSE.\n\noutput files:\nPARCHG\n\nLSEPB\n= .TRUE.\n,\nLSEPK\n= .FALSE.\n\noutput files:\nPARCHG.0009.ALLK, PARCHG.0010.ALLK, PARCHG.0011.ALLK\n\nLSEPB\n= .FALSE.\n,\nLSEPK\n= .TRUE.\n\noutput files:\nPARCHG.ALLB.0001, PARCHG.ALLB.0034\n\nLSEPB\n= .TRUE.\n,\nLSEPK\n= .TRUE.\n\noutput files:\nPARCHG.0009.0001, PARCHG.0009.0034, PARCHG.0010.0001, PARCHG.0010.0034,  PARCHG.0011.0001, PARCHG.0011.0034\n\nMind:\nIf VASP 6.5.0 or later is used, the code is compiled with\nHDF5 support\n, and\nLPARDH5\n= .TRUE., all output will be redirected to the\nvaspout.h5\nfile, where it can be analyzed with\npy4vasp\n.",
    "related_tags": [
      "LPARD",
      "IBAND",
      "EINT",
      "NBMOD",
      "KPUSE",
      "LSEPB",
      "LPARDH5",
      "PARCHG",
      "vaspout.h5",
      "Band-decomposed charge densities"
    ]
  },
  "LSFBXC": {
    "default_value": "LSFBXC = .FALSE.",
    "description": "Removes sources and drains from the exchange-correlation B field.",
    "detailed_description": "With\nLSFBXC\n=T, the sources and drains are removed from the exchange-correlation (XC) B field\n[1]\nat each step of the electronic minimization. Thus, any\nXC potential\ncan be constrained to correspond to a Maxwellian magnetic field at the cost of becoming a potential-only\nXC functional\n, since there is no correction applied to the XC energy.\n\nMoore et al. implemented the same feature in a parallel work\n[2]\n[3]\nand performed more extensive applications. Whether the two implementations are identical has not been tested, and no publication is associated with the present implementation (by Marie-Therese Huebsch) using\nLSFBXC\n.",
    "related_tags": [
      "XC",
      "GGA"
    ]
  },
  "LSINGLES": {
    "default_value": "LSINGLES = .FALSE.",
    "description": "Switch on singles contribution to correlation energy for GW algorithms . [1]",
    "detailed_description": "LSINGLES\nenables the calculation of the singles contributions to the correlation energy that can be represented by the following Feynman (time-ordered) diagrams:\n[2]\n[1]\n\nLSINGLES\nis used in combination with the\nlow-scaling ACFDT/RPA\nand\nGW\nalgorithms.\n\nIf the\nACFDT/RPA algorithm\nis selected with\nALGO\n=RPAR|ACFDTR and\nLSINGLES\nis set, the code calculates two singles contributions and writes following lines to\nOUTCAR\n\nHF single shot energy change        -1.23182672\nrenormalized HF singles             -1.23310555\n\nHere,\nrenomalized HF singles\ncorresponds to the renormalized singles contribution suggested by Ren and coworkers:\n[3]\n\nE\nc\nr\nS\nE\n=\n−\n∑\na\n∈\nv\ni\nr\nt\n,\ni\n∈\no\nc\nc\n|\n⟨\ni\n|\nV\nH\nF\n−\nV\n0\nK\nS\n|\na\n⟩\n|\n2\nϵ\na\n−\nϵ\ni\n{\\displaystyle \nE^{rSE}_c = -\\sum_{a\\in virt, i\\in occ} \\frac{|\\langle i| V^{HF} - V_0^{KS}|a\\rangle|^2 }{\\epsilon_a-\\epsilon_i}\n}\n\nThis contribution accounts for the change of the mean-field exchange energy and can be derived consistently within the AC-FDT framework as described in Sec. II D Eq. (28) of Klimeš et al.\n[1]\n\nIn contrast, the\nHF single shot energy change\nline contains the somewhat simpler contribution\n[1]\n\nE\nc\nr\nS\nE\n=\nT\nr\n[\n(\nγ\nH\nF\n−\nγ\nD\nF\nT\n)\nh\n^\nH\nF\n]\n,\n{\\displaystyle \nE_c^{rSE} = \\mathrm{Tr}\\left[ (\\gamma_{HF} - \\gamma_{DFT})\\hat h_{HF} \\right],\n}\n\nwhere\nγ\nH\nF\n{\\displaystyle \\gamma_{HF}}\nis the Hartree-Fock density matrix, determined for the Hartree-Fock Hamiltonian\nh\n^\nH\nF\n{\\displaystyle \\hat h_{HF}}\nand\nγ\nD\nF\nT\n{\\displaystyle \\gamma_{DFT}}\nis the Kohn-Sham density matrix.\nIn all practical calculations, we found that both values, the single-shot HF and renormalized singles contributions, are exceedingly close to each other.\n\nIf the\nGW algorithm\nis selected with\nALGO\n=G0W0R, the\nOUTCAR\ncontains also the singles contribution beyond the Hartree-Fock level\n\nE\nc\nG\nW\nS\nE\n=\nT\nr\n[\n(\nγ\nR\nP\nA\n−\nγ\nD\nF\nT\n)\nh\n^\nH\nF\n]\n,\n{\\displaystyle \nE_c^{GWSE} = \\mathrm{Tr}\\left[ (\\gamma_{RPA} - \\gamma_{DFT})\\hat h_{HF} \\right],\n}\n\nwhere\nγ\nR\nP\nA\n{\\displaystyle \\gamma_{RPA}}\nis the RPA density matrix.\n[1]\nFor versions <= 6.4.2, this contribution is not directly printed to file. However, the first and second term is printed to\nOUTCAR\n:\n\nEnergies using frozen KS orbitals\nHartree-Fock free energy of the ion-electron system (eV)\n ...\n eigenvalues         EBANDS =       -88.61789695   <--------Tr{ gam_DFT h_HF}---------\n ... \nEnergies after update of density matrix \nHartree-Fock free energy of the ion-electron system (eV) \n ...\n eigenvalues         EBANDS =       -89.68870320   <--------Tr{ gam_RPA h_HF}---------\n ...\n\nVersion >6.4.2 writes the GWSE singles contribution to\nOUTCAR\n:\n\nGWSE singles contribution:        -1.07080625\n\nMind:\nThe singles contribution is calculated correctly only for the default\nNATURALO\n=2.\n\nThe\nACFDT total energy\nin the limit of\ninfinite energy cutoff\nis then obtained by adding the singles contribution to the value of\n\nHF+E_corr(extrapolated)    =      -153.98810072 eV",
    "related_tags": [
      "NATURALO",
      "ALGO",
      "ACFDT/RPA formalism",
      "GW calculations",
      "Basis set convergence"
    ]
  },
  "LSMP2LT": {
    "default_value": "Default: LSMP2LT = .FALSE.",
    "description": "LSMP2LT selects a stochastic Laplace transformed MP2 algorithm.",
    "detailed_description": "If\nLSMP2LT\n=.TRUE. and\nALGO\n=ACFTDRK is set, a quartic scaling stochastic Laplace transformed MP2 algorithm is selected.\n[1]\n\nThis tag should be used in combination with\nKPAR\nto tweak parallelization as described in this\ntutorial\n.",
    "related_tags": [
      "NOMEGA",
      "ESTOP",
      "NSTORB",
      "KPAR",
      "ALGO",
      "↑",
      "T. Schäfer, B. Ramberger, and G. Kresse, J. Chem. Phys. 146 , 104101 (2017)."
    ]
  },
  "LSORBIT": {
    "default_value": "LSORBIT = .FALSE.",
    "description": "Switch on spin-orbit coupling.",
    "detailed_description": "LSORBIT\n= True switches on spin-orbit coupling (SOC)\n[1]\nand automatically sets\nLNONCOLLINEAR\n= True.  It requires using\nvasp_ncl\n. SOC couples the spin degrees of freedom with the lattice degrees of freedom. We recommend carefully checking the symmetry and convergence of your results when using SOC; see below.\n\nLSORBIT\nonly works for PAW potentials and is not supported by ultrasoft pseudopotentials. It is supported as of VASP.4.5.\n\nAssumptions and output\n\nSwitching on spin-orbit coupling (SOC) adds an additional term\nH\ns\no\nc\nα\nβ\n∝\nσ\n⋅\nL\n{\\displaystyle H^{\\alpha\\beta}_{soc}\\propto\\mathbf{\\sigma}\\cdot\\mathbf{L}}\nto the Hamiltonian that couples the Pauli-spin operator\nσ\n{\\displaystyle \\mathbf{\\sigma}}\nwith the angular momentum operator\nL\n{\\displaystyle \\mathbf{L}}\n.\n[1]\nAs a relativistic correction, SOC acts predominantly in the immediate vicinity of the nuclei. Therefore, it is assumed that contributions of\nH\ns\no\nc\n{\\displaystyle H_{soc}}\noutside the PAW spheres are negligible. Hence, VASP calculates the matrix elements of\nH\ns\no\nc\n{\\displaystyle H_{soc}}\nonly for the all-electron one-center contributions\n\nE\ns\no\nc\ni\nj\n=\nδ\nR\ni\nR\nj\nδ\nl\ni\nl\nj\n∑\nn\nk\nw\nk\nf\nn\nk\n∑\nα\nβ\n⟨\nψ\n~\nn\nk\nα\n|\np\n~\ni\n⟩\n⟨\nϕ\ni\n|\nH\ns\no\nc\nα\nβ\n|\nϕ\nj\n⟩\n⟨\np\n~\nj\n|\nψ\n~\nn\nk\nβ\n⟩\n{\\displaystyle \nE_{soc}^{ij} = \\delta_{{\\bf R}_i{\\bf R}_j}\\delta_{l_il_j} \\sum_{n \\bf k} w_{\\bf k} f_{n\\bf k} \\sum_{\\alpha\\beta} \\langle \\tilde{\\psi}^\\alpha_{n\\bf k} |\\tilde{p}_i \\rangle \\langle \\phi_i | H^{\\alpha\\beta}_{soc} | \\phi_j \\rangle \\langle \\tilde{p}_j | \\tilde{\\psi}^\\beta_{n\\bf k} \\rangle\n}\n\nwhere\nϕ\ni\n(\nr\n)\n=\nR\ni\n(\n|\nr\n−\nR\ni\n|\n)\nY\nl\ni\nm\ni\n(\nθ\n,\nφ\n)\n{\\displaystyle  \\phi_i({\\bf r}) = R_i(|{\\bf r}-{\\bf R}_i|) Y_{l_im_i}(\\theta,\\varphi) }\nare the partial waves of an atom centered at\nR\ni\n{\\displaystyle {\\bf R}_i}\n,\nψ\n~\nn\nk\nα\n{\\displaystyle \\tilde{\\psi}^\\alpha_{n\\bf k}}\nis the spinor-component\nα\n=↑\n,\n↓\n{\\displaystyle \\alpha=\\uparrow,\\downarrow}\nof the pseudo-orbital with band-index\nn\nand Bloch vector\nk\n, and\nf\nn\nk\n{\\displaystyle f_{n\\bf k}}\nand\nw\nk\n{\\displaystyle w_{\\bf k}}\nare the Fermi- and\nk\n-point weights, respectively.\n[1]\n\nIt is possible to write the partial magnetization by setting\nLORBIT\n, i.e., the site- and orbital-resolved expectation value of the Pauli-spin operator\nσ\n{\\displaystyle \\mathbf{\\sigma}}\n. And the partial orbital angular momentum by setting\nLORBMOM\n, i.e., the site- and orbital-resolved expectation value of the orbital angular momentum operator\nL\n{\\displaystyle \\mathbf{L}}\n.\n\nMind:\nThe orbital angular momentum (vector-like quantity) is written to the\nOUTCAR\nfile in Cartesian coordinates, while the magnetic moments (spinor-like quantity) are read and written in the basis specified by\nSAXIS\n(spinor space).\n\nThe default orientation of spinor space is\nσ\n1\n=\nx\n^\n{\\displaystyle \\sigma_1=\\hat x}\n,\nσ\n2\n=\ny\n^\n{\\displaystyle \\sigma_2 =\\hat y}\n,\nσ\n3\n=\nz\n^\n{\\displaystyle \\sigma_3 = \\hat z}\n. Hence, the bases agree by default, and no transformation is required.\n\nAfter a successful calculation including SOC, VASP writes the following results to the\nOUTCAR\nfile:\n\nSpin-Orbit-Coupling matrix elements\n\nIon:    1  E_soc:     -0.0984080\nl=   1\n    0.0000000    -0.0134381    -0.0134381\n   -0.0134381     0.0000000    -0.0134381\n   -0.0134381    -0.0134381     0.0000000\nl=   2\n    0.0000000    -0.0005072     0.0000000    -0.0005072    -0.0024560\n   -0.0005072     0.0000000    -0.0018420    -0.0005072    -0.0006140\n    0.0000000    -0.0018420     0.0000000    -0.0018420     0.0000000\n   -0.0005072    -0.0005072    -0.0018420     0.0000000    -0.0006140\n   -0.0024560    -0.0006140     0.0000000    -0.0006140     0.0000000\nl=   3\n    0.0000000    -0.0000000     0.0000000     0.0000000     0.0000000    -0.0000000    -0.0000000\n   -0.0000000     0.0000000    -0.0000000     0.0000000    -0.0000000    -0.0000000    -0.0000000\n    0.0000000    -0.0000000     0.0000000    -0.0000000    -0.0000000    -0.0000000     0.0000000\n    0.0000000     0.0000000    -0.0000000     0.0000000    -0.0000000     0.0000000     0.0000000\n    0.0000000    -0.0000000    -0.0000000    -0.0000000     0.0000000    -0.0000000     0.0000000\n   -0.0000000    -0.0000000    -0.0000000     0.0000000    -0.0000000     0.0000000    -0.0000000\n   -0.0000000    -0.0000000     0.0000000     0.0000000     0.0000000    -0.0000000     0.0000000\n\nHere,\n1  E_soc\nrepresents the accumulated energy contribution\nE\ns\no\nc\n=\n∑\ni\nj\nE\ns\no\nc\ni\nj\n{\\displaystyle E_{soc}=\\sum_{ij} E_{soc}^{ij}}\ninside the augmentation sphere that is centered at\nR\n1\n{\\displaystyle {\\bf R}_1}\n(position of ion 1), while the following entries correspond to the matrix elements\nE\ns\no\nc\ni\nj\n{\\displaystyle E_{soc}^{ij}}\nfor the angular momentum\nl\n{\\displaystyle l}\n. Rows and columns correspond to\nm\n{\\displaystyle m}\nand\nm\n′\n{\\displaystyle m'}\nof the real spherical harmonics\nY\nl\nm\n{\\displaystyle Y_{lm}}\n(see\nAngular functions\nfor naming and ordering conventions).\n\nSymmetry and convergence\n\nIn any spin-polarized (\nISPIN\n=2) or noncollinear (\nLNONCOLLINEAR\n=T) calculation, even without SOC, the total energy depends on the relative orientation of magnetic moments. For instance, two magnetic sites may couple ferromagnetically or antiferromagnetically. On the other hand, the total energy is independent of the orientation of the magnetic moments with respect to the lattice without SOC. For instance, in-plane and out-of-plane moments on a surface would yield the same energy in the absence of SOC.\n\nSwitching on SOC couples the spin degrees of freedom that live in spinor space and the lattice degrees of freedom that live in real space, see\nSAXIS\n. Therefore, the in-plane and out-of-plane magnetic moments on a surface would yield different energies, when including SOC. Similarly, the ferromagnetically or antiferromagnetically ordered magnetic moments may additionally align with, e.g., the third lattice vector by setting\nLSORBIT\n= True.\n\nGenerally, be extremely diligent when using SOC: The energy differences can be of the order of few\nμ\n{\\displaystyle \\mu}\neV/atom, k-point convergence is tedious and slow, and the required compute time might be huge, even for small cells.\n\nWarning:\nWhen SOC is included, we recommend testing whether switching off symmetry (\nISYM\n=-1) changes the results.\n\nOften, the k-point set changes from one to the other spin orientation, thus worsening the transferability of the results. Note that the\nWAVECAR\nfile cannot be reread properly if the number of k-points changes. Hence, restart the calculation without symmetry from a converged charge density by setting\nICHARG\n=1! Also, consider the setting of\nLMAXMIX\n.\n\nWe recommend setting\nGGA_COMPAT\n= False for noncollinear calculations since this improves the numerical precision of GGA calculations.\n\nPlease check the sections on\nLNONCOLLINEAR\n,\nSAXIS\n,\nLMAXMIX\n, and\nGGA_COMPAT\n.",
    "related_tags": [
      "LNONCOLLINEAR",
      "MAGMOM",
      "SAXIS",
      "LORBMOM",
      "LORBIT",
      "LMAXMIX",
      "GGA_COMPAT"
    ]
  },
  "LSPECTRAL": {
    "default_value": "Default: LSPECTRAL = .TRUE. if NOMEGA >2",
    "description": "LSPECTRAL specifies to use the spectral method.",
    "detailed_description": "If\nLSPECTRAL\n= .TRUE. is set, the imaginary part of the independent particle polarizability\nχ\nq\n0\n(\nG\n,\nG\n′\n,\nω\n)\n{\\displaystyle \\chi_{\\mathbf{q}}^0 (\\mathbf{G}, \\mathbf{G}', \\omega)}\nis calculated first, and afterwards the full independent particle polarizability is determined using a Kramers-Kronig (or Hilbert) transform. This reduces the computational workload by almost a factor\nNOMEGA\n/2. The downside of the coin is that the response function must be kept in memory for all considered frequencies, which can cause excessive memory requirements. VASP, therefore, distributes the dielectric functions among the available compute nodes.\n\nA similar trick is used when the QP-shifts are calculated. In general it is strongly recommended to set\nLSPECTRAL\n= .TRUE., except if memory requirements are too excessive.",
    "related_tags": [
      "NOMEGA",
      "LSPECTRALGW"
    ]
  },
  "LSPECTRALGW": {
    "default_value": "LSPECTRALGW = .FALSE.",
    "description": "LSPECTRALGW specifies to use the spectral method for calculating the self-energy.",
    "detailed_description": "If\nLSPECTRALGW\n= .TRUE. is set, the imaginary part of the self-energy\nΣ\n(\nω\n)\n=\nG\nW\n{\\displaystyle \\Sigma(\\omega)= G W}\nis calculated from the imaginary part of screened potential\nW\n(\nω\n)\n{\\displaystyle W(\\omega)}\nby shifting the poles of\nW\n{\\displaystyle W }\nby\n±\nϵ\n{\\displaystyle  \\pm \\epsilon }\n, where\nϵ\n{\\displaystyle  \\epsilon }\nare the poles of the Green's function\nG\n{\\displaystyle  G}\n.\nGenerally,\nLSPECTRALGW\naffects the compute time very little. QP energies also hardly\nchange when\nLSPECTRALGW\nis modified.\nHowever,\nLSPECTRALGW\n= .TRUE. is usually slightly more robust,\nand should be selected for molecules and other systems with flat dispersion-less bands.  \nOne the other hand,\nLSPECTRALGW\n= .TRUE. seems to converge slightly slower, \nas the complex shift\nCSHIFT\nis decreased. Set this flag, if the QP energies\nshow erratic behavior, for instance, if QP energies or Z-factors are not in the expected\nrange of values (0.5<Z<0.9).",
    "related_tags": [
      "LSPECTRAL"
    ]
  },
  "LSPIN_VDW": {
    "default_value": "LSPIN_VDW = .FALSE.",
    "description": "LSPIN_VDW =.TRUE. switches on the use of the spin-polarized formulation [1] for the nonlocal part of a van der Waals functional (available as of VASP.6.4.0).",
    "detailed_description": "Mind:\nLSPIN_VDW\n=.TRUE. is possible only for van der Waals functionals that consist of a\nGGA\nfor the semilocal part and the kernel type of Dion\net al.\n[2]\n(\nIVDW_NL\n=1) for the nonlocal part.",
    "related_tags": [
      "LUSE_VDW",
      "IVDW_NL",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "LSPIRAL": {
    "default_value": "LSPIRAL = .FALSE.",
    "description": "set LSPIRAL =.TRUE. to represent spin spirals by means of a generalized Bloch condition.",
    "detailed_description": "See the\ndescription of spin spiral calculations\nfor more details.",
    "related_tags": [
      "Spin spirals",
      "QSPIRAL",
      "LZEROZ"
    ]
  },
  "LSUBROT": {
    "default_value": "Default: SUBROT = .FALSE.",
    "description": "This flag can be set for hybrid functionals (HF-type calculations). LSUBROT determines whether an optimal rotation matrix between the occupied and unoccupied block is sought, when a direct optimization of the energy functional is performed (i.e. ALGO =All | Damped). The corresponding algorithm is unpublished. LSUBROT =.FALSE. is the standard algorithm, in which the rotation matrix between occupied and unoccupied orbitals is determined essentially using Loewdin perturbation theory, as for instance explained in Ref. [1] . For LSUBROT =.TRUE. the rotation matrix is instead optimized by performing a few standard SCF steps, in which the orbitals are kept fixed, but rotations between the occupied and unoccupied manifold are allowed. Once satisfactory convergence has been reached, the optimized density matrix (rotation matrix between occupied and unoccupied block) is passed back to the direct optimization routine and a rotation along the suggested direction is performed alongside an update of the orbitals. This generally speeds up calculations for small gap systems as well as metals. However, in rare cases, we have observed instabilities, so be careful when selecting LSUBROT =.TRUE.",
    "detailed_description": "Although the flag can be set for standard functionals, it is only efficient for hybrid functionals (HF-type calculations).\n\nReferences\n\n↑\nG. Kresse and J. Furthmüller, Phys. Rev. B 54, 11169 (1996).",
    "related_tags": []
  },
  "LSYNCH5": {
    "default_value": "LSYNCH5 = .FALSE.",
    "description": "LSYNCH5 determines whether the output in vaspout.h5 is always synchronized with VASP while the calculation is running.",
    "detailed_description": "If you set this flag, VASP will enable single-writer-multiple-reader mode for the HDF5 file.\nThis allows you to monitor the output using\npy4vasp\nwhile the calculation is still running.\n\nMind:\nSynchronizing the HDF5 file continuously comes with a computational cost. Please do your own testing whether that is a bottleneck for your calculation.",
    "related_tags": [
      "LH5"
    ]
  },
  "LTBOUNDLIBXC": {
    "default_value": "LTBOUNDLIBXC = .FALSE.",
    "description": "LTBOUNDLIBXC specifies whether or not the lower bound for the Kohn-Sham kinetic-energy density τ σ {\\displaystyle \\tau_{\\sigma}} ( τ σ W < τ σ {\\displaystyle \\tau_{\\sigma}^{\\textrm{W}}<\\tau_{\\sigma}} ) is enforced before τ σ {\\displaystyle \\tau_{\\sigma}} is used in a METAGGA functional from Libxc.",
    "detailed_description": "The Kohn-Sham kinetic-energy density\n\nτ\nσ\n=\n1\n2\n∑\ni\n∇\nψ\ni\nσ\n∗\n⋅\n∇\nψ\ni\nσ\n{\\displaystyle \\tau_{\\sigma}=\\frac{1}{2}\\sum_{i}\\nabla\\psi_{i\\sigma}^{*}\\cdot\\nabla\\psi_{i\\sigma}}\n\nshould, in principle, be larger than the von Weizsäcker kinetic-energy density\n[1]\n\nτ\nσ\nW\n=\n|\n∇\nn\nσ\n|\n2\n8\nn\nσ\n.\n{\\displaystyle \\tau_{\\sigma}^{\\textrm{W}}=\\frac{\\left\\vert\\nabla n_{\\sigma}\\right\\vert^{2}}{8 n_{\\sigma}}.}\n\nHowever, for numerical reasons\nτ\nσ\nW\n<\nτ\nσ\n{\\displaystyle \\tau_{\\sigma}^{\\textrm{W}}<\\tau_{\\sigma}}\nmay not be fulfilled, which can potentially lead to problems, in particular if the meta-GGA functional is not defined for negative values of\nτ\nσ\n−\nτ\nσ\nW\n{\\displaystyle \\tau_{\\sigma}-\\tau_{\\sigma}^{\\textrm{W}}}\n. If\nLTBOUNDLIBXC\n=.TRUE. in\nINCAR\n, then\nτ\nσ\n=\nmax\n(\nτ\nσ\n,\nτ\nσ\nW\n)\n{\\displaystyle \\tau_{\\sigma}=\\max(\\tau_{\\sigma},\\tau_{\\sigma}^{\\mathrm{W}})}\nis applied before\nτ\nσ\n{\\displaystyle \\tau_{\\sigma}}\nis used in a meta-GGA functional from Libxc.\n\nHowever, according to tests, for some of the most common meta-GGA functionals like SCAN\n[2]\n, a violation of the lower bound is technically not a problem. Furthermore, it has been observed that applying\nτ\nσ\n=\nmax\n(\nτ\nσ\n,\nτ\nσ\nW\n)\n{\\displaystyle \\tau_{\\sigma}=\\max(\\tau_{\\sigma},\\tau_{\\sigma}^{\\mathrm{W}})}\nmay possibly lead to very inaccurate forces and stress tensor. Therefore, by default\nLTBOUNDLIBXC\n=.FALSE. and Libxc should be compiled  with the option\n--disable-fhc\nhas explained\nhere\n.\n\nThus, the recommendation is to set\nLTBOUNDLIBXC\n=.TRUE. only in the case convergence shows an erratic behavior. If this choice is made, then the forces and stress tensor should be carefully monitored if a geometry optimization is done.",
    "related_tags": [
      "LIBXC1",
      "LIBXC2",
      "METAGGA"
    ]
  },
  "LTEMPER": {
    "default_value": "LTEMPER = .FALSE.",
    "description": "LTEMPER specified whether parallel tempering is used. The flag must be used in combination with IMAGES .",
    "detailed_description": "VASP supports various modes where simultaneous calculations for different INCAR, KPOINTS, POTCAR, or POSCAR files are performed. \nThe parallel tempering mode is explained in this section, however, please read the section\nIMAGES\nfirst. Parallel tempering is also known as replica-exchange molecular dynamics.\n[1]\n\nIf the tags\nIMAGES\n=nn and\nLTEMPER\n=.TRUE. are set in the\nINCAR\nfile, VASP performs parallel tempering calculations. In this case, it is expedient to supply different\nINCAR\nand\nPOSCAR\nfiles in each subdirectory 01, 02, 03, ..., nn. For each subdiretory a different simulation temperature should be supplied using the tags\nTEBEG\nin the INCAR files 01/INCAR, 02/INCAR ... nn/INCAR.\n\nIn the course of the simulations, VASP will attempt to swap the temperatures between the images. Swapping attempts are made every\nNTEMPER\nMD steps and accepted with a likelyhood of\n\np\n=\nmin\n(\n1\n,\nexp\n⁡\n(\n−\nE\nj\nk\nT\ni\n−\nE\ni\nk\nT\nj\n)\nexp\n⁡\n(\n−\nE\ni\nk\nT\ni\n−\nE\nj\nk\nT\nj\n)\n)\n=\nmin\n(\n1\n,\ne\n(\nE\ni\n−\nE\nj\n)\n(\n1\nk\nT\ni\n−\n1\nk\nT\nj\n)\n)\n,\n{\\displaystyle  p = \\min \\left( 1, \\frac{ \\exp \\left( -\\frac{E_j}{kT_i} - \\frac{E_i}{kT_j} \\right) }{ \\exp \\left( -\\frac{E_i}{kT_i} - \\frac{E_j}{kT_j} \\right) } \\right) = \\min \\left( 1, e^{(E_i - E_j) \\left( \\frac{1}{kT_i} - \\frac{1}{kT_j} \\right)} \\right) ,}\n\nwhere\nE\ni\n,\nE\nj\n{\\displaystyle  E_i, E_j}\nand\nT\ni\n,\nT\nj\n{\\displaystyle  T_i, T_j }\nare the energies and temperatures of the considered two replicas. Note that VASP swaps the temperatures and not the positions between images. This means that the temperatures in each subdirectory change as the MD progresses. Information on the current temperatures for each image can be found in the\nOUTCAR\nfiles around the lines (all OUTCAR files will show the same information):\n\nparallel tempering new\n\nThe average acceptance ratios are also written to the\nOUTCAR\nfile. For efficient parallel tempering the acceptance ratio should not fall much below 0.2-0.3. If the acceptance ratio is too small, one usually needs to increase the number of images. However, too many images can also decrease the probability that all images visit all allowed temperatures.",
    "related_tags": [
      "IMAGES",
      "NTEMPER"
    ]
  },
  "LTHOMAS": {
    "default_value": "LTHOMAS = .FALSE.",
    "description": "LTHOMAS selects a decomposition of the exchange functional based on Thomas-Fermi exponential screening.",
    "detailed_description": "If\nLTHOMAS\n=.TRUE. the decomposition of the exchange operator (in a\nrange-separated hybrid functional\n) into a short range and a long range part will be based on Thomas-Fermi exponential screening.\nThe Thomas-Fermi screening length\nk\nTF\nis specified by means of the\nHFSCREEN\ntag.\n\nFor typical semiconductors, a Thomas-Fermi screening length of about 1.8 Å\n-1\nyields reasonable band gaps. In principle, however, the Thomas-Fermi screening length depends on the valence electron density; VASP determines this parameter from the number of valence electrons (read from the\nPOTCAR\nfile) and the volume and writes the corresponding value to the\nOUTCAR\nfile:\n\nThomas-Fermi vector in A             =   2.00000\n\nMind:\nIf\nLTHOMAS\n=.TRUE., then\nLHFCALC\n=.TRUE. is automatically set.\n\nSince, VASP counts the semi-core states and\nd\n-states as valence electrons, although these states do not contribute to the screening, the values reported by VASP are often incorrect.",
    "related_tags": [
      "LHFCALC",
      "HFSCREEN",
      "LRHFCALC",
      "Thomas-Fermi screening",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "LTRIPLET": {
    "default_value": "Default: LTRIPLET = .FALSE.",
    "description": "LTRIPLET selects a triplet ansatz for Bethe-Salpeter-equations (BSE) calculations. This is synonymous to LHARTREE = .FALSE.",
    "detailed_description": "For a usual BSE calculation (\nLHARTREE\n=.TRUE.;\nLTRIPLET\n= .FALSE.), the excited state corresponds to a singlet if the ground state is not spin-polarized (\nISPIN\n=1) or anti-ferromagnetic (\nISPIN\n=2, total magnetic moment 0). This is so because the ansatz for the BSE calculation involves a hole and an electron pair prepared within each spin channel. For instance, an electron with up spin is removed from the ground-state determinant and placed with the same spin into a previously unoccupied orbital. If there are no separate spin channels this ansatz results in a net spin-zero, which corresponds to a singlet state.\n\nIf\nLTRIPLET\n=.TRUE., VASP assumes that an\nup\nelectron is removed from the ground-state determinant and placed as a\ndown\nelectron into a previously unoccupied orbital (spin flip). This ansatz corresponds to a triplet state as it has a net spin of one. Without spin-orbit coupling (\nLSORBIT\n= .FALSE.), the transition probability from the singlet ground state to the triplet solutions will be exactly zero. These excitations correspond to dark, potentially long-lived triplet excitons. However, VASP calculates the transition probabilities incorrectly, by assuming that a spin-flip excitation has the same transition probabilities as a usual singlet excitation.\nThe reported transition probabilities (\"optical transitions\" in\nvasprun.xml\n) are hence incorrect; they should be all zero. Likewise, the contributions to the dielectric function are zero for triplet excitations,\nand incorrectly reported in the\nvasprun.xml\nfile.\n\nIf a non-magnetic material is calculated using\nISPIN\n=2 for both the groundstate and BSE calculation, and a usual BSE calculation is performed (\nLHARTREE\n=.TRUE.;\nLTRIPLET\n= .FALSE.), all\nsinglet transitions as well as one set of the triplet excitations (those with\nm\nS\n=\n0\n{\\displaystyle  m_S=0}\n) are calculated. All triplet transitions will have zero transition probabilities. If\nLTRIPLET\n= .TRUE. is set for the BSE calculation, the other two sets of triplet excitations (those with\nm\nS\n=\n1\n{\\displaystyle  m_S=1}\nand\nm\nS\n=\n−\n1\n{\\displaystyle  m_S=-1}\n) are determined. Note that as for\nISPIN\n=1 for\nISPIN\n=2 and\nLTRIPLET\n= .FALSE., incorrect non-zero transition probabilities are reported in the\nvasprun.xml\nfile (they should be all exactly zero, since the underlying pair states fed into the BSE can not be excited by light).\n\nTo obtain meaningful transition probabilities for the singlet and triplet excitations, include spin-orbit coupling by setting\nLSORBIT\n= .TRUE. in the\nINCAR\nfile throughout the calculation, i.e., for the ground-state and BSE calculation.  In this case, the singlet and all three sets of triplet excitations are calculated simultaneously, and proper transition probabilities are assigned to each transition. Small transition probabilities might be observed even for triplet excitations as a result of spin-orbit coupling.\nLTRIPLET\n= .TRUE. should not be used for calculations including spin-orbit coupling.\n\nWarning:\nLTRIPLET\n=.TRUE. has not been extensively tested in combination with spin-polarized ground states (\nISPIN\n=2).\n\nWarning:\nWe are not sure whether the\nBSEFATBAND\napproach can be combined with the\nLTRIPLET\ntag.",
    "related_tags": [
      "LHARTREE",
      "ISPIN",
      "LSORBIT",
      "BSE calculations"
    ]
  },
  "LTRUNCATE": {
    "default_value": "KERNEL_TRUNCATION/LTRUNCATE = .False.",
    "description": "KERNEL_TRUNCATION/LTRUNCATE truncates the coulomb kernel to remove electrostatic interactions along non-periodic dimensions",
    "detailed_description": "Setting\nKERNEL_TRUNCATION/LTRUNCATE\n= T  switches on coulomb kernel truncation methods. These methods removes interactions with periodic replicas in non-periodic directions, i.e. along the surface normal for 2D materials and along all directions for 0D systems such as atoms and molecules.\n\nMind:\nThis tag acts as a \"super-tag\", i.e. unless this tag is switched on further options in KERNEL_TRUNCATION will be ignored.\n\nDefault settings\n\nThe following default settings are assumed when setting\nKERNEL_TRUNCATION/LTRUNCATE\n= T,\n\nKERNEL_TRUNCATION {\n        LTRUNCATE      = T\n        IDIMENSIONALITY = 0\n        LCOARSEN       = T\n  }\n\nwhich translates to 0D coulomb truncation which is suitable for a molecule using the coarsen before pad strategy\n[1]\n. Detailed information is available on the respective pages of the\nINCAR\ntags.",
    "related_tags": [
      "KERNEL_TRUNCATION/LCOARSEN",
      "KERNEL_TRUNCATION/IDIMENSIONALITY",
      "KERNEL_TRUNCATION/ISURFACE"
    ]
  },
  "LTSSURF": {
    "default_value": "LTSSURF = .FALSE.",
    "description": "if LTSSURF set to .TRUE., the standard parametrization of the Tkatchenko-Scheffler method is replaced by the one designed to enable reliable modeling of structure and stability for a broad class of organic molecules adsorbed on metal surfaces is activated [1] .",
    "detailed_description": "",
    "related_tags": [
      "IVDW",
      "Tkatchenko-Scheffler method",
      "↑",
      "V. G. Ruiz, W. Liu, and A. Tkatchenko, Density-functional theory with screened van der Waals interactions applied to atomic and molecular adsorbates on close-packed and non-close-packed surfaces , Phys. Rev. B 93 , 035118 (2016)"
    ]
  },
  "LUSENCCL": {
    "default_value": "LUSENCCL = .TRUE.",
    "description": "LUSENCCL allows deactivating the NVIDIA Collective Communications Library (NCCL) during runtime when the code was compiled with the -DUSENCCL option.",
    "detailed_description": "",
    "related_tags": []
  },
  "LUSE_VDW": {
    "default_value": "LUSE_VDW = .FALSE.",
    "description": "LUSE_VDW =.TRUE. switches on the use of a nonlocal vdW-DF functional. These functionals depend on the electron density at two points in space and model long-range van der Waals (dispersion) correlation effects.",
    "detailed_description": "Mind:\nIn versions of VASP prior to 6.4.0, a meta-GGA functional (e.g., SCAN) could be combined only with the rVV10 nonlocal functional. Conversely, a GGA functional could be combined only with the original nonlocal functional of Dion\net al.\n. This restriction is lifted since VASP.6.4.0 thanks to the introduction of the\nIVDW_NL\ntag.",
    "related_tags": [
      "GGA",
      "METAGGA",
      "IVDW_NL",
      "LSPIN_VDW",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "LVACPOTAV": {
    "default_value": "LVACPOTAV = .False.",
    "description": "Switch on determining the vacuum potential by averaging the local potential over a field-free region.",
    "detailed_description": "LVACPOTAV\nswitches on the computation of the vacuum potential, i.e., the average of the local potential in the vacuum region. \nIt computes the average potential by searching regions that are field-free (\nVACPOTFLAT\n), and the 2D-averaged charge density is nearly zero. The averaging is done in the direction of\nIDIPOL\nand is reported as the vacuum potential in the\nOUTCAR\n.\n\nTip:\nAs\nLVACPOTAV\nperforms a post-processing step, you may use it together with\nALGO\n= None by restarting a converged calculation.\n\nThe vacuum potential is one of the quantities needed to\ncompute the work function\n. It can be extracted from the\nOUTCAR\nby the following bash command\n\ngrep upper OUTCAR\n\nNote that two vacuum potentials will be produced, one corresponding to the upper termination of the slab and one corresponding to the lower. Depending on the system, one might be more interesting than the other.\n\nTip:\nFor determining the work function, we suggest using\nLVACPOTAV\nalong with the\nLVHAR\ntag such that only the sum of the Hartree and ionic potentials are used in the calculation of the vacuum potential. This choice is because the exchange-correlation potential might be noisy in the vacuum region but should, in principle, be zero.\n\nMind:\nLVACPOTAV\nis available only for versions after 6.4.3.\n\nBefore VASP 6.4.3, the default algorithm reports the 2D-averaged potential four grid points from the the minimum 2D-averaged charge density in the direction of\nIDIPOL\n, i.e., no averaging is performed along the surface normal of the 2D-averaged potential.\n\nUse in conjunction with the dipole correction\n\nA typical use case for\nLVACPOTAV\nis together with the dipole correction (including tags\nLDIPOL\nand\nIDIPOL\n). Switching on the dipole correction is crucial for determining the vacuum potential; without it, there will be no field-free region for dipolar systems.\n\nMind:\nNote that\nLVACPOTAV\nis currently implemented for\nIDIPOL\nbetween 1 and 3.\n\nWarnings\n\nIn case\nLVACPOTAV\nis not able to generate an accurate work function, the following warnings may be found in the\nOUTCAR\nfile.\n\nVacuum region is likely too small\n\n|     Did not find any points to average over, which means that no vacuum     |\n|     field-free region was found. Please increase the size of  your cell     |\n|     in the dimension of the dipole correction to obtain accurate            |\n|     workfunction values.                                                    |\n\nA possible solution to this problem is to increase the size of the vacuum dimension in your cell.\n\nThe minimum charge density in your cell may be too large\n\n|     The minimum charge density times volume of the cell along the axis      |\n|     of the dipole correction is larger 1E-1, which could mean that your     |\n|     workfunction is not accurate as there is no field free region in        |\n|     your cell. Please consider either increasing the size of your cell      |\n|     along the dipole correction (vacuum dimension) or perhaps               |\n|     increasing the precision of your calculation.                           |\n\nPossible solutions include:\n\nMaking sure you have a large enough vacuum dimension.\nIncreasing the precision of your calculation by changing\nEDIFF\n.",
    "related_tags": [
      "DIPOL",
      "LDIPOL",
      "IDIPOL",
      "VACPOTFLAT",
      "WRT_POTENTIAL",
      "LVTOT",
      "LVHAR",
      "Computing the work function"
    ]
  },
  "LVDWEXPANSION": {
    "default_value": "LVDWEXPANSION = .FALSE.",
    "description": "LVDWEXPANSION decides whether to write the two- to six- body contributions to MBD dispersion energy in the OUTCAR file.",
    "detailed_description": "",
    "related_tags": [
      "IVDW",
      "Many-body dispersion energy",
      "LSCSGRAD"
    ]
  },
  "LVDWSCS": {
    "default_value": "LVDWSCS = .FALSE.",
    "description": "LVDWSCS activates the self-consistent screening in Tkatchenko-Scheffler method .",
    "detailed_description": "",
    "related_tags": [
      "IVDW",
      "Tkatchenko-Scheffler method",
      "Self-consistent screening in Tkatchenko-Scheffler method"
    ]
  },
  "LVDW_EWALD": {
    "default_value": "LVDW_EWALD = .FALSE.",
    "description": "LVDW_EWALD decides whether the lattice summation in E d i s p {\\displaystyle E_{disp}} expression by means of Ewald's summation is computed.",
    "detailed_description": "LVDW_EWALD\ndecides whether the lattice summation in\nE\nd\ni\ns\np\n{\\displaystyle E_{disp}}\nexpression by means of Ewald's summation is computed in the pairwise van der Waals corrections schemes\nDFT-D2\n,\nDFT-ulg\nand\nTkatchenko-Scheffler method\n.",
    "related_tags": [
      "DFT-D2",
      "DFT-ulg",
      "Tkatchenko-Scheffler method"
    ]
  },
  "LVDW_ONECELL": {
    "default_value": "LVDW_ONECELL = .FALSE. .FALSE. .FALSE.",
    "description": "LVDW_ONECELL can be used to disable vdW interaction with mirror image in X Y Z direction. This is advisable for molecular calculations in the gas phase. In all other cases, use the default.",
    "detailed_description": "Note: There is some confusing documentation on the ASE pages, which states that \".TRUE. .TRUE. .TRUE.\" enables the interaction with neighboring cells. However, the opposite is the case and\n.TRUE.\ndisables the interaction (\".FALSE. .FALSE. .FALSE.\" = interactions switched on, \".TRUE. .TRUE. .TRUE.\" = interactions switched off).",
    "related_tags": [
      "IVDW",
      "Many-body dispersion energy"
    ]
  },
  "LVGVAPPL": {
    "default_value": "LVGVAPPL = .FALSE.",
    "description": "LVGVAPPL determines whether the vGv orbital magnetic susceptibility is applied in the calculation of the CSA tensor.",
    "detailed_description": "LVGVAPPL\nis available as of VASP.6.4.0.\n\nWhen performing a chemical shift calculation the standard\npGv\nsusceptibility is used to calculate the\nG\n=\n0\n{\\displaystyle \\mathbf{G=0}}\ncontribution to the CSA tensor by default.\nThis can be overruled with\nLVGVAPPL\n.\nIn case\nLVGVAPPL\nis true, the\nvGv\nsusceptibility is applied for the calculation of the\nG\n=\n0\n{\\displaystyle \\mathbf{G=0}}\ncontribution to the CSA tensor. For details see\nLVGVCALC\n.",
    "related_tags": [
      "LCHIMAG",
      "LVGVCALC"
    ]
  },
  "LVGVCALC": {
    "default_value": "LVGVCALC = .TRUE.",
    "description": "LVGVCALC switches on calculation of the vGv expression for the orbital magnetic susceptibility.",
    "detailed_description": "LVGVCALC\nis available as of VASP.6.4.0.\n\nWhen performing a chemical shift calculation the standard\npGv\nsusceptibility is calculated and used in the calculation of the CSA tensor\n[1]\n. When\nLVGVCALC\nis true, the magnetic susceptibility is also calculated with the\nvGv\napproximation.\nLVGVAPPL\ndetermines whether the\nvGv\nor\npGv\nresult is applied in the calculation of the\nG\n=\n0\n{\\displaystyle \\mathbf{G=0}}\ncontribution to the CSA tensor.\n\nThe\nvGv\nexpression for the orbital susceptibility was introduced by d'Avezac\net al.\n[2]\n.\nIn VASP its ultra-soft generalization is used\n[3]\n.",
    "related_tags": [
      "LCHIMAG",
      "LVGVAPPL"
    ]
  },
  "LVHAR": {
    "default_value": "LVHAR = .FALSE.",
    "description": "Determines whether the local potential V ionic ( r ) + V hartree ( r ) {\\displaystyle V_{\\text{ionic}}(\\mathbf{r}) +V_{\\text{hartree}}(\\mathbf{r}) } (in eV) is written to the LOCPOT file.",
    "detailed_description": "V\nionic\n(\nr\n)\n+\nV\nhartree\n(\nr\n)\n=\nV\nionic\n(\nr\n)\n+\n∫\nn\n(\nr\n′\n)\n|\nr\n−\nr\n′\n|\nd\nr\n′\n{\\displaystyle \nV_{\\text{ionic}}(\\mathbf{r})+V_{\\text{hartree}}(\\mathbf{r}) =\nV_{\\text{ionic}}(\\mathbf{r}) + \n\\int \\frac{n(\\mathbf{r'})}{|\\mathbf{r}-\\mathbf{r'}|}d\\mathbf{r'}\n}\n\nwhere\nV\nionic\n(\nr\n)\n{\\displaystyle V_{\\text{ionic}}(\\mathbf{r})}\nis the ionic potential as mimicked by the pseudopotentials and\nV\nhartree\n(\nr\n)\n{\\displaystyle V_{\\text{hartree}}(\\mathbf{r})}\nis the Hartree potential.\n\nThe local potential is written to the\nLOCPOT\nfile and hence to the same file as the local potential for\nLVTOT\n=T. Carefully check that the\nLOCPOT\nfile contains the potential you expect.\nWRT_POTENTIAL\nalso gives access to the ionic and Hartree potentials and offers more options.\n\nWarning:\nSetting\nLVHAR\n=True will set\nLVTOT\n=False.\n\nSee\nLOCPOT\nto find out how to write\nV\nionic\n(\nr\n)\n+\nV\nhartree\n(\nr\n)\n{\\displaystyle V_{\\text{ionic}}(\\mathbf{r}) +V_{\\text{hartree}}(\\mathbf{r}) }\nin VASP < 5.2.12.",
    "related_tags": [
      "Computing the work function",
      "LVTOT",
      "LOCPOT",
      "WRT_POTENTIAL",
      "LVACPOTAV"
    ]
  },
  "LVTOT": {
    "default_value": "LVTOT = .FALSE.",
    "description": "Determines whether the total local potential V LOCPOT ( r ) {\\displaystyle V_{\\text{LOCPOT}}(\\mathbf{r})} (in eV) is written to the LOCPOT file.",
    "detailed_description": "V\nLOCPOT\n(\nr\n)\n=\nV\nionic\n(\nr\n)\n+\n∫\nn\n(\nr\n′\n)\n|\nr\n−\nr\n′\n|\nd\nr\n′\n+\nV\nxc\n(\nr\n)\n{\\displaystyle \nV_{\\text{LOCPOT}}(\\mathbf{r}) = \nV_{\\text{ionic}}(\\mathbf{r}) + \n\\int \\frac{n(\\mathbf{r'})}{|\\mathbf{r}-\\mathbf{r'}|}d\\mathbf{r'}+\nV_{\\text{xc}}(\\mathbf{r})\n}\n\nwhere\nV\nionic\n(\nr\n)\n{\\displaystyle V_{\\text{ionic}}(\\mathbf{r})}\nis the ionic potential,\nthe second term is the Hartree potential, and\nV\nxc\n(\nr\n)\n{\\displaystyle V_{\\text{xc}}(\\mathbf{r})}\nis the (semi-)local exchange-correlation potential.\n\nIf\nLVTOT\n=.TRUE., the\nV\nLOCPOT\n(\nr\n)\n{\\displaystyle V_{\\text{LOCPOT}}(\\mathbf{r})}\nis written to the\nLOCPOT\nfile and the\nPOT\nfile. The\nPOT\nfile additionally contains the augmentation part.\n\nWarning:\nLVHAR\n=T changes the content of the\nLOCPOT\nfile.\n\nWRT_POTENTIAL\nalso gives access to the total local potential and offers more options.",
    "related_tags": [
      "Computing the work function",
      "LVHAR",
      "LOCPOT",
      "WRT_POTENTIAL",
      "LVACPOTAV",
      "POT"
    ]
  },
  "LWANNIER90": {
    "default_value": "LWANNIER90 = .FALSE.",
    "description": "LWANNIER90 =.TRUE. switches on the interface between VASP and WANNIER90 .",
    "detailed_description": "N.B.\n: This feature is only present if VASP is compiled with\n-DVASP2WANNIER90 or -DVASP2WANNIER90v2\n.\n\nFor\nLWANNIER90\n=.TRUE., VASP will write the input files for a WANNIER90 run:\nwannier90.win\n,\nwannier90.mmn\n,\nwannier90.eig\n,\nwannier90.amn\n, and if\nLWRITE_UNK\n=.TRUE.\nwannier90.UNKp.s\n. This is done by running\nwannier_setup\nin library mode as described in Chapter 6 of the\nWANNIER90 manual\n. For documentation of these files and tags therein, please refer to the\nWANNIER90 manual\n.\n\nThe following cases may occur:\n\nIf\nwannier90.win\ndoes not exist, VASP will write the following template\n\nnum_wann =\nNBANDS\nbegin unit_cell_cart\n  ... ... ...\n  ... ... ...\n  ... ... ...\nend unit_cell_cart\n\nbegin atoms_cart\n   ... ... ...\n   ... ... ...\n   ... ... ...\n   ... ... ...  \nend atoms_cart\n\nmp_grid = .. .. ..\n\nbegin kpoints\n   ... ... ...\n   ... ... ...\n   ... ... ...\n   ... ... ...\nend kpoints\n\nHere, the\nunit_cell_cart\n,\natoms_cart\n, and\nkpoints\nblocks, and\nmp_grid\narray, will be set in accordance with the setup of the VASP calculation. This basically corresponds to the information given in the\nPOSCAR\nand\nKPOINTS\nfiles.\n\nIf the\nwannier90.win\nfile already exists, VASP will only add the aforementioned information if it is not already present. This means that VASP will check, for instance, whether or not the\nwannier90.win\nfile contains a\nkpoints\nblock, and add one if not.\nMind\n: If it finds a\nkpoints\nblock, VASP will not check whether this block agrees with the k points used in the VASP calculation!\n\nThe user may create a\nwannier90.win\nfile prior to running VASP with\nLWANNIER90\n=.TRUE., and specify any tag and/or block that is understood by\nwannier_setup\nand/or\nwannier_run\n. For instance, one can specify the\nprojections\nblock in the\nwannier90.win\nfile that controls the initial guess for the maximally localized Wannier functions.\nThen, VASP writes the projections of the Bloch functions onto the relevant projectors to the\nwannier90.amn\nfile. See Chapter 3 of the\nWANNIER90 manual\nfor more information.",
    "related_tags": [
      "LWRITE_UNK",
      "LWRITE_MMN_AMN",
      "LWRITE_SPN",
      "LWANNIER90_RUN",
      "NUM_WANN",
      "WANNIER90_WIN"
    ]
  },
  "LWANNIER90_RUN": {
    "default_value": "LWANNIER90_RUN = .FALSE.",
    "description": "LWANNIER90_RUN executes wannier_setup (see LWANNIER90 =.TRUE.) and subsequently runs WANNIER90 in library mode ( wannier_run ).",
    "detailed_description": "For details on the execution of\nwannier_setup\nin VASP, see the description of the\nLWANNIER90\n-tag.\nFor information on the many tags one may set in the\nwannier90.win\nfile to control the execution of WANNIER90 (be it standalone or in library mode) we refer to the\nWANNIER90 manual\n.\n\nMind\n: when running WANNIER90 in library mode, the\nwannier90.mmn\nand\nwannier90.amn\nfiles are not written. The information these files normally contain is passed on to\nwannier_run\ninternally. If you want these files to be written anyway, for instance to be able to run WANNIER90 standalone later on, one should add\n\nLWRITE_MMN_AMN\n=.TRUE.\n\nto the\nINCAR\nfile.",
    "related_tags": [
      "LWANNIER90",
      "LWRITE_MMN_AMN",
      "LWRITE_UNK",
      "NUM_WANN",
      "LWRITE_SPN",
      "WANNIER90_WIN"
    ]
  },
  "LWAVE": {
    "default_value": "LWAVE = .NOT. LH5",
    "description": "LWAVE determines whether the wavefunctions are written to the WAVECAR file at the end of a run.",
    "detailed_description": "",
    "related_tags": [
      "LCHARG",
      "LCHARGH5",
      "LWAVEH5",
      "LH5"
    ]
  },
  "LWAVEH5": {
    "default_value": "LWAVEH5 = LH5",
    "description": "Determines whether the wavefunctions are written to vaspwave.h5 file at the end of a run.",
    "detailed_description": "If\nLWAVEH5\n= True\n, the Kohn-Sham orbitals, i.e., wavefunctions, are written to the\nvaspwave.h5\nfile at the end of the calculation. This can be used to restart VASP.",
    "related_tags": [
      "LCHARG",
      "LCHARGH5",
      "LWAVE",
      "LH5"
    ]
  },
  "LWEIGHTED": {
    "default_value": "LWEIGHTED = .FALSE.",
    "description": "LWEIGHTED selects the weighted cRPA method .",
    "detailed_description": "Selects the cRPA method of Sasioglu, Friedrich and Blügel\n[1]\nwhere following screening are subtracted from the full RPA polarizability:\n\nχ\n~\nG\n,\nG\n′\nσ\n(\nq\n,\ni\nω\n)\n≈\n1\nN\nk\n∑\nn\nn\n′\nk\nf\nn\nk\n−\nf\nn\n′\nk\n−\nq\nϵ\nn\nk\n−\nϵ\nn\n′\nk\n−\nq\n−\ni\nω\np\nn\nk\nσ\np\nn\n′\nk\n−\np\nσ\n′\n⟨\nu\nn\nk\nσ\n|\ne\n−\ni\n(\nG\n+\nq\n)\nr\n|\nu\nn\n′\nk\n−\nq\nσ\n′\n⟩\n⟨\nu\nn\n′\nk\n−\nq\nσ\n′\n|\ne\n−\ni\n(\nG\n′\n−\nq\n)\nr\n′\n|\nu\nn\n′\nk\nσ\n⟩\n{\\displaystyle \\tilde  \\chi^\\sigma_{{\\bf G,G}'}({\\bf q},i\\omega)\\approx\n\\frac 1{N_k}\\sum_{nn'{\\bf k}}\n\\frac{\nf_{n\\bf k}-f_{n'\\bf k-q}\n}{\n\\epsilon_{n{\\bf k}} -  \\epsilon_{n'\\bf k-q} - i \\omega \n}\np_{n\\bf k }^{\\sigma}\np_{n'\\bf k-p }^{\\sigma'}\n\\langle\nu_{n {\\bf k  }}^{\\sigma  } \n|e^{-i \\bf (G+q) r}| \nu_{n'{\\bf k-q}}^{ \\sigma' }\n\\rangle\n\\langle\nu_{n' {\\bf k-q}}^{\\sigma' }\n|e^{-i \\bf (G'-q)r'} |\nu_{n'{\\bf k  }}^{ \\sigma  }\n\\rangle\n}",
    "related_tags": [
      "LDISENTANGLED",
      "LSCRPA",
      "ALGO"
    ]
  },
  "LWRITE_MMN_AMN": {
    "default_value": "Default: LWRITE_MMN_AMN = .TRUE. if LWANNIER90 =.TRUE. | = .FALSE. otherwise",
    "description": "LWRITE_MMN_AMN =.TRUE. tells the VASP2WANNIER90 interface to write the wannier90.mmn and wannier90.amn files.",
    "detailed_description": "When running WANNIER90 in library mode (\nLWANNIER90_RUN\n=.TRUE.), the\nwannier90.mmn\nand\nwannier90.amn\nfiles are not written. The information these files normally contain is passed on to\nwannier_run\ninternally. If you want these files to be written anyway, for instance, to be able to run WANNIER90 standalone later on, set\nLWRITE_MMN_AMN\n=.TRUE. in the\nINCAR\nfile.",
    "related_tags": [
      "LWANNIER90",
      "LWANNIER90_RUN"
    ]
  },
  "LWRITE_SPN": {
    "default_value": "LWRITE_SPN = .FALSE.",
    "description": "Write wannier90.spn file for noncollinear calculations.",
    "detailed_description": "For noncollinear calculations (\nLNONCOLLINEAR\n=T using vasp_ncl) the\nwannier90.spn\nfile is written when\n\nLWANNIER90\n=T ! switch on Wannier90 interface\nLWRITE_SPN\n=T\n\nThe file is formatted, and the appropriate line (\nspn_formatted = .true.\n) is automatically added to the\nwannier90.win\nfile.\n\nWarning:\nOnly the default setting for\nSAXIS\nis supported.\n\nMind:\nAvailable for VASP version > 6.4.2.",
    "related_tags": [
      "LWANNIER90",
      "LWRITE_UNK",
      "LWRITE_MMN_AMN",
      "LWANNIER90_RUN",
      "NUM_WANN"
    ]
  },
  "LWRITE_UNK": {
    "default_value": "LWRITE_UNK = .FALSE.",
    "description": "LWRITE_UNK decides whether the cell-periodic part of the relevant Bloch functions is written.",
    "detailed_description": "For\nLWRITE_UNK\n=True, VASP writes the cell-periodic part of the Kohn–Sham orbitals in spin channel s at k point p to the file\nwannier90.UNKp.s\n. This file can be used to plot Wannier orbitals with WANNIER90.\n\nFor details on the execution of\nwannier_setup\nin VASP, see the description of the\nLWANNIER90\ntag.\nFor information on the\nwannier90.win\nfile and the execution of WANNIER90, we refer to the\nWANNIER90 manual\n.",
    "related_tags": [
      "LWANNIER90",
      "LWRITE_MMN_AMN"
    ]
  },
  "LWRITE_WANPROJ": {
    "default_value": "LWRITE_WANPROJ = .FALSE.",
    "description": "LWRITE_WANPROJ determines whether the Wannier projection file WANPROJ is written.",
    "detailed_description": "If\nWANPROJ\nis present, VASP skips the Wannier projection and reads the effective projectors U\nnk\nfrom the\nWANPROJ\nfile for each k point.",
    "related_tags": [
      "LWANNIER90",
      "LWANNIER90_RUN",
      "LDOWNSAMPLE"
    ]
  },
  "LZEROZ": {
    "default_value": "LZEROZ = .FALSE.",
    "description": "for LZEROZ =.TRUE. the z -component of the spin-spiral magnetisation density will be forced to be and to remain zero.",
    "detailed_description": "See the\ndescription of spin spiral calculations\nfor more details.",
    "related_tags": [
      "Spin spirals",
      "LSPIRAL",
      "QSPIRAL"
    ]
  },
  "MACHINE_LEARNING": {
    "default_value": "PLUGINS/MACHINE_LEARNING = .False.",
    "description": "PLUGINS/MACHINE_LEARNING calls the Python plugin for the machine learning interface for each ionic relaxation step",
    "detailed_description": "When\nPLUGINS/MACHINE_LEARNING\n=.TRUE., VASP calls the\nmachine_learning\nPython function at the end of each ionic relaxation step. \nYou can use this tag to replace VASP forces and the stress tensor to represent an external machine-learned interatomic potential.\nThis can be used if you want to combine an machine-learned interatomic potential with the different features of\nIBRION\n.\nFor example, you could compute the phonon frequencies of the interatomic potential and compare it to ab-initio data and be sure that the workflow is the same.\n\nExpected inputs\n\nThe\nmachine_learning\nPython function is different from the other plugins because it does not provide any input from VASP.\nInstead the plugin infrastructure handles the communication with VASP.\nThe only requirement of the plugin is that the function returns a class compatible with an\nASE Calculator\n.\n\ndef\nmachine_learning\n():\n# code to setup calculator\nreturn\ncalculator\n\nVASP will take care to convert its internal data to be compatible with the Calculator.\nWe compute the forces and stress using the calculator on this data.\nVASP packages the results on the Python side and sends them back to Fortran where they replace the usual force and stress values.",
    "related_tags": [
      "Plugins",
      "PLUGINS/FORCE_AND_STRESS",
      "PLUGINS/LOCAL_POTENTIAL",
      "PLUGINS/STRUCTURE"
    ]
  },
  "MAGMOM": {
    "default_value": "Default: MAGMOM = NIONS * 1.0 for ISPIN =2 | = 3 * NIONS * 1.0 for noncollinear magnetic systems ( LNONCOLLINEAR =.TRUE.)",
    "description": "Initial magnetic moment for each atom if no magnetization density is present. Considered when symmetry is determined.",
    "detailed_description": "For a\nmagnetic calculation from scratch\n(\nISTART\n=0),\nMAGMOM\nspecifies (i) the initial on-site magnetic moment for each atom, and (ii) lowers the symmetry of the system (as of VASP.4.4.4). A magnetic calculation could be either a spin-polarized calculation (\nISPIN\n=2) or noncollinear calculation (\nLNONCOLLINEAR\n=T). If the\nMAGMOM\nline breaks a symmetry of the crystal, the corresponding symmetry operation is removed and not applied during the symmetrization of, e.g., charges and forces.\n\nWhen\nrestarting a magnetic calculation\n,\nMAGMOM\nis only used to determine the symmetry of the system and not to set the on-site magnetic moment. Therefore, if you remove the\nMAGMOM\ntag before restarting from a converged\nWAVECAR\nor\nCHGCAR\n, the magnetization is likely to be symmetrized away.\n\nMAGMOM\nalso specifies the initial on-site magnetic moments when a\nmagnetic calculation\n(\nISPIN\n=2 or\nLNONCOLLINEAR\n=T) is\nstarted from a non-spin-polarized calculation\n(\nISPIN\n=1 and\nLNONCOLLINEAR\n=F). This implies restarting with\nICHARG\n=1 while the\nCHGCAR\nfile contains no magnetization density. Starting magnetic calculations from a non-spin-polarized calculation can improve convergence.\n\nThe\nI_CONSTRAINED_M\ntag can constrain the on-site magnetic moments.\n\nTip:\nTo converge to the magnetic ground state, we recommend setting the magnetic moments slightly larger than the expected values, e.g., using the experimental magnetic moment multiplied by 1.2-1.5. A growing collection of experimental data is available at the Bilbao crystallographic server.\n[1]\nIf no experimental data is available,\nMAGMOM\ncan be defined according to the procedure outlined in the Huebsch et al. 2021.\n[2]\n\nImportant:\nThe final magnetic state strongly depends on the initial values for\nMAGMOM\n.\n[2]\nThis is true even if no symmetry is used (\nISYM\n=-1), because of the many local minima that most exchange-correlation functionals have within spin-density-functional theory.\n\nFormat and basis\n\nFor a spin-polarized calculation (\nISPIN\n=2),\nMAGMOM\nis a list of NIONS positive or negative values that specify the magnitude and relative orientation of the magnetization on each ion. The on-site magnetic moments have no direction in real space, i.e., no orientation in the lattice.\n\nFor noncollinear calculation (\nLNONCOLLINEAR\n=T), the on-site magnetic moment is specified by three components for each ion. Without spin-orbit coupling (\nLSORBIT\n=False), the total energy depends only on the relative direction of the on-site magnetic moments. Hence, you can give the desired magnetic structure in Cartesian coordinates without considering how the lattice matrix or\nSAXIS\nis defined.\n\nWith spin-orbit coupling (\nLSORBIT\n=True), the three components must be specified in the basis of spinor space that is defined by\nSAXIS\n. The default is\nσ\n1\n=\nx\n^\n{\\displaystyle \\sigma_1=\\hat x}\n,\nσ\n2\n=\ny\n^\n{\\displaystyle \\sigma_2 =\\hat y}\n,\nσ\n3\n=\nz\n^\n{\\displaystyle \\sigma_3 = \\hat z}\n, such that\nMAGMOM\ncan be given in Cartesian coordinates. The orientation of\nMAGMOM\nwith respect to the lattice only matters if spin-orbit coupling is included (\nLSORBIT\n).\n\nExamples\n\nThe most simple input for a bcc cell with antiferromagnetic (AFM) spin alignment would be the following.\n\nPOSCAR\nfile:\n\nAFM\n 2.80000\n 1.00000   .00000   .00000\n  .00000  1.00000   .00000\n  .00000   .00000  1.00000\n 1 1\nCartesian\n  .00000   .00000   .00000\n  .50000   .50000   .50000\n\nwith\n\nISPIN\n= 2\nMAGMOM\n= 1.0 -1.0\n\nspecified in\nINCAR\n. In a perfectly AFM ordered cell, the total net magnetisation is zero, but the local magnetic moments can be written to the\nOUTCAR\nfile by setting\nLORBIT\ntag (and if\nLORBIT\n<10 , the\nRWIGS\ntag in addition) in the\nINCAR\nfile.\n\nIf you have problems converging to a desired magnetic solution, try to calculate first the non-magnetic ground state and continue from the generated\nWAVECAR\nand\nCHGCAR\n. To restart, e.g., a calculation with two atoms that have equally large and antiferromagnetically coupled on-site magnetic moments, you need to set the following in the\nINCAR\nfile:\n\nICHARG\n= 1\nISPIN\n= 2\nMAGMOM\n= m -m\n\nor for a noncollinear\n\nICHARG\n= 1\nLNONCOLLINEAR\n= T\nMAGMOM\n= 0 0 m  0 0 -m\n\nFor systems containing many atoms,\nMAGMOM\ninput on a single line can be hard to read, especially in the noncollinear case. It is possible to provide\nINCAR\ninput on\nmultiple lines\nusing backslashes (\n\\\n) as linebreaks. E.g. for a noncollinear system with AFM alignment and 16 atoms (the first 8 of them magnetic), the multi-line input could look like this:\n\nMAGMOM\n=  3.0  2.0  1.0 \\\n         -3.0 -2.0 -1.0 \\\n          3.0  2.0  1.0 \\\n         -3.0 -2.0 -1.0 \\\n          3.0  2.0  1.0 \\\n         -3.0 -2.0 -1.0 \\\n          3.0  2.0  1.0 \\\n         -3.0 -2.0 -1.0 \\\n          24*0.0\n\nRelated Tags and Sections\n\nISPIN\n,\nLNONCOLLINEAR\n,\nLSORBIT\n,\nSAXIS\n,\nLORBIT\n,\nI_CONSTRAINED_M\n\nExamples that use this tag\n\n↑\nMAGNDATA, Bilbao crystallographic server\n↑\na\nb\nHuebsch, M-T and Nomoto, T and Suzuki, M-T and Arita, R,\nBenchmark for ab initio prediction of magnetic structures based on cluster-multipole theory\n, Phys. Rev. X\n11\n, 011031 (2021).",
    "related_tags": []
  },
  "MAXMEM": {
    "default_value": "MAXMEM = 2800 (VASP.5.4.4. and older), automatically set as of VASP.6",
    "description": "MAXMEM specifies the maximum memory one MPI rank will attempt to allocate (in MByte). Since, the default varies somewhat between VASP versions, it is safer to set this flag manually. Currently the flag is only inspected in few selected routines, such as the GW or RPA routines that can use excessive amounts of memory. It is recommended to set MAXMEM to the available memory per core minus 200 Mbyte. For instance, if one node is equipped with 12 Gbyte, and 6 MPI ranks share this memory, the recommended setting is 12*1024/6-200 = 1848.",
    "detailed_description": "As of VASP.6 the default value of MAXMEM is set to 90 percent of the available memory per MPI rank. If more than one compute node is used, the minimum of all nodes is used. The available memory in RAM is estimated by searching the file \"/proc/meminfo\" for the entry \"MemAvailable:\". Note that \"/proc/meminfo\" is present on any Linux system and stored in RAM. In case that the file cannot be found, MAXMEM is set to 2800.",
    "related_tags": [
      "GW calculations",
      "ACFDT calculations",
      "NTAUPAR"
    ]
  },
  "MAXMIX": {
    "default_value": "MAXMIX = -45",
    "description": "MAXMIX specifies the maximum number of steps stored in the Broyden mixer ( IMIX =4).",
    "detailed_description": "MAXMIX\nspecifies the maximum number of vectors stored in the Broyden/Pulay mixer, in other words, it corresponds to the maximal rank of the approximation of the charge-dielectric function build up by the mixer.\nMAXMIX\ncan be either negative or positive:\n\nMAXMIX\n<0\n\nThe mixer is reset after each ionic step or if the number of electronic steps exceeds |\nMAXMIX\n| (this is the default and similar to the behavior of VASP.4.3 and VASP.3.2).\n\nMAXMIX\n>0\n\nThe charge density mixer is only reset if the storage capabilities are exceeded. The reset is done \"smoothly\" by removing the five oldest vectors from the iteration history. Therefore, if\nMAXMIX\nis positive, the approximation for the charge dielectric function which was obtained in previous ionic steps is \"reused\" in the current ionic step, and this, in turn, can reduce the number of electronic steps during relaxations and MD's. Especially for relaxations that start from a good ionic starting guess and for systems with a strong charge sloshing behavior the speedup can be significant. We found that for a 12 Å long box containing 16 Fe atoms the number of electronic iterations decreased from 8 to 2-3 when\nMAXMIX\nwas set to 40. For a carbon surface the number of iterations decreased from 7 to 3. At the same time, the energy stability increased significantly. But be careful, this option increases the memory requirements for the mixer considerably, and thus the option is not recommended for systems where charge sloshing is negligible anyway (like bulk simple metals). The optimal setting for\nMAXMIX\nis usually around three times the number of electronic steps required in the first iteration. Too large values for\nMAXMIX\nmight cause the code to crash (because linear dependencies between input vectors might develop). Too small values for\nMAXMIX\ncan slow your convergence significantly. For instance, if you need 50 self-consistency cycles, and set\nMAXMIX\nto 20, you force the mixer to remove iteration history continuously, which can cause divergence and at least a slow down of the convergence.\n\nCaution: do not set\nMAXMIX\n>0 in the following cases. (i) If your initial positions in the\nPOSCAR\nfile are far from the fully relaxed positions, the ions might move considerably during relaxation. In this case, it is not expedient to \"reuse\" charge mixing information from the previous ionic steps. (ii) During machine learning, the first-principles calculations are often bypassed for hundreds or even thousands of ionic steps, and the ions might move considerably between first-principles calculations. In these cases using\nMAXMIX\nwill very often lead to electronic divergence or strange errors during the self-consistency cycle. In general, whenever the column RMS(c) in the\nOSZICAR\nfiles shows a sudden increase in the norm of the charge density residual vector, try to remove the tag\nMAXMIX\nfrom the INCAR file.\n\nMind:\nMAXMIX\nis only available in VASP.4.4 and newer versions, and it is strongly recommended to use this option for molecular dynamics and relaxations.",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "AMIX",
      "BMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "AMIN",
      "MIXPRE",
      "WC"
    ]
  },
  "MDALGO": {
    "default_value": "MDALGO = 0",
    "description": "MDALGO specifies the molecular-dynamics-simulation protocol (in case IBRION =0 and VASP was compiled with -Dtbdyn ).",
    "detailed_description": "MDALGO\n=0: Standard molecular dynamics\n\nShould provide the same results as\nMDALGO\n=2 (\nNose-Hoover thermostat\n). The difference is that it is a different implementation and works also without the precompiler flag\n-Dtbdyn\n.\n\nNVE ensemble\n\nTo perform a calculation in the NVE ensemble:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=0 and set\nSMASS\n=-3.\n\nMDALGO\n=1: Andersen thermostat\n\nFor the description of the Andersen thermostat see:\nAndersen thermostat\n.\n\nThe Andersen thermostat is only available for the NVT ensemble.\n\nStandard molecular dynamics in\n\nFor a standard molecular dynamics run with Anderson thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=1, and choose an appropriate setting for\nANDERSEN_PROB\n\nConstrained molecular dynamics\n\nFor a description of constrained molecular dynamics see\nConstrained molecular dynamics\n.\n\nFor a constrained molecular dynamics run with Andersen thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\nSet\nMDALGO\n=1, and choose an appropriate setting for\nANDERSEN_PROB\nDefine geometric constraints in the\nICONST\n-file, and set the STATUS parameter for the constrained coordinates to 0\nWhen the free-energy gradient is to be computed, set\nLBLUEOUT\n=.TRUE.\n\nSlow-growth approach\n\nFor a description of slow-growth approach see\nSlow-growth approach\n.\n\nFor a slow-growth simulation, one has to perform a calcualtion very similar to\nConstrained molecular dynamics\nbut additionally the transformation velocity-related\nINCREM\n-tag for each geometric parameter with\nSTATUS=0\nhas to be specified:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\nSet\nMDALGO\n=1, and choose an appropriate setting for\nANDERSEN_PROB\nDefine geometric constraints in the\nICONST\n-file, and set the STATUS parameter for the constrained coordinates to 0\nWhen the free-energy gradient is to be computed, set\nLBLUEOUT\n=.TRUE.\n\nSpecify the transformation velocity-related\nINCREM\n-tag for each geometric parameter with\nSTATUS=0\n.\n\nMonitoring geometric parameters\n\nGeometric parameters with\nSTATUS = 7\nin the\nICONST\n-file are monitored during the MD simulation.\nThe corresponding values are written onto the\nREPORT\n-file, for each MD step, after the lines following the string\nMonit_coord\n.\n\nSometimes it is desirable to terminate the simulation if all values of monitored parameters get larger that some predefined upper and/or lower limits. These limits can be set by the user by means of the\nVALUE_MAX\nand\nVALUE_MIN\n-tags.\n\nTo monitor geometric parameters during an MD run:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=1, and choose an appropriate setting for\nANDERSEN_PROB\n.\nDefine geometric constraints in the\nICONST\n-file, and set the\nSTATUS\nparameter for the constrained coordinates to 7.\nOptionally, set the upper and/or lower limits for the coordinates, by means of the\nVALUE_MAX\nand\nVALUE_MIN\n-tags, respectively.\n\nMetadynamics\n\nFor a description of metadynamics see\nMetadynamics\n.\n\nFor a metadynamics run with Andersen thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=1 (or\nMDALGO\n=11 in VASP 5.x), and choose an appropriate setting for\nANDERSEN_PROB\n.\nSet the parameters\nHILLS_H\n,\nHILLS_W\n, and\nHILLS_BIN\n.\nDefine collective variables in the\nICONST\n-file, and set the\nSTATUS\nparameter for the collective variables to 5.\nIf needed, define the bias potential in the\nPENALTYPOT\n-file.\n\nThe actual time-dependent bias potential is written to the\nHILLSPOT\n-file, which is updated after adding a new Gaussian. At the beginning of the simulation, VASP attempts to read the initial bias potential from the\nPENALTYPOT\n-file. For the continuation of a metadynamics run, copy\nHILLSPOT\nto\nPENALTYPOT\n. The values of all collective variables for each MD step are listed in\nREPORT\n-file, check the lines after the string\nMetadynamics\n.\n\nBiased molecular dynamics\n\nFor a description of biased molecular dynamics see\nBiased molecular dynamics\n.\n\nFor a biased molecular dynamics run with Andersen thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=1 (or\nMDALGO\n=11 in VASP 5.x), and choose an appropriate setting for\nANDERSEN_PROB\n.\nIn order to avoid updating of the bias potential, set\nHILLS_BIN\n=\nNSW\n.\nDefine collective variables in the\nICONST\n-file, and set the\nSTATUS\nparameter for the collective variables to 5.\nDefine the bias potential in the\nPENALTYPOT\n-file if necessary.\n\nThe values of all collective variables for each MD step are listed in the\nREPORT\n-file, check the lines after the string\nMetadynamics\n.\n\nSpecial case: NVE ensemble\n\nNVE ensemble calculations can be also run by selecting the Anderson thermostat and setting the update collision probability (\nANDERSEN_PROB\n) to zero.\n\nTo run an NVE ensemble:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=1 and\nANDERSEN_PROB\n=0.0.\n\nMDALGO\n=2: Nose-Hoover thermostat\n\nFor the description of the Nose-Hoover thermostat see:\nNose-Hoover thermostat\n.\n\nThe Nose-Hoover thermostat is currently only available for the NVT ensemble.\n\nStandard molecular dynamics\n\nFor a standard molecular dynamics run with Nose-Hoover thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=2, and choose an appropriate setting for\nSMASS\n.\n\nConstrained molecular dynamics\n\nFor a description of constrained molecular dynamics see\nConstrained molecular dynamics\n.\n\nFor a constrained molecular dynamics run with Nose-Hoover thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=2, and choose an appropriate setting for\nSMASS\n.\nDefine geometric constraints in the\nICONST\n-file, and set the STATUS parameter for the constrained coordinates to 0.\nWhen the free-energy gradient is to be computed, set\nLBLUEOUT\n=.TRUE.\n\nSlow-growth approach\n\nFor a description of slow-growth approach see\nSlow-growth approach\n.\n\nFor a slow-growth approach run with Nose-Hoover thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\nSet\nMDALGO\n=2, and choose an appropriate setting for\nSMASS\nDefine geometric constraints in the\nICONST\n-file, and set the\nSTATUS\nparameter for the constrained coordinates to 0\nWhen the free-energy gradient is to be computed, set\nLBLUEOUT\n=.TRUE.\n\nSpecify the transformation velocity-related\nINCREM\n-tag for each geometric parameter with\nSTATUS=0\n\nMonitoring geometric parameters\n\nGeometric parameters with\nSTATUS = 7\nin the\nICONST\n-file are monitored during the MD simulation.\nThe corresponding values are written onto the\nREPORT\n-file, for each MD step, after the lines following the string\nMonit_coord\n.\n\nSometimes it is desirable to terminate the simulation if all values of monitored parameters get larger that some predefined upper and/or lower limits. These limits can be set by the user by means of the\nVALUE_MAX\nand\nVALUE_MIN\n-tags.\n\nTo monitor geometric parameters during an MD run:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\nSet\nMDALGO\n=2, and choose an appropriate setting for\nSMASS\nDefine geometric constraints in the\nICONST\n-file, and set the\nSTATUS\nparameter for the constrained coordinates to 7\nOptionally, set the upper and/or lower limits for the coordinates, by means of the\nVALUE_MAX\nand\nVALUE_MIN\n-tags, respectively.\n\nMetadynamics\n\nFor a description of metadynamics see\nMetadynamics\n.\n\nFor a metadynamics run with Nose-Hoover thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=2 (or\nMDALGO\n=21 in VASP 5.x), and choose an appropriate setting for\nSMASS\n.\nSet the parameters\nHILLS_H\n,\nHILLS_W\n, and\nHILLS_BIN\n.\nDefine collective variables in the\nICONST\n-file, and set the\nSTATUS\nparameter for the collective variables to 5.\nIf needed, define the bias potential in the\nPENALTYPOT\n-file.\n\nThe actual time-dependent bias potential is written to the\nHILLSPOT\n-file, which is updated after adding a new Gaussian. At the beginning of the simulation, VASP attempts to read the initial bias potential from the\nPENALTYPOT\n-file. For the continuation of a metadynamics run, copy\nHILLSPOT\nto\nPENALTYPOT\n. The values of all collective variables for each MD step are listed in\nREPORT\n-file, check the lines after the string\nMetadynamics\n.\n\nBiased molecular dynamics\n\nFor a description of biased molecular dynamics see\nBiased molecular dynamics\n.\n\nFor a biased molecular dynamics run with Nose-Hoover thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nMDALGO\n=2 (or\nMDALGO\n=21 in VASP 5.x), and choose an appropriate setting for\nSMASS\n.\nIn order to avoid updating of the bias potential, set\nHILLS_BIN\n=\nNSW\n.\nDefine collective variables in the\nICONST\n-file, and set the\nSTATUS\nparameter for the collective variables to 5.\nDefine the bias potential in the\nPENALTYPOT\n-file.\n\nThe values of all collective variables for each MD step are listed in the\nREPORT\n-file, check the lines after the string\nMetadynamics\n.\n\nMDALGO\n=3: Langevin thermostat\n\nFor the description of the Langevin thermostat see:\nLangevin thermostat\n.\n\nThe Langevin thermostat is available for\nNVT\nand\nNpT\nensembles.\n\nNVT\n-simulation with Langevin thermostat\n\nTo run an\nNVT\n-simulation with a Langevin thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nISIF\n=2.\nSet\nMDALGO\n=3 to invoke the Langevin thermostat.\nSpecify friction coefficients for all species in the\nPOSCAR\nfile, by means of the\nLANGEVIN_GAMMA\n-tag.\n\nNpT\n-simulation with Langevin thermostat\n\nThe Langevin dynamics in the isobaric-isothermal ensemble is calculated by the method of Parrinello and Rahman\n[1]\n[2]\n(see\nNpT ensemble\nfor more descriptions) combined with a\nLangevin thermostat\n.\n\nTo run an NpT-simulation (Parinello-Rahman dynamics) with a Langevin thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\n.\nSet\nISIF\n=3 to allow for relaxation of the cell volume and shape. At the moment, dynamics with\nfixed volume+variable shape\n(\nISIF\n=4) or\nfixed shape+variable volume\n(\nISIF\n=7) are not available.\nSet\nMDALGO\n=3 to invoke the Langevin thermostat.\nSpecify friction coefficients for all species in the\nPOSCAR\nfile, by means of the\nLANGEVIN_GAMMA\n-tag.\nSpecify a separate set of friction coefficient for the lattice degrees-of-freedom, using the\nLANGEVIN_GAMMA_L\n-tag.\nSet a mass for the lattice degrees-of-freedom, using the\nPMASS\n-tag.\nOptionally, one may define an external pressure (in kB), by means of the\nPSTRESS\n-tag.\n\nNote that the advanced simulation protocols, such metadynamics, or geometric constraints and restraints are available within the\nMDALGO\n=3 setting.\n\nStochastic boundary conditions\n\nIn some cases it is desirable to study approach of initially non-equilibrium system to equilibrium. Examples of such simulations include the impact problems when a particle with large kinetic energy hits a surface or calculation of friction force between two surfaces sliding with respect to each other. As shown by Toton\net al.\n[3]\n, this type of problems can be studied using the stochastic boundary conditions (SBC) derived from the generalized Langevin equation by Kantorovich and Rompotis.\n[4]\nIn this approach, the system of interest is divided into three regions: (a) fixed atoms, (b) the internal (Newtonian) atoms moving according to Newtonian dynamics, and (c) a buffer region of Langevin atoms (\ni.e.\n, atoms governed by\nLangevin equations of motion\n) located between (a) and (b).\n\nThe role of the Langevin atoms is to dissipate heat, while the fixed atoms are needed solely to create the correct potential well for the Langevin atoms to move in. The Newtonian region should include all atoms relevant to the process under study: in the case of the impact problem, for instance, the Newtonian region should contain atoms of the molecule hitting the surface and several uppermost layers of the material forming the surface. Performing molecular dynamics with such a setup guarantees that the system (possibly out of equilibrium initially) arrives at the appropriate canonical distribution.\n\nTo run a simulation with stochastic boundary conditions, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\nSet\nISIF\n=2\nSet\nMDALGO\n=3 to invoke the Langevin thermostat\nPrepare the\nPOSCAR\nfile in such a way that the Newtonian and Langevin atoms are treated as different species (even if they are chemically identical). In your\nPOSCAR\n, use \"selective dynamics\" and the corresponding logical flags to define the frozen and moveable atoms.\nSpecify friction coefficients γ, for all species in the\nPOSCAR\nfile, by means of the\nLANGEVIN_GAMMA\n-tag: set the friction coefficients to 0 for all fixed and Newtonian atoms, and choose a proper γ for the Langevin atoms.\n\nPractical example\n\nConsider a system consisting of 16 hydrogen and 48 silicon atoms. Suppose that eight silicon atoms are considered to be Langevin atoms and the remaining 32 Si atoms are either fixed or Newtonian atoms. The Langevin and Newtonian (or fixed) atoms should be considered as different species,\ni.e.\n, the\nPOSCAR\n-file should contain the line like this:\n\nSi H Si\n40 16 8\n\nAs only the final eight Si atoms are considered to be Langevin atoms, the\nINCAR\n-file should contain the following line defining the friction coefficients:\n\nLANGEVIN_GAMMA = 0.0   0.0   10.0\n\ni.e.\n, for all non-Langevin atoms, γ should be set to zero.\n\nMDALGO\n=4: Nose Hoover chains thermostat\n\nFor a description of Nose Hoover chains theromastat, see\nNHC thermostat\n.\n\nTo run an\nNVT\n-simulation with a Nose Hoover chains thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\nSet\nISIF\n=2\nSet\nMDALGO\n=4 to invoke the thermostat, select the number of thermostats in chain via\nNHC_NCHAINS\nand choose an appropriate setting for the thermostat parameter\nNHC_PERIOD\n.\n\nNote that the advanced simulation protocols, such metadynamics, or geometric constraints and restraints are available within the\nMDALGO\n=4 setting.\n\nMDALGO\n=5: Canonical sampling through velocity-rescaling (CSVR thermostat)\n\nMind:\nThis option is available as of VASP 6.4.3.\n\nFor a description of CSVR theromastat, see\nCSVR thermostat\n.\n\nTo run an\nNVT\n-simulation with a CSVR thermostat, one has to:\n\nSet the standard MD-related tags:\nIBRION\n=0,\nTEBEG\n,\nPOTIM\n, and\nNSW\nSet\nISIF\n=2\nSet\nMDALGO\n=5 to invoke the thermostat and choose an appropriate setting for the thermostat parameter\nCSVR_PERIOD\n.\n\nNote that the advanced simulation protocols, such metadynamics, or geometric constraints and restraints are available within the\nMDALGO\n=5 setting.\n\nMDALGO\n=13: Multiple Andersen thermostats\n\nUp to three user-defined atomic subsystems may be coupled with independent Andersen thermostats\n[5]\n(see remarks under\nMDALGO\n=1 as well).\nThe\nPOSCAR\nfile must be organized such that the positions of atoms of subsystem\ni+1\nare defined after those for the subsystem\ni\n, and the following flags must be set by the user:\n\nNSUBSYS\n=[int array]\n\nDefine the last atom for each subsystem (two or three values must be supplied). For instance, if total of 20 atoms is defined in the\nPOSCAR\nfile, and the initial 10 atoms belong to the subsystem 1, the next 7 atoms to the subsystem 2, and the last 3 atoms to the subsystem 3,\nNSUBSYS\nshould be defined as follows:\n\nNSUBSYS\n= 10 17 20\n\nNote that the last number in the previous example is actually redundant (clearly the last three atoms belong to the last subsystem) and does not have to be user-supplied.\n\nTSUBSYS\n=[real array]\n\nSimulation temperature for each subsystem\n\nPSUBSYS\n=[real array]\n\nCollision probability for atoms in each subsystem. Only the values 0≤\nPSUBSYS\n≤1 are allowed.\n\nRelated Tags and Sections\n\nIBRION\n,\nISIF\n,\nSMASS\n,\nANDERSEN_PROB\n,\nRANDOM_SEED\n,\nLBLUEOUT\n,\nSHAKETOL\n,\nSHAKEMAXITER\n,\nHILLS_H\n,\nHILLS_W\n,\nHILLS_BIN\n,\nINCREM\n,\nVALUE_MIN\n,\nVALUE_MAX\n,\nLANGEVIN_GAMMA\n,\nLANGEVIN_GAMMA_L\n,\nPMASS\n,\nNSUBSYS\n,\nTSUBSYS\n,\nPSUBSYS\n,\nICONST\n,\nPENALTYPOT\n,\nHILLSPOT\n,\nREPORT\n\nExamples that use this tag\n\nReferences\n\n↑\nM. Parrinello and A. Rahman, Phys. Rev. Lett.\n45\n, 1196 (1980).\n↑\nM. Parrinello and A. Rahman, J. Appl. Phys.\n52\n, 7182 (1981).\n↑\nD. Toton, C. D. Lorenz, N. Rompotis, N. Martsinovich, and L. Kantorovich, J. Phys.: Condens. Matter 22, 074205 (2010).\n↑\nL. Kantorovich and N. Rompotis, Phys. Rev. B 78, 094305 (2008).\n↑\nH. C. Andersen, J. Chem. Phys. 72, 2384 (1980).",
    "related_tags": []
  },
  "METAGGA": {
    "default_value": "The functional specified by LEXCH in the POTCAR if GGA and XC are also not specified.",
    "description": "Selects a meta-GGA exchange-correlation functional.",
    "detailed_description": "Mind:\nIf you select a meta-GGA functional, make sure that you use\nPOTCAR files that are suited for meta-GGA functionals\n. However, note that this requirement does not concern the deorbitalized meta-GGAs, i.e. those that do not depend on the kinetic-energy density, like SCAN-L.\nDepending on the meta-GGA that is chosen, it may be recommended to use a\nPAW potential\nthat is more accurate than the standard/recommended one. This is particularly the case with functionals (e.g., MBJ or the Minnesota functionals like M06-L) that are very different from the standard ones like PBE or SCAN. The reason is that for such\nspecial\nfunctionals, using a PAW potential that includes more states in the valence or that is harder may be required to obtain results that are closer to the results that would be obtained with an all-electron code. That also means that it may be a good idea to do test calculations with different PAW potentials.\nFor accuracy, it is strongly recommended to set\nLASPH\n=.TRUE. to\naccount for aspherical contributions to the PAW one-centre terms\n.\nSince VASP.6.4.0 it is possible to use hybrid functionals that mix meta-GGA and Hartree-Fock exchange (\nAEXX\n). Furthermore, two new tags,\nAMGGAX\nand\nAMGGAC\n, were created.\nThe\nXC\ntag, available since VASP.6.4.3, can be used to specify any linear combination of LDA,\nGGA\nand\nMETAGGA\nexchange-correlation functionals.\nThe results obtained with the meta-GGA functionals that depend on the Laplacian of the density\n∇\n2\nn\n{\\displaystyle \\nabla^2n}\n(e.g., SCAN-L) may not be reliable for large values of the energy cutoff\nENCUT\ndue to numerical instability. According to some tests, it is not recommended to use values of\nENCUT\nabove 800 eV.\n\nAvailable functionals\n\nThis table lists the meta-GGA functionals available in VASP. There are essentially two types of meta-GGAs, that differ in the variable on which they depend (in addition to\nn\n{\\displaystyle n}\nand\n∇\nn\n{\\displaystyle \\nabla n}\n): the kinetic-energy density\nτ\n{\\displaystyle \\tau}\nor the Laplacian of the density\n∇\n2\nn\n{\\displaystyle \\nabla^2n}\n. The names of functionals which end with \"_X\" and \"_C\" correspond to exchange-only and correlation functionals, respectively. Note that the implementation of\nτ\n{\\displaystyle \\tau}\n-dependent meta-GGA functionals is described in\n[1]\n.\n\nMETAGGA=\nVariable\nDescription\nLIBXC\nAny MGGA from the external library Libxc.\n[2]\n[3]\n[4]\nIt is necessary to have\nLibxc >= 5.2.0 installed\nand VASP.6.3.0 or higher compiled with\nprecompiler options\n. The\nLIBXC1\nand\nLIBXC2\ntags (where examples are shown) are also required.\nTPSS, TPSS_X or TPSS_C\n(1)\nτ\n{\\displaystyle \\tau}\nTPSS.\n[5]\nRTPSS, RTPSS_X or RTPSS_C\n(1)\nτ\n{\\displaystyle \\tau}\nrevTPSS is a revised version of TPSS.\n[6]\nM06L, M06L_X or M06L_C\n(1)\nτ\n{\\displaystyle \\tau}\nM06-L.\n[7]\nMS0, MS0_X or MS0_C\n(1)\nτ\n{\\displaystyle \\tau}\nMS0 corresponds to\nκ\n=\n0.29\n{\\displaystyle \\kappa=0.29}\n,\nc\n=\n0.28771\n{\\displaystyle c=0.28771}\nand\nb\n=\n1.0\n{\\displaystyle b=1.0}\n.\n[8]\n[9]\nNote that the correlation component, called vPBEc or regTPSS in the literature, is a GGA. Available since VASP.5.4.1.\nMS1, MS1_X or MS1_C\n(1)\nτ\n{\\displaystyle \\tau}\nMS1 corresponds to\nκ\n=\n0.404\n{\\displaystyle \\kappa=0.404}\n,\nc\n=\n0.18150\n{\\displaystyle c=0.18150}\nand\nb\n=\n1.0\n{\\displaystyle b=1.0}\n.\n[9]\nNote that the correlation component, called vPBEc or regTPSS in the literature, is a GGA. Available since VASP.5.4.1.\nMS2, MS2_X or MS2_C\n(1)\nτ\n{\\displaystyle \\tau}\nMS2 corresponds to\nκ\n=\n0.504\n{\\displaystyle \\kappa=0.504}\n,\nc\n=\n0.14601\n{\\displaystyle c=0.14601}\nand\nb\n=\n4.0\n{\\displaystyle b=4.0}\n.\n[9]\nNote that the correlation component, called vPBEc or regTPSS in the literature, is a GGA. Available since VASP.5.4.1.\nSCAN, SCAN_X or SCAN_C\n(1)\nτ\n{\\displaystyle \\tau}\nSCAN.\n[10]\nMay possibly lead to numerical instabilities. rSCAN or r\n2\n{\\displaystyle ^{2}}\nSCAN are more stable and should give similar results. Available since VASP.5.4.4.\nRSCAN, RSCAN_X or RSCAN_C\n(1)\nτ\n{\\displaystyle \\tau}\nrSCAN is a regularized version of SCAN that is numerically more stable.\n[11]\nR2SCAN, R2SCAN_X or R2SCAN_C\n(1)\nτ\n{\\displaystyle \\tau}\nr\n2\n{\\displaystyle ^{2}}\nSCAN is a regularized version of SCAN that is numerically more stable.\n[12]\nAvailable since VASP.6.2.0, or in version 5.4.4 by\npatch 4\n.\nSREGTM1, SREGTM2 or SREGTM3\nτ\n{\\displaystyle \\tau}\nsregTM\n[13]\nversions 1, 2 or 3 of a regularized Tao-Mo functional.\n[14]\nAvailable since VASP.6.4.3.\nTASK_X\n(2)\nτ\n{\\displaystyle \\tau}\nTASK exchange.\n[15]\nAvailable since VASP.6.5.0.\nLAK, LAK_X or LAK_C\nτ\n{\\displaystyle \\tau}\nLAK.\n[16]\nAvailable since VASP.6.5.0.\nMSPBEL, MSRPBEL or MSB86BL\nτ\n{\\displaystyle \\tau}\nMS-PBEl, MS-RPBEl or MS-B86bl.\n[17]\nAvailable since VASP.6.5.0.\nRMSPBEL, RMSRPBEL or RMSB86BL\nτ\n{\\displaystyle \\tau}\nrMS-PBEl, rMS-RPBEl or rMS-B86bl.\n[18]\nAvailable since VASP.6.5.0.\nSCANL\n∇\n2\nn\n{\\displaystyle \\nabla^2n}\nSCAN-L\n[19]\n[20]\nis a deorbitalized version of SCAN. Available since VASP.6.4.0.\nRSCANL\n∇\n2\nn\n{\\displaystyle \\nabla^2n}\nrSCAN-L is a deorbitalized version of rSCAN. Available since VASP.6.4.0.\nR2SCANL\n∇\n2\nn\n{\\displaystyle \\nabla^2n}\nr\n2\n{\\displaystyle ^2}\nSCAN-L is a deorbitalized versions of r\n2\n{\\displaystyle ^2}\nSCAN.\n[21]\n[22]\nAvailable since VASP.6.4.0.\nOFR2\n∇\n2\nn\n{\\displaystyle \\nabla^2n}\nOrbital-free regularized-restored SCAN (OFR2).\n[22]\nAvailable since VASP.6.4.0.\nSREGTM2L\n∇\n2\nn\n{\\displaystyle \\nabla^2n}\nv2-sregTM-L is a deorbitalized versions of v2-sregTM.\n[23]\nAvailable since VASP.6.4.0.\nMBJ\n(3)\n∇\n2\nn\n,\nτ\n{\\displaystyle \\nabla^2n,\\tau}\nModified Becke-Johnson potential.\n[24]\n[25]\nThe\nCMBJA\n,\nCMBJB\nand\nCMBJE\ntags correspond to\nα\n{\\displaystyle \\alpha}\n,\nβ\n{\\displaystyle \\beta}\nand the power\ne\n=\n1\n/\n2\n{\\displaystyle e=1/2}\n(that can be modified) in Eq. (3) of Ref.\n[25]\n, respectively. The default values are\nα\n=\n−\n0.012\n{\\displaystyle \\alpha=-0.012}\n,\nβ\n=\n1.023\n{\\displaystyle \\beta=1.023}\nbohr\n1\n/\n2\n{\\displaystyle ^{1/2}}\nand\ne\n=\n1\n/\n2\n{\\displaystyle e=1/2}\n.\n[25]\nLMBJ\n(3)\n∇\n2\nn\n,\nτ\n{\\displaystyle \\nabla^2n,\\tau}\nThe local MBJ (LMBJ) potential.\n[26]\n[27]\nThe\nCMBJA\n,\nCMBJB\n,\nCMBJE\n,\nSMBJ\n, and\nRSMBJ\ntags correspond to\nα\n{\\displaystyle \\alpha}\n,\nβ\n{\\displaystyle \\beta}\n, the power\ne\n=\n1\n{\\displaystyle e=1}\n(that can be modified) of\ng\n¯\n{\\displaystyle \\bar{g}}\n,\nσ\n{\\displaystyle \\sigma}\nand\nr\ns\nt\nh\n{\\displaystyle r_{s}^{\\mathrm{th}}}\nin Eqs. (5)-(7) of Ref.\n[27]\n, respectively. The default values are (see erratum of Ref.\n[27]\n)\nα\n=\n0.488\n{\\displaystyle \\alpha=0.488}\n,\nβ\n=\n0.5\n{\\displaystyle \\beta=0.5}\nbohr,\ne\n=\n1\n{\\displaystyle e=1}\n,\nσ\n=\n2\n{\\displaystyle \\sigma=2}\nÅ\n{\\displaystyle \\AA}\n(\n=\n3.78\n{\\displaystyle =3.78}\nbohr), and\nr\ns\nt\nh\n=\n7\n{\\displaystyle r_{s}^{\\mathrm{th}}=7}\nbohr (which corresponds to\nn\nt\nh\n=\n6.96\n×\n10\n−\n4\n{\\displaystyle n_{\\mathrm{th}}=6.96\\times10^{-4}}\ne/bohr\n3\n{\\displaystyle ^{3}}\n).\n\n(1)\nThe exchange-only and correlation-only implementations are available since VASP.6.4.3.\n\n(2)\nIn Ref.\n[15]\nTASK exchange is combined with LDA-PW92 correlation.\n[28]\nThis can be done with\nXC\n=TASK_X PW92_C in\nINCAR\n.\n\n(3)\nA few points about the MBJ and LMBJ potentials:\n\nThese are\npotential-only\nmethods,\ni.e.\n, there is no corresponding exchange-correlation energy\nE\nx\nc\n{\\displaystyle E_{xc}}\n. The used expression for\nE\nx\nc\n{\\displaystyle E_{xc}}\nis LDA, which is an arbitrary choice. This means that MBJ and LMBJ calculations can never be self-consistent with respect to the total energy, and thus we cannot compute Hellmann-Feynman forces (\ni.e.\n, no ionic relaxation, etc.). Actually, these potentials aim solely at a description of the electronic properties, primarily the band gap, or magnetic moments.\nMBJ and LMBJ calculations may converge very slowly, so the number of maximum electronic steps (\nNELM\n) should be set higher than usual.\nIn the presence of an extended vacuum region (e.g., surfaces) or an interface, the average of\n|\n∇\nn\n|\n/\nn\n{\\displaystyle |\\nabla n|/n}\nhas no meaning. Therefore, MBJ calculations should be done with a fixed value of\nc\n{\\displaystyle c}\n, which can be done with the\nCMBJ\ntag., or alternatively with the LMBJ that was proposed for the purpose to be applicable to systems with vacuum or interfaces.\n\nPOTCAR files: required information\n\nCalculations with a meta-GGA that depends on the kinetic-energy density require\nPOTCAR\nfiles that include information on the kinetic-energy density of the core electrons. Almost all recent\nPOTCAR\nfiles do fulfill this requirement, but there are some notable exceptions like O_GW. To check whether a particular\nPOTCAR\ncontains this information, type:\n\ngrep kinetic POTCAR\n\nThis should yield at least the following lines (for each element on the file):\n\nkinetic energy-density\nmkinetic energy-density pseudized\n\nand for PAW datasets with partial core corrections:\n\nkinetic energy density (partial)\n\nMind:\nFor\nPOTCAR\nfiles without core electrons (H, He, Li_sv, Be_sv, and _GW variants thereof) the\ngrep\ncommand given above will not return the line about pseudized kinetic energy-density, since all electrons are considered as valence. These potentials can nevertheless be used for all meta-GGA functionals.\n\nAspherical contributions related to one-center terms\n\nLASPH\n=.TRUE. should be selected if a meta-GGA functional is selected. If\nLASPH\n=.FALSE.,\nthe one-center contributions are only calculated for a spherically averaged density and kinetic-energy\ndensity. This means that the one-center contributions to the Kohn-Sham potential are also spherical. \nSince the PAW method describes the entire space using plane waves, errors are often small even\nif the non-spherical contributions to the Kohn-Sham potential are neglected inside the PAW spheres\n(additive augmentation, as opposed to the APW or FLAPW method where the plane wave contribution only\ndescribes the interstitial region between the atoms). Anyhow, if the density is strongly non-spherical\naround some atoms in your structure,\nLASPH\n=.TRUE. must be selected. Non-spherical terms are particularly encountered\nin d- and f-elements, dimers, molecules, and solids with strong directional bonds.\n\nConvergence issues\n\nIf convergence problems are encountered, it is recommended to preconverge the\ncalculations using the PBE functional and start the calculation from the\nWAVECAR\nfile corresponding to the PBE ground state. Furthermore,\nALGO\n= A (conjugate gradient algorithm for orbitals) is often more stable\nthan charge density mixing, in particular if the system contains vacuum regions.",
    "related_tags": [
      "LIBXC1",
      "LIBXC2",
      "GGA",
      "XC",
      "CMBJ",
      "CMBJA",
      "CMBJB",
      "CMBJE",
      "SMBJ",
      "RSMBJ",
      "LASPH",
      "LMAXTAU",
      "LMIXTAU",
      "AMGGAX",
      "AMGGAC",
      "Band-structure calculation using meta-GGA functionals"
    ]
  },
  "MINROT": {
    "default_value": "MINROT = 0.01",
    "description": "The flag MINROT defines the value for which the dimer is rotated only if the predicted rotation angle is greater than MINROT (rad.) in the Improved Dimer Method .",
    "detailed_description": "",
    "related_tags": [
      "Improved Dimer Method"
    ]
  },
  "MIXPRE": {
    "default_value": "MIXPRE = 1",
    "description": "MIXPRE specifies the metric in the Broyden mixing scheme( IMIX =4).",
    "detailed_description": "MIXPRE\n=0\n\nNo preconditioning, metric=1\n\nMIXPRE\n=1\n\n\"Inverse Kerker\" metric with automatically determined\nBMIX\n(determined in such a way that the variation of the preconditioning weights covers a range of a factor 20)\n\nMIXPRE\n=2\n\n\"Inverse Kerker\" metric with automatically determined\nBMIX\n(determined in such a way that the variation of the preconditioning weights covers a range of a factor 200)\n\nMIXPRE\n=3 (implemented for test purposes;\nnot\nrecommended)\n\n\"Inverse Kerker\" metric with\nBMIX\nfrom\nINCAR\n, the weights for the metric are given by\nP\n(\nG\n)\n=\n1\n+\nB\n2\nG\n2\n{\\displaystyle P\\left(G\\right)=1+\\frac{B^2}{G^2}}\nwith\nB\n{\\displaystyle B}\n=\nBMIX\n.\n\nThe preconditioning is done only on the total charge density (i.e. up+down component) and not on the magnetization charge density (i.e. up-down component). In our experience, the introduction of a metric always improves the convergence speed. The best choice is\nMIXPRE\n=1 (i.e. the default).",
    "related_tags": [
      "IMIX",
      "INIMIX",
      "MAXMIX",
      "AMIX",
      "BMIX",
      "AMIX_MAG",
      "BMIX_MAG",
      "AMIN",
      "WC"
    ]
  },
  "ML_AFILT2": {
    "default_value": "ML_AFILT2 = 0.002",
    "description": "This tag sets the filtering parameter for the angular filtering for ML_IAFILT2 in the machine learning force field method.",
    "detailed_description": "This tag is only used if\nML_LAFILT2\n=\n.TRUE.\nand\nML_IAFILT2\n=2 are used.\n\nThe angular filtering function\n[1]\nfor\nML_IAFILT2\n=2 is described as\nη\nl\n,\na\nF\nI\nL\nT\n=\n1\n1\n+\na\nF\nI\nL\nT\n[\nl\n(\nl\n+\n1\n)\n]\n2\n{\\displaystyle \\eta_{l,a_{\\mathrm{FILT}}}=\\frac{1}{1+a_{\\mathrm{FILT}} [l (l+1)]^{2}} }\n. The tag\nML_AFILT2\nsets the parameter\na\nF\nI\nL\nT\n{\\displaystyle a_{\\mathrm{FILT}}}\n.\n\nReferences\n\n↑\nJ. P. Boyd, Chebyshev and Fourier Spectral Methods (Dover Publications, New York, 2000).",
    "related_tags": [
      "ML_LMLFF",
      "ML_LAFILT2",
      "ML_IAFILT2"
    ]
  },
  "ML_CALGO": {
    "default_value": "ML_CALGO = 0",
    "description": "Chooses error estimation type for on-the-fly training or reselection of local referenc configurations.",
    "detailed_description": "This tag chooes which algorithm is employed for the error estimation in\nML_MODE\n=\nTRAIN\nor\nSELECT\n. The following two choices are available:\n\nML_CALGO\n=0: Bayesian error estimation. Constant or variable threshold. Default.\nML_CALGO\n=1: Spilling factor. Constant threhold.\n\nIn both modes an ab-initio calculation is carried out if the value of the error estimate is above a threshold specified by\nML_CTIFOR\n. In both algorithms the estimators have different units, values and hence defaults for this threshold. \nIn contrast to the Bayesian error estimation which can be run in many different modes for the threhold update (see\nML_ICRITERIA\n), the spilling factor can only be used with a constant threshold (\nML_ICRITERIA\n=0).",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_ICRITERIA",
      "ML_CTIFOR"
    ]
  },
  "ML_CDOUB": {
    "default_value": "Default: ML_CDOUB = 4.0 for ML_MODE = select | = 2.0 else",
    "description": "This tag controls the criterion for \"enforced\" DFT calculations within the machine learning force field method.",
    "detailed_description": "The usage of this tag in combination with the learning algorithms is described here:\nhere\n.\n\nIf at any time, the estimated force errors are\nML_CDOUB\ntimes larger than the Bayesian threshold (i.e. \"critically\" high), a first principles calculation is performed and a new force field is immediately generated (even if the counter for sampling is below the minimum amount of sampled structures\nML_NMDINT\n).",
    "related_tags": [
      "ML_LMLFF",
      "ML_MCONF_NEW",
      "ML_CTIFOR",
      "ML_NMDINT"
    ]
  },
  "ML_CSIG": {
    "default_value": "ML_CSIG = 0.4 {\\displaystyle 0.4}",
    "description": "Parameter used in the automatic determination of threshold ML_CTIFOR for error estimation in the machine learning force field method.",
    "detailed_description": "The usage of this tag in combination with the learning algorithms is described here:\nhere\n.\n\nThe standard error of the history of maximum estimated errors of the forces (\nML_MHIS\n) and it's slope must be below\nML_CSIG\nand\nML_CSLOPE\nso that an update of the threshold for the maximum estimated error of forces\nML_CTIFOR\ncan take place.",
    "related_tags": [
      "ML_LMLFF",
      "ML_ICRITERIA",
      "ML_CSLOPE",
      "ML_MHIS",
      "ML_CTIFOR",
      "ML_CX"
    ]
  },
  "ML_CSLOPE": {
    "default_value": "ML_CSLOPE = 0.2 {\\displaystyle 0.2}",
    "description": "Parameter used in the automatic determination of threshold for error estimation in the machine learning force field method.",
    "detailed_description": "The usage of this tag in combination with the learning algorithms is described here:\nhere\n.\n\nThe standard error of the history of maximum estimated errors of the forces (\nML_MHIS\n) and it's slope must be below\nML_CSIG\nand\nML_CSLOPE\nso that an update of the threshold for the maximum estimated error of forces\nML_CTIFOR\ncan take place.",
    "related_tags": [
      "ML_LMLFF",
      "ML_ICRITERIA",
      "ML_CSIG",
      "ML_MHIS",
      "ML_CX"
    ]
  },
  "ML_CTIFOR": {
    "default_value": "Default: ML_CTIFOR = 0.002 if ML_CALGO = 0 | = 0.02 if ML_CALGO = 1",
    "description": "This flag sets the threshold for the error estimation in the machine learning force field method.",
    "detailed_description": "The use of this tag in combination with the learning algorithms is described here:\nhere\n. Generally, first principles calculations are only performed if the error estimate of one force exceeds the threshold.\n\nThe initial threshold is set to the value provided by the tag\nML_CTIFOR\n(units of eV/Angstrom for\nML_CALGO\n=0 and unitless for\nML_CALGO\n=1).\n\nFor\nML_CALGO\n=0, the threshold can be updated dynamically during ML. The details of the update are controlled by\nML_ICRITERIA\n. Typically, after extensive training, attainable values for ML_CTIFOR are 0.02 around 300-500 K, and 0.06 around 1000-2000 K, so temperature but also system dependent. The initial default 0.002 is only sensible, if\nML_CTIFOR\nis automatically updated (\nML_ICRITERIA\n= 1 or 2). If\nML_ICRITERIA\n= 0 is used, it is necessary to use significantly larger values around 0.02-0.06 for\nML_CTIFOR\n.\n\nFor\nML_CALGO\n=1, only a constant threshold during the calculation is available (\nML_ICRITERIA\n=0).\n\nThe related tag\nML_SCLC_CTIFOR\ndetermines how many local reference configurations are chosen from each first principles calculations.",
    "related_tags": [
      "ML_LMLFF",
      "ML_ICRITERIA",
      "ML_CALGO",
      "ML_SCLC_CTIFOR",
      "ML_MHIS",
      "ML_CSIG",
      "ML_CSLOPE",
      "ML_CDOUB",
      "ML_CX",
      "ML_NMDINT",
      "ML_MCONF_NEW"
    ]
  },
  "ML_CX": {
    "default_value": "ML_CX = 0.0",
    "description": "The parameter determines to which value the threshold ( ML_CTIFOR ) is updated within the machine learning force field methods.",
    "detailed_description": "The use of this tag in combination with the learning algorithms is described here:\nhere\n.\n\nIf\nML_ICRITERIA\n>0,\nML_CTIFOR\nis set to the average of the errors of the forces stored in a history. Note that\nML_ICRITERIA\n=1 and\nML_ICRITERIA\n=2, average over different data. In the first case the average is performed over errors after updates of the force fields, and in the second case over all recent error estimates (see\nML_ICRITERIA\n). In both cases, if\nML_CTIFOR\nis updated, it is set to\n\nML_CTIFOR\n= (average of the stored errors in the history) *(1.0 +\nML_CX\n).\n\nObviously setting\nML_CX\nto a positive value will result in fewer first principles calculations and fewer updates of the MLFF, whereas negative values result in more frequent first principles calculations (as well as updates of the MLFF). Typical values of\nML_CX\nare between -0.2 and 0.0 for\nML_ICRITERIA\n=1, and 0.0 and 0.3 for\nML_ICRITERIA\n=2 (a good starting value is 0.2 for\nML_ICRITERIA\n=2). For training runs using heating, the default usually results in very well balanced machine learned force fields. When the training is performed at a fixed temperature, it is often desirable to decrease to\nML_CX\n=-0.1, in order to increase the number of first principle calculations and thus the size of the training set (the default can result in too few training data).\n\nThe number of entries in the history are controlled by\nML_MHIS\nfor\nML_ICRITERIA\n=1, and it is currently fixed to 400 for\nML_ICRITERIA\n=2 (in future releases 50 x\nML_MHIS\n).",
    "related_tags": [
      "ML_LMLFF",
      "ML_ICRITERIA",
      "ML_CTIFOR",
      "ML_MHIS",
      "ML_CSIG",
      "ML_CSLOPE"
    ]
  },
  "ML_DESC_TYPE": {
    "default_value": "ML_DESC_TYPE = 0",
    "description": "Selects the descriptor type of the three-body descriptor used in machine learning force fields.",
    "detailed_description": "ML_DESC_TYPE\nselects how the three-body descriptor is calculated, and the following options are available:\n\nML_DESC_TYPE\n= 0\n:\nStandard three-body descriptor\n, where the number of descriptors in the calculation scales quadratically with the number of elements.\nML_DESC_TYPE\n= 1\n:\nElement-reduced descriptor\nfor which the number of descriptors is linearly scaling with respect to the number of chemical species.\n\nMind:\nThis tag is only available as of VASP 6.4.3 or higher.\n\nMind:\nML_DESC_TYPE\nis available for all options of\nML_MODE\nfor VASP >= 6.5.0. For VASP < 6.5.0, it was only available for\nML_MODE\n= refit\nand\nML_MODE\n= run\n.\n\nStandard three-body descriptor\n\nThe standard three-body descriptor (\nML_DESC_TYPE\n=0) without self-interaction corrections for the\ni\n{\\displaystyle i}\nth atom looks like the following\n\np\nn\nν\nl\ni\nJ\nJ\n′\n=\n8\nπ\n2\n2\nl\n+\n1\n∑\nm\n=\n−\nl\nl\nc\nn\nl\nm\ni\nJ\nc\nν\nl\nm\ni\nJ\n′\n.\n{\\displaystyle  \np_{n\\nu l}^{iJJ'}=\\sqrt{\\frac{8\\pi^{2}}{2l+1}} \\sum\\limits_{m=-l}^{l} c_{nlm}^{iJ} c_{\\nu lm}^{iJ'}.\n}\n\nHere\nn\n{\\displaystyle n}\n/\nν\n{\\displaystyle \\nu}\n,\nl\n{\\displaystyle l}\nand\nm\n{\\displaystyle m}\nare radial, angular, and magnetic quantum numbers, respectively.\nJ\n{\\displaystyle J}\nand\nJ\n′\n{\\displaystyle J'}\nare indices for the element types. Both indices go over all elements in the structure. So one can see that the number of three-body descriptors grows quadratically with the number of element types.\n\nElement-reduced descriptor\n\nAnother type of descriptor (\nML_DESC_TYPE\n=1) which was proposed in Ref.\n[1]\napplies a reduction of one of the intermediate coefficients\nc\nn\nl\nm\n{\\displaystyle c_{nlm}}\nand is written as\n\np\nn\nν\nl\ni\nJ\n=\n8\nπ\n2\n2\nl\n+\n1\n∑\nm\n=\n−\nl\nl\nc\nn\nl\nm\ni\nJ\n∑\nJ\n′\nc\nν\nl\nm\ni\nJ\n′\n.\n{\\displaystyle  \np_{n\\nu l}^{iJ}=\\sqrt{\\frac{8\\pi^{2}}{2l+1}} \\sum\\limits_{m=-l}^{l}  c_{nlm}^{iJ} \\sum\\limits_{J'}c_{\\nu lm}^{iJ'}.\n}\n\nIn contrast to the standard three-body descriptor\np\nn\nν\nl\ni\nJ\n{\\displaystyle p_{n\\nu l}^{iJ}}\ndepends only linearly on the number of chemical species, since summing over\nJ\n′\n{\\displaystyle J'}\nfor\nc\nν\nl\nm\ni\nJ\n′\n{\\displaystyle c_{\\nu lm}^{iJ'}}\nis equivalent to having element agnostic intermediate coefficients. When using this descriptor everything up to the calculation of the descriptors takes the same time to calculate as for the standard descriptor, but everything that comes after that, such as e.g. kernels and forces, scales linearly with respect to the number of chemical species. Hence the factor that is gained in computational efficiency is less than the number of chemical species but the factor increases with an increasing number of local reference configurations employed in the calculations. The improved computational efficiency comes at the price of decreased accuracy. The accuracy loss is system-dependent and is typically around 5 to 20 percent.\n\nAdditional sparsification\n\nAll descriptors can be further combined with\ndescriptor sparsification\n(\nML_LSPARSDES\n=\n.TRUE.\n). Generally, the sparsification of descriptors results in a trade-off between accuracy and efficiency. The fraction of descriptors that is kept is specified by\nML_RDES_SPARSDES\n. We advise the user to adjust this parameter carefully and test it individually for each system. However, we have experienced the following trends for our test cases: For\nML_DESC_TYPE\n=0 a descriptor sparsification of 50 percent\nML_RDES_SPARSDES\n=0.5 leaves the accuracy almost untouched. Since\nML_DESC_TYPE\n=1 contains already much fewer descriptors than\nML_DESC_TYPE\n=0, a 50 percent sparsification for\nML_DESC_TYPE\n=1 results in noticeable accuracy loss (additionally to the 5 to 20 percent by the descriptor itself).",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_LSPARSDES",
      "ML_RDES_SPARSDES"
    ]
  },
  "ML_EATOM_REF": {
    "default_value": "ML_EATOM_REF = 0.0",
    "description": "Reference total energies of isolated atoms used in the machine learning force field method.",
    "detailed_description": "This tag is only used if\nML_ISCALE_TOTEN\n= 1\n.\n\nIf\nML_EATOM_REF\nis not provided in the\nINCAR\nfile then 0.0 is assumed for all species in the system.\n\nBy default this tag is not used since all energies are scaled to the average of the training data (\nML_ISCALE_TOTEN\n= 2\n).\n\nIf this tag is used, each reference energy should be obtained from a VASP calculation of an isolated atoms in a sufficiently large simulation box. The reference is then simply taken from the Helmholtz free energy from the\nOSZICAR\nfile (value following \"1 F=\" in that file).\n\nThe reference energies are simply set in one line as a list for each species, i.e. like the following\n\nML_EATOM_REF = E_1 E_2 E_3 ...\n\nwhere E_1, E_2, E_2 etc. are the energies for species 1, 2, 3 etc. (corresponding to the order they occur in the\nPOTCAR\nfile).\n\nThe unit of the energies is eV/atom.\n\nMind:\nReference energies are stored in the\nML_AB\nfile and are reused whenever the file is read in, i.e, in case of a continued training (\nML_MODE\n= train\nwith\nML_AB\npresent), refitting (\nML_MODE\n= refit\n) or a re-selection run (\nML_MODE\n= select\n). However, since VASP 6.4.3 the values in the\nINCAR\nfile take precedence, hence, reference energies from the\nML_AB\nfile can be updated by providing new values for the\nML_EATOM_REF\ntag in the\nINCAR\nfile. In case you are unsure, check the\nML_LOGFILE\nwhich lists the values actually used.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_ISCALE_TOTEN"
    ]
  },
  "ML_EPS_LOW": {
    "default_value": "Default: ML_EPS_LOW = 1E-11 for ML_MODE = SELECT, REFIT | = 1E-9 else (vasp.6.3.0 default was 1E-10, see comments below)",
    "description": "Threshold for the CUR algorithm used in the sparsification of local reference configurations within the machine learning force fields.",
    "detailed_description": "This value sets the threshold for the eigenvalues that contribute to the leverage scoring used in the CUR algorithm for the rank compression (\"sparsification\") of the local configurations (for details see appendix E of reference\n[1]\n). Small eigenvalues and those columns (local configurations) that are strongly connected\nwith these small eigenvalues are removed by the sparsification routines. The default value is fairly well balanced, and we do not  recommend to increase the threshold to values \nlarger than 1E-7. Also using smaller values than 1E-9 does not improve the MLFF if Bayesian regression is used\n(but it can be benficial for SVD).\n\nThe description how to choose\nML_EPS_LOW\nfor accurate force fields is given\nhere\n.\n\nOn the theory of the sparsification of local reference configurations see\nhere\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MB",
      "ML_EPS_REG",
      "ML_IALGO_LINREG"
    ]
  },
  "ML_EPS_REG": {
    "default_value": "ML_EPS_REG = 1E-15",
    "description": "Initial value for the threshold of the eigenvalues of the covariance matrix in the evidence approximation.",
    "detailed_description": "This threshold is used to determine which eigenvalues\nλ\nk\n{\\displaystyle \\lambda_{k}}\nof the covariance matrix\nΦ\nT\nΦ\n/\nσ\nv\n2\n{\\displaystyle \\mathbf{\\Phi}^{\\mathrm{T}}\\mathbf{\\Phi}/\\sigma^{2}_{\\mathrm{v}}}\nare used in the optimization of the regularization parameters\nσ\nw\n2\n{\\displaystyle \\sigma^{2}_{\\mathrm{w}}}\nand\nσ\nv\n2\n{\\displaystyle \\sigma^{2}_{\\mathrm{v}}}\ndetermined by the following equations\n\nσ\nw\n2\n=\n|\nw\n¯\n|\n2\nγ\n,\n{\\displaystyle \n\\sigma^{2}_{\\mathrm{w}}=\\frac{|\\mathbf{\\bar{w}}|^{2}}{\\gamma},\n}\n\nσ\nv\n2\n=\n|\nT\n−\nϕ\nw\n¯\n|\n2\nM\n−\nγ\n,\n{\\displaystyle \n\\sigma^{2}_{\\mathrm{v}}=\\frac{|\\mathbf{T}-\\mathbf{\\phi}\\mathbf{\\bar{w}}|^{2}}{M-\\gamma},\n}\n\nγ\n=\n∑\nk\n=\n1\nN\nB\nλ\nk\nλ\nk\n+\n1\n/\nσ\nw\n2\n{\\displaystyle \n\\gamma=\\sum\\limits_{k=1}^{N_{\\mathrm{B}}} \\frac{\\lambda_{k}}{\\lambda_{k}+1/\\sigma^{2}_{\\mathrm{w}}} \n}\n.\n\nAll eigenvalues satisfying\nλ\ni\n/\nλ\nm\na\nx\n{\\displaystyle \\lambda_{i} / \\lambda_{\\mathrm{max}} }\n>\nML_EPS_REG\nare included in the above equations, whereas smaller eigenvalues are disregarded (they are anyway potentially inaccurate because of loss of significance).\n\nIf at any point during iterating the above equations, the quadratic norm of errors (eight column of\nREGR/REGRF\nin\nML_LOGFILE\n) becomes too large (more than 1.2 times larger than in previous iterations), the code assumes that numerical issues\n(loss of significance) have occurred, and  then\nML_EPS_REG\nis automatically doubled. Furthermore, if the regression does not converge within 10 steps,\nML_EPS_REG\nis also increased by a factor of 4. The maximum allowed iteration depths is 50 (the iteration number is the second entry of\nREGR/REGRF\nin\nML_LOGFILE\n). When 50 iterations are reached, no force field is created and there is most likely something seriously wrong in the calculation.\n\nThe seventh entry of\nREGR/REGRF\nin the\nML_LOGFILE\nshows the ratio of the regularization (\nσ\nv\n2\n/\nσ\nw\n2\n{\\displaystyle \\sigma_{v}^{2}/ \\sigma_{w}^{2}}\n) and the largest eigenvalue. Usually this number is a number with many varying digits. If this number becomes a \"well rounded\" number (e.g. 1.00000000E-14), this is an indication that the cap for the current\nML_EPS_REG\nis reached. That means that regularization becomes crucial.",
    "related_tags": [
      "ML_LMLFF",
      "ML_IALGO_LINREG",
      "ML_IREG",
      "ML_SIGV0",
      "ML_SIGW0"
    ]
  },
  "ML_IAFILT2": {
    "default_value": "ML_IAFILT2 = 2",
    "description": "This tag specifies the type of angular filtering used in the machine learning force field method.",
    "detailed_description": "Fig. 1: Square of filtering function.\n\nThis tag is only used if\nML_LAFILT2\n=\n.TRUE.\nis set.\n\nFollowing cases are possible for the angular filtering function\nη\n{\\displaystyle \\eta}\n(see also\nhere\n):\n\nML_IAFILT2\n=1: The angular filtering function is described as\nη\nl\n=\n1\n(\n2\nl\n+\n1\n)\n1\n/\n4\n{\\displaystyle \\eta_{l}=\\frac{1}{(2l+1)^{1/4}}}\n.\nML_IAFILT2\n=2: The angular filtering function\n[1]\nis described as\nη\nl\n,\na\nF\nI\nL\nT\n=\n1\n1\n+\na\nF\nI\nL\nT\n[\nl\n(\nl\n+\n1\n)\n]\n2\n{\\displaystyle \\eta_{l,a_{\\mathrm{FILT}}}=\\frac{1}{1+a_{\\mathrm{FILT}} [l (l+1)]^{2}} }\n. Using this function the parameter\na\nF\nI\nL\nT\n{\\displaystyle a_{\\mathrm{FILT}}}\nhas to be defined too. It is set in the\nINCAR\nfile by setting\nML_AFILT2\n. This option is the default.\n\nIn the case of the angular descriptor two radial basis functions are multiplied by each other (see\nhere\n). Both basis functions use the same filtering function and hence the filtering is done by the square of the filtering function. This is plotted in Fig. 1 for the two different functions used for\nML_IAFILT2\n=1 and 2 (labeled as TYPE1 and TYPE2, respectively). In the case of\nML_IAFILT2\n=2 it can be seen that for the filtering parameter\nML_AFILT2\n=0.002 and\nl\n{\\displaystyle l}\n=5 the function has only a contribution of 0.15. Using this filtering parameter the maximum cut-off for the angular quantum number can be reduced to\nML_LMAX2\n=4.\n\nReferences\n\n↑\nJ. P. Boyd, Chebyshev and Fourier Spectral Methods (Dover Publications, New York, 2000).",
    "related_tags": [
      "ML_LMLFF",
      "ML_LAFILT2",
      "ML_AFILT2"
    ]
  },
  "ML_IALGO_LINREG": {
    "default_value": "ML_IALGO_LINREG = 1",
    "description": "This tag determines the algorithm that is employed to solve the system of linear equations in the ridge regression method for machine learning.",
    "detailed_description": "In the ridge regression method for machine learning one needs to solve for the unknown weights\nw\n{\\displaystyle \\mathbf{w}}\nminimizing\n\n|\n|\nY\n−\nΦ\nw\n|\n|\n→\nmin\n.\n{\\displaystyle \n || \\mathbf{Y} - \\mathbf{\\Phi} \\mathbf{w} || \\rightarrow \\mbox{min}.\n}\n\nFor the theory of the available methods please see\nhere\n.\n\nThe following options are available to solve for\nw\n{\\displaystyle \\mathbf{w}}\n:\n\nML_IALGO_LINREG\n=1: Bayesian linear regression (see\nhere\n). Recommended for\nNSW\n≥\n{\\displaystyle \\ge}\n1. Usable with\nML_MODE\n=\nTRAIN\n,\nSELECT\n, and\nREFITBAYESIAN\n.\nML_IALGO_LINREG\n=2: QR factorization. Usable with\nML_MODE\n=\nREFIT\nand\nREFITBAYESIAN\n.\nML_IALGO_LINREG\n=3: Singular value decomposition. Usable with\nML_MODE\n=\nREFIT\nand\nREFITBAYESIAN\n.\nML_IALGO_LINREG\n=4: Singular value decomposition with Tikhonov regularization. The regularization can be controlled via\nML_SIGW0\n. Usable with\nML_MODE\n=\nREFIT\nand\nREFITBAYESIAN\n.\n\nFor on the fly learning\nML_MODE\n=\nTRAIN\nand reselection of local reference configurations\nML_MODE\n=\nSELECT\n, it is strictly necessary to use Bayesian regression (\nML_IALGO_LINREG\n=1), since uncertainty estimates are only available for Bayesian regression.\n\nRefitting\n:\nAlthough the above modes result in an\nML_FFN\nfile that could be used for production runs, we strongly advise to refit the\nML_ABN\nfiles. For that copy the\nML_ABN\nfile to the\nML_AB\nfile and use\nML_MODE\n=\nREFIT\n(if Bayesian error estimation is required during production runs\nML_MODE\n=\nREFITBAYESIAN\nis an option, but at the cost of significatnly slower calculation time).\nML_MODE\n=\nREFIT\nemploys\nML_IALGO_LINREG\n=4 by default.\n\nFor\nML_IALGO_LINREG\n>1,\nML_IALGO_LINREG\n=3 and 4 are the most tested approaches and we use\nML_IALGO_LINREG\n=4 routinely before employing a machine learned force field.\nML_IALGO_LINREG\n=4 gives more stable force fields and better fitting accuracy than\nML_IALGO_LINREG\n=3, due to the regularization term employed (for details please see\nhere\n).\n\nML_IALGO_LINREG\n=4 dramatically improves the condition number of the fitting compared to\nML_IALGO_LINREG\n=1 since it directly uses the design matrix. In contrast\nML_IALGO_LINREG\n=1 requires to use the covariance matrix (square of the design matrix), which effectively doubles the condition number.\nHowever,\nML_IALGO_LINREG\n=4 needs significantly more memory than\nML_IALGO_LINREG\n=1 (at least twice that much). Please always monitor the memory estimates in the\nML_LOGFILE\n! It should be also noted that\nML_IALGO_LINREG\n=4 is computationally somewhat more demanding than\nML_IALGO_LINREG\n=1, but it typically requires between a few minutes and an hour. So usually the extra cost is negligible compared to the original training.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_W1",
      "ML_WTOTEN",
      "ML_WTIFOR",
      "ML_WTSIF",
      "ML_SIGW0"
    ]
  },
  "ML_ICOUPLE": {
    "default_value": "",
    "description": "This tag specifies the atoms where the coupling parameter is introduced to calculate the chemical potential within the machine learning force field method.",
    "detailed_description": "Atom are ordered according to the\nPOSCAR\nfile and indices start with index 1. For thermodynamic integration calculations please have a look at the tag\nML_LCOUPLE\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_LCOUPLE",
      "ML_NATOM_COUPLED",
      "ML_RCOUPLE"
    ]
  },
  "ML_ICRITERIA": {
    "default_value": "Default: ML_ICRITERIA = 3 if ML_MODE = SELECT and ML_CALGO = 0 | = 1 if ML_MODE != SELECT and ML_CALGO = 0 | = 0 if ML_CALGO = 1",
    "description": "Decides how the error threshold ( ML_CTIFOR ) is updated within the machine learning force field method. ML_CTIFOR determines whether a first-principles calculation is performed.",
    "detailed_description": "The use of this tag in combination with the learning algorithms is described here:\nhere\n.\n\nThe following options are possible for\nML_ICRITERIA\n:\n\nML_ICRITERIA\n= 0: The threshold\nML_CTIFOR\nis not updated. This method is the only method used for\nML_CALGO\n=1. For\nML_CALGO\n=0, this method is only recommended for refining an existing force field. For example, if you know that\nML_CTIFOR\nhas taken a value of 0.03 in previous runs, you can continue to collect training data by now setting the threshold to\nML_CTIFOR\n=0.03 to capture all contours and areas of the potential energy surface where first-principles data are still missing. To achieve extremely robust force fields, it is recommended to run\nNSW\n=100000 steps in this mode to slightly above the highest temperature to be considered.\nML_ICRITERIA\n= 1: Set\nML_CTIFOR\nto a value proportional to the average errors of the\nML_MHIS\nsteps.\nML_ICRITERIA\n= 1, the average is calculated only for errors after updating the force field. Such updates are quite rare, so updates of\nML_CTIFOR\nare also quite rare in this mode. Furthermore, since the first principle calculations are only performed for configurations with large errors (\"outliers\"), the force field is updated only after the outliers are taken into account. Therefore, the  errors included in the averaging are typically larger than the average error in this mode.  It is therefore recommended to set\nML_CX\nto 0 (default) in this mode.\nML_ICRITERIA\n= 2: Update the criteria using the moving average of all previous errors. This method gives the average of the errors of all previous predictions (i.e. all previously considered MD steps), while\nML_ICRITERIA\n= 1 gives only the average of the predictions immediately following the retraining. The length of the history in this mode is currently hard-coded and set to 400 steps (or\nML_MHIS\nx 50 in the newer version). This mode tends to continue sampling, and is therefore somewhat prone to oversampling: as errors decrease, the threshold is steadily lowered and additional first-principles computations are initiated. The recommended values for\nML_CX\nin this mode are approximately 0.1 to 0.3. = 0,2, a first-principles calculation is typically performed every 50 steps. This means that if the number of ionic steps is, say,\nNSW\n=50,000, then about 1,000 first-principles calculations should be performed. For many materials, this results in a reasonably good and robust ML database.\nML_ICRITERIA\n=3: This mode is the default for reselecting local reference configurations from an existing\nML_AB\nfile (\nML_MODE\n=\nSELECT\n). The\nML_AB\nfile shall contain a\nML_CTIFOR\nfor each structure stored in the\nML_AB\nfile. These values are used by VASP as error thresholds for structure selection. This also means that the tags\nML_CTIFOR\n,\nML_CX\n,\nML_CSLOPE\n,\nML_CSIG\nand\nML_MHIS\nset in\nINCAR\nare ignored. This mode is only available when\nML_MODE\n=\nSELECT\nis activated. It is important that the\nML_AB\nfile contains a\nML_CTIFOR\nvalue for each structure included. Otherwise, VASP will throw an error and will also indicate to the user that some\nML_CTIFOR\nvalues are missing from the\nML_AB\nfile.\n\nAs mentioned above, the\nML_CX\ntag can be used to fine-tune the update of\nML_CTIFOR\n. \nThe fact that the\nML_ICRITERIA\n= 1 or\nML_ICRITERIA\n= 2 is a matter of taste. Just remember that\nML_CX\nmust be set differently in both modes.  While\nML_ICRITERIA\n= 1, the\nML_CX\n= 0.0,\nML_ICRITERIA\n= 2,\nML_CX\n= 0.2 is a good default.  \nMost of our force fields use\nML_ICRITERIA\n= 1, but this mode sometimes stagnates and stops the first principle calculations.\nOn the other hand, and as already mentioned, using\nML_ICRITERIA\n= 2 is prone to oversampling, i.e. it may perform too many first principle calculations.",
    "related_tags": [
      "ML_LMLFF",
      "ML_CTIFOR",
      "ML_CSLOPE",
      "ML_CSIG",
      "ML_MHIS",
      "ML_CX",
      "ML_CALGO"
    ]
  },
  "ML_IERR": {
    "default_value": "ML_IERR = 0",
    "description": "Calculation and output frequency of error estimates for ML_MODE = RUN computations.",
    "detailed_description": "This tag sets the interval in units of molecular-dynamics steps at which the error estimates are written to the\nML_LOGFILE\n. The error estimate is computed by utilizing the\nspilling factor\nif a refit with\nML_MODE\n=\nREFIT\nwas done. The\nspilling factor\nis calculated for each atom in the current structure and the maximum among all atoms is written to the\nML_LOGFILE\nfile marked with\nSFF\n.\n\nThe\nspilling factor\nmeasures the similarity of the local environment of each atom in the current structure to that of the local reference configurations of the force field. The values of the spilling factor are in the range\n[\n0\n,\n1\n]\n{\\displaystyle [0,1]}\n. If the atomic environment is \"properly\" represented by the local reference configurations the spilling factor approaches 0. Vice versa the\nspilling factor\nquickly approaches 1, if the force field is extrapolating.\n\nThe calculation of the spilling factor scales quadratically with the number of local reference configurations and linearly with the number of species. For force fields containing many species and/or local reference configurations, the evaluation time of the spilling factor becomes of the order of the evaluation of a single force field step or more. Since it is sufficient to monitor the error every\nML_IERR\nMD steps, the total time consumed by the evaluation of the spilling factor can become insignificantly compared to the total time.\n\nIn long molecular dynamics calculations, we recommend to use at least\nML_IERR\n=20-100.\n\nML_IERR\ncan be freely chosen only if\nML_MODE\n=\nRUN\n. In any other calculation mode, if\nML_IERR\nis not equal to 1, the code will exit with an error and provide an error description.\n\nFor calculations using force fields obtained by\nML_MODE\n=\nREFITBAYESIAN\nor without any refitting, the Bayesian error estimates of energy, forces and stress (\nBEFF\n) are additionally written out to the\nML_LOGFILE\nfile and their output frequency is also controlled by\nML_IERR\n. Albeit having the advantage of an additional error estimate we still do not recommend using these force fields, since they are significantly slower than force fields obtained by\nML_MODE\n=\nREFIT\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_LFAST",
      "ML_OUTBLOCK",
      "ML_OUTPUT_MODE",
      "ML_CALGO"
    ]
  },
  "ML_IREG": {
    "default_value": "ML_IREG = 2",
    "description": "This tag specifies whether the regularization parameters are kept constant or not in the machine learning force field method.",
    "detailed_description": "The following cases are possible for this tag:\n\nML_IREG\n=1: The (initial) precision (\nML_SIGV0\n) and noise (\nML_SIGW0\n) parameters are kept constant.\nML_IREG\n=2: The parameters are optimized (default).\n\nFor the optimization of the noise parameter\nσ\nv\n2\n{\\displaystyle \\sigma_{\\mathrm{v}}^{2}}\nsee\nthis section\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_SIGV0",
      "ML_SIGW0"
    ]
  },
  "ML_ISCALE_TOTEN": {
    "default_value": "ML_ISCALE_TOTEN = 2",
    "description": "This tag specifies how to scale the energy data in the machine learning force field method.",
    "detailed_description": "The following cases are possible:\n\nML_ISCALE_TOTEN\n= 1\n: The total energy is scaled to the total energy of the isolated atoms given by\nML_EATOM_REF\n.\nML_ISCALE_TOTEN\n= 2\n: The total energy is scaled to the average of the training data. This is the default setting.",
    "related_tags": [
      "ML_LMLFF",
      "ML_EATOM_REF"
    ]
  },
  "ML_ISTART": {
    "default_value": "ML_ISTART = 0 Warning: This tag is deprecated and we advise to use ML_MODE instead.",
    "description": "This tag selects the mode of operation (e.g. start from scratch, prediction-only,...) of the machine learning force fields method.",
    "detailed_description": "If the machine learning force fields method is enabled via\nML_LMLFF\n= .TRUE., this tag further specifies the mode of operation when VASP is run. The following cases can be selected:\n\nML_ISTART\n= 0: On-the-fly learning is enabled, starting from scratch. Force predictions from the machine learning force field are used to drive the MD simulation. However, if the error estimation performed in each time step indicates a high force error an ab initio calculation is performed instead and the collected energy, forces and stress are used to improve the machine learning force field. Setting\nML_ISTART\n= 0 starts the machine learning force field from scratch. Hence, in the beginning of the MD run there is no force field available and ab initio calculations will happen frequently.\nML_ISTART\n= 1: Same as\nML_ISTART\n= 0 but taking into account pre-existing ab initio data. This is the usual choice for continuing a previous MD simulation with activated machine learning. Before the MD run starts the\nML_AB\nfile, copied from\nML_ABN\nfrom a previous run, is read and the contained ab initio energies, forces and stresses are used to generate an initial force field. Note that this preparative learning step adopts the previous choice of local reference configurations, i.e. the reference atomic environments entering the kernel are taken from a list in the\nML_AB\nfile. Then, the MD simulation is started with on-the-fly learning enabled. The\nML_AB\nfile does not necessarily need to contain structures matching the current starting configuration in the\nPOSCAR\nfile in terms of simulation box, present elements or number of atoms. However, if the same elements appear the initial force field is of course used for predictions. In any case the provided training data is included in the finally generated machine learning force field, i.e. the\nML_FFN\nfile will define a force field applicable to both, the structures in the\nML_AB\nfile\nand\nthe current MD simulation. By restarting repeatedly with\nML_ISTART\n= 1 while providing an\nML_AB\nfile from the last run it is possible to iteratively extend the applicability of the resulting machine learning force field, e.g. by exploring different temperature ranges or element compositions.\n\nTip:\nSetting\nML_ISTART\n= 1 together with\nNSW\n= 0 allows to repeat learning on the given training data and create a new force field in\nML_FFN\nwithout actually performing additional MD steps. In this way force field parameters (e.g. cutoff radii, number of radial basis functions, etc.) can be varied without recalculating the entire trajectory. Moreover, because Bayesian error estimation is not required when no MD is run it is possible to switch the regression algorithm via the tag\nML_IALGO_LINREG\nand check whether in this way better fitting results can be achieved. In order to avoid that the starting structure in the\nPOSCAR\nfile is processed and eventually added to the training data just set\nML_CTIFOR\nto a large value (e.g. 1000).\n\nML_ISTART\n= 2: Prediction only. In this mode the previously trained machine learning force field is read from the\nML_FF\nfile. The MD simulation is driven with predictions from the force field only, no ab initio calculations are performed and no learning is executed. However, in order to monitor the quality of predictions the Bayesian error estimate of forces is still computed and logged in the\nML_LOGFILE\n. This setting is typically used when the machine learning force field is considered mature and ready for production runs.\nML_ISTART\n= 3: Learning from given ab initio data only, no MD time steps. In this operation mode a new machine learning force field is generated from ab initio data provided in the\nML_AB\nfile. The structures are read in and processed one by one as if harvested via an MD simulation. In other words, the same steps are performed as in on-the-fly training but the source of data is not an MD run but the series of structures available in\nML_AB\n. This operation mode can be used to generate VASP machine learning force fields from pre-computed or external ab initio data sets. At first glance\nML_ISTART\n= 3 looks very similar to the combination of\nML_ISTART\n= 1 and\nNSW\n= 0 described above. However, there is an important difference: Setting\nML_ISTART\n= 3 will ignore the list of local reference configurations in the\nML_AB\nfile and instead will determine a new collection which is written to the resulting\nML_ABN\nfile.\n\nTip:\nIf calculations for\nML_ISTART\n= 3 are too time-consuming using the default settings, it is useful to increase\nML_MCONF_NEW\nto values around 10-16 and set\nML_CDOUB\n= 4. This often accelerates the calculations by a factor of 2-4.\nThe\nML_AB\nfile may contain values for\nCTIFOR\nfor each training structure. These are the thresholds used to sample that structure from the previous training. If a value for\nML_CTIFOR\nis specified in the\nINCAR\nfile, that value is then used and the thresholds from the\nML_AB\nare ignored. Otherwise: 1) If thresholds exist in the\nML_AB\nthey are used. 2) If no thresholds are specified the default value for\nML_CTIFOR\nis used.\n\nML_ISTART\n= 4: Refitting of the force field is done based on an existing\nML_AB\nfile, but the number of local reference configurations is taken from the\nML_AB\nfile.\nNSW\non the input is ignored and only a single step is executed. No ab-initio calculation is carried out.",
    "related_tags": [
      "ML_LMLFF",
      "ML_IALGO_LINREG",
      "ML_IWEIGHT",
      "ML_ICRITERIA",
      "ML_IREG",
      "ML_LSPARSDES",
      "ML_ISCALE_TOTEN",
      "ML_LCOUPLE",
      "ML_LHEAT",
      "ML_LEATOM",
      "ML_MB",
      "ML_MCONF"
    ]
  },
  "ML_IWEIGHT": {
    "default_value": "ML_IWEIGHT = 3",
    "description": "This tag controls which procedure is used for normalizing and weighting the energies, forces, and stresses in the machine learning force field method.",
    "detailed_description": "To achieve optimal training it is important to normalize the available data. Furthermore, sometimes it may be desired to emphasize some training quantities over others, e.g. one might want excellent force predictions, even at the cost of sacrificing some energy and stress accuracy. How normalizing and weighting are performed can be controlled with the\nML_IWEIGHT\ntogether with weighting parameters\nML_WTOTEN\n,\nML_WTIFOR\nand\nML_WTSIF\nfor energies, forces, and stresses, respectively. The following procedures can be selected via\nML_IWEIGHT\n:\n\nML_IWEIGHT\n= 1: Manual control over normalization/weighting: the unnormalized energies, forces, and stress tensor training data are divided by the weights determined by the flags\nML_WTOTEN\n(eV/atom),\nML_WTIFOR\n(eV/\nÅ\n{\\displaystyle \\AA}\n) and\nML_WTSIF\n(kBar), respectively.\n\nML_IWEIGHT\n= 2: Normalization via global standard deviations: The energies, forces, and stresses are normalized by their respective standard deviation over the entire training data. Then, the normalized quantities are weighted by\nML_WTOTEN\n,\nML_WTIFOR\nand\nML_WTSIF\nwhen they are processed for learning in the design matrix\nΦ\n{\\displaystyle \\mathbf{\\Phi}}\n(see\nthis section\n). In this case the values of\nML_WTOTEN\n,\nML_WTIFOR\nand\nML_WTSIF\nare unitless quantities.\n\nML_IWEIGHT\n= 3: Normalization via averages over subset standard deviations: Same as\nML_IWEIGHT\n= 2 but the training data is divided into individual subsets. For each subset, the standard deviations are calculated separately. Then, the energies, forces, and stresses are normalized using the average of the standard deviations of all subsets. Finally, as for\nML_IWEIGHT\n= 2 the normalized quantities are multiplied by\nML_WTOTEN\n,\nML_WTIFOR\nand\nML_WTSIF\nfor learning purposes. By default (\nML_LUSE_NAMES\n=\n.FALSE.\n) the division into subsets is based on the atom types and number of atoms per type. If two systems contain the same atom types and the same number of atoms per type then they are considered to be in the same subset. To further divide them into subsets set\nML_LUSE_NAMES\n=\n.TRUE.\nand choose different system names in the first line of the\nPOSCAR\nfile. This can be useful if training is performed for widely different materials, for instance, different phases with widely different energies. Without the finer subset assignment, the overall energy standard deviation might become large, reducing the weight of the energies too much of given subsets.\n\nFor\nML_IWEIGHT\n= 2, 3 the weights are unitless quantities used to multiply the data, whereas for\nML_IWEIGHT\n= 1 they have a unit. All three methods provide unitless energies, forces, and stress tensors, which are then passed to the learning algorithm. Although the defaults are usually rather sensible, it can be useful to explore different weights. For instance, if vibrational frequencies are supposed to be reproduced accurately, we found it helpful to increase\nML_WTIFOR\nto 10-100. On the other hand, if the energy difference between different phases needs to be described accurately by the force field, it might be useful to increase\nML_WTOTEN\nto around 10-100.\n\nTip:\nOn-the-fly learning implies that training structures accumulate along the running MD trajectory. Hence, also the standard deviations of energies, forces, and stresses change over time and will be recalculated whenever a learning step is triggered. We highly recommend using\nML_IWEIGHT\n= 3 because this ensures that at any time learning is performed on an adequately normalized set.",
    "related_tags": [
      "ML_LMLFF",
      "ML_WTOTEN",
      "ML_WTIFOR",
      "ML_WTSIF",
      "ML_LUSE_NAMES"
    ]
  },
  "ML_LAFILT2": {
    "default_value": "ML_LAFILT2 = .TRUE.",
    "description": "This tag specifies whether angular filtering is applied or not within the machine learning force field method.",
    "detailed_description": "For the desciption of the filters please see:\nML_IAFILT2\nand\nML_AFILT2\n.\n\nThe applied angular filter is also briefly described\nhere\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_IAFILT2",
      "ML_AFILT2"
    ]
  },
  "ML_LBASIS_DISCARD": {
    "default_value": "ML_LBASIS_DISCARD = .TRUE.",
    "description": "Controls whether calculation is continued or stopped after the maximum number of local reference configurations ML_MB for a given species is reached.",
    "detailed_description": "For\nML_LBASIS_DISCARD\n=.FALSE., whenever the number of local reference configurations for a given species would exceed the maximum number of allowed configurations\nML_MB\n, the code will terminate (soft exit) and request the user to continue with and increased number for\nML_MB\n.\n\nFor\nML_LBASIS_DISCARD\n=.TRUE. (default) the code will not stop, when the number of local reference configurations for a given species would exceed the maximum, but old configurations may be replaced by new ones.\n\nIn multi-component systems it can happen that, although\nML_MB\nis set to the maximum that is computationally affordable, one species exceeds\nML_MB\nwhile the other species are not sufficiently sampled and still far below\nML_MB\n. For that\nML_LBASIS_DISCARD\n=.TRUE. should be set. In that case the fast sampled species would retain the same number of local reference configurations and the new local reference configurations would replace old ones. At the same time new local reference configurations could be added for the slowly-sampled species further improving their accuracy for fitting.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MB",
      "ML_MCONF",
      "ML_EPS_LOW"
    ]
  },
  "ML_LCOUPLE": {
    "default_value": "ML_LCOUPLE = .FALSE.",
    "description": "This tag specifies whether thermodynamic integration is activated in order to calculate the chemical potentials within the machine learning force field method.",
    "detailed_description": "In thermodynamic integration a coupling parameter\nλ\n{\\displaystyle \\lambda}\nis introduced to the Hamiltonian to smoothly switch between a \"non-interacting\" reference state and a \"fully-interacting\" state. The change of the free energy along this path is written as\n\nΔ\nμ\n=\n∫\n0\n1\n⟨\nd\nH\n(\nλ\n)\nd\nλ\n⟩\nλ\nd\nλ\n.\n{\\displaystyle \n\\Delta \\mu = \\int\\limits_{0}^{1} \\langle \\frac{dH(\\lambda)}{d\\lambda} \\rangle_{\\lambda} d\\lambda.\n}\n\nUsing machine learning force fields the Hamiltonian can be written as\n\nH\n(\nλ\n)\n=\n∑\ni\n=\n1\nN\na\n|\np\ni\n|\n2\n2\nm\ni\n+\n∑\ni\n∉\nM\nU\ni\n(\nλ\n)\n+\nλ\n∑\ni\n∈\nM\nU\ni\n(\nλ\n)\n+\n∑\ni\nN\na\nU\ni\n,\na\nt\no\nm\n.\n{\\displaystyle \nH (\\lambda) = \\sum\\limits_{i=1}^{N_{a}} \\frac{|\\mathbf{p}_{i}|^2}{2m_{i}} + \\sum\\limits_{i \\notin M} U_{i}(\\lambda) + \\lambda \\sum\\limits_{i \\in M} U_{i}(\\lambda) + \\sum\\limits_{i}^{N_{a}} U_{i,\\mathbf{atom}}. \n}\n\nwhere\nN\na\n{\\displaystyle N_{a}}\ndenotes the number of atoms and\nU\ni\n,\na\nt\no\nm\n{\\displaystyle  U_{i,\\mathbf{atom}}}\nis an atomic reference energy for a single non interacting atom. The first term in the equation describes the potential energy and the second and third term describe the potential energy of an atom\ni\n{\\displaystyle i}\n. The index\nM\n{\\displaystyle M}\ndenotes the atoms whose interaction is controlled by a coupling parameter. The interactions of the atoms are controlled by scaling the contributions to the atom density via the coupling parameter\n\nρ\n(\nr\n,\nλ\n)\n=\n∑\nj\n∉\nM\nf\nc\nu\nt\n(\n|\nr\nj\n−\nr\ni\n|\n)\ng\n[\nr\n−\n(\nr\nj\n−\nr\ni\n)\n]\n+\nλ\n∑\nj\n∈\nM\nf\nc\nu\nt\n(\n|\nr\nj\n−\nr\ni\n|\n)\ng\n[\nr\n−\n(\nr\nj\n−\nr\ni\n)\n]\n.\n{\\displaystyle \n\\rho (\\mathbf{r},\\lambda) = \\sum\\limits_{j\\notin M} f_{\\mathrm{cut}} \\left( \\left| \\mathbf{r}_{j} - \\mathbf{r}_{i} \\right| \\right) g \\left[ \\mathbf{r} - \\left( \\mathbf{r}_{j} - \\mathbf{r}_{i} \\right) \\right] + \\lambda \\sum\\limits_{j\\in M} f_{\\mathrm{cut}} \\left( \\left| \\mathbf{r}_{j} - \\mathbf{r}_{i} \\right| \\right) g \\left[ \\mathbf{r} - \\left( \\mathbf{r}_{j} - \\mathbf{r}_{i} \\right) \\right].\n}\n\nFurther details on the implementation can be found in reference\n[1]\n.\n\nFor thermodynamic integration the following parameters have to be set:\n\nML_MODE\n= run\n.\nML_LCOUPLE\n= .TRUE.\n.\nThe number of atoms for which a coupling parameter is introduced (\ni\n∈\nM\n{\\displaystyle i \\in M }\n):\nML_NATOM_COUPLED\n.\nThe list of atom indices that for that the coupling parameter is applied in the interaction:\nML_ICOUPLE\n.\nThe strength of the coupling parameter\nλ\n{\\displaystyle \\lambda}\nbetween 0 and 1:\nML_RCOUPLE\n.\n\nThe derivative of the hamiltonian with respect to the coupling constant\nd\nH\n/\nd\nλ\n{\\displaystyle dH/d\\lambda}\nis written out at every MD step to the\nML_LOGFILE\n. A sample output should look like this:\n\n# DCOUPLE ################################\n# DCOUPLE This line shows the derivative of the Hamiltonian with respect to coupling constant (dH/dlambda).\n# DCOUPLE \n# DCOUPLE nstep .......... MD time step or input structure counter\n# DCOUPLE der_H_lambda ... dH/dlambda\n# DCOUPLE ################################\n# DCOUPLE           nstep     der_H_lambda\n# DCOUPLE               2                3\n# DCOUPLE ################################\nDCOUPLE                 1  -1.08332135E+01\nDCOUPLE                 2  -1.08132321E+01\nDCOUPLE                 3  -1.07631992E+01\nDCOUPLE                 4  -1.06786675E+01\nDCOUPLE                 5  -1.05493088E+01\nDCOUPLE                 6  -1.03561161E+01\nDCOUPLE                 7  -1.00762443E+01\nDCOUPLE                 8  -9.69961878E+00\nDCOUPLE                 9  -9.25531640E+00\nDCOUPLE                10  -8.82525354E+00\n...\n\nReferences\n\n↑\nR. Jinnouchi, F. Karsai, and G. Kresse, Phys. Rev. B\n101\n, 060201 (2020).",
    "related_tags": [
      "ML_LMLFF",
      "ML_NATOM_COUPLED",
      "ML_ICOUPLE",
      "ML_RCOUPLE"
    ]
  },
  "ML_LEATOM": {
    "default_value": "ML_LEATOM = .FALSE.",
    "description": "This term specifies whether the total atomic energy is written out or not.",
    "detailed_description": "This tag specifies whether the total atomic energy (potential energy plus kinetic energy) for each MD step is written out to the\nML_EATOM\nfile. It also writes the atomic positions and lattice parameters at every MD step to this file.",
    "related_tags": [
      "ML_LMLFF",
      "ML_WTOTEN"
    ]
  },
  "ML_LERR": {
    "default_value": "ML_LERR = .TRUE. Warning: This tag is deprecated and is replaced by ML_IERR .",
    "description": "Decides whether the Bayesian error estimates are calculated and written out or not.",
    "detailed_description": "",
    "related_tags": [
      "ML_LMLFF",
      "ML_IERR",
      "ML_MODE"
    ]
  },
  "ML_LFAST": {
    "default_value": "Default: ML_LFAST = .TRUE. for ML_MODE = refit | = .FALSE. else",
    "description": "This tag switches on the descriptors for refitting in the fast execution mode within machine learning force fields. This tag is usually switched on by ML_MODE = refit and doesn't need to be set explicitely.",
    "detailed_description": "Mind:\nThis tag is only available as of VASP.6.4.0\n\nThis tag switches on the descriptors for the fast execution mode. To use the fast execution mode the force field first has to be refit with the fast descriptors. This is done by setting\nML_MODE\n= refit\n, which will automatically set\nML_LFAST\n. As usual, the resulting\nML_FFN\nhas to be copied to\nML_FF\nand the fast code will be automatically run in production mode runs by setting\nML_MODE\n.\n\nThe speedup of the fast method compared to the regular method is increasing with increasing number of local reference configurations.\n\nIt should be noted that in the fast version no Bayesian error estimation is available.\n\nSince the calculation time of the fast version is of the same order of magnitude as the timing for the output of the molecular-dynamics results, we advise decreasing the output frequency for molecular dynamics by the tag\nML_OUTBLOCK\n. Additionally, the calculation and output of the pair-correlation function can be suppressed by\nML_OUTPUT_MODE\n= 0\nas default.\n\nDeprecated:\nIf\nML_LFAST\n= .TRUE.\nis explicitely used without the\nML_MODE\ntag then it can only be used with\nML_ISTART\n= 4\nand\nML_IALGO_LINREG\n> 1\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_IERR",
      "ML_OUTBLOCK",
      "ML_OUTPUT_MODE"
    ]
  },
  "ML_LHEAT": {
    "default_value": "ML_LHEAT = .FALSE.",
    "description": "This tag specifies whether the heat flux is calculated or not in the machine learning force field method.",
    "detailed_description": "The heat flux within machine learning force fields is decomposed into atomic contributions written as\n\nq\n(\nt\n)\n=\n∑\ni\n=\n1\nN\na\nd\nd\nt\n(\nr\ni\nE\ni\n)\n,\n{\\displaystyle \n\\mathbf{q}(t) = \\sum\\limits_{i=1}^{N_{a}} \\frac{d}{dt} \\left( \\mathbf{r}_{i} E_{i} \\right),\n}\n\nE\ni\n=\nm\ni\n|\nv\ni\n|\n2\n2\n+\nU\ni\n{\\displaystyle \nE_{i}=\\frac{m_{i} \\left|\\mathbf{v}_{i} \\right|^{2}}{2} + U_{i}\n}\n\nwhere\nr\ni\n{\\displaystyle \\mathbf{r}_{i}}\n,\nv\ni\n{\\displaystyle \\mathbf{v}_{i}}\nand\nE\ni\n{\\displaystyle E_{i}}\ndenote the position vector, velocity and energy of atom\ni\n{\\displaystyle i}\n, respectively. The number of atoms in the system is denoted by\nN\na\n{\\displaystyle N_{a}}\n. The heat flux can be further rewritten as\n\nq\n(\nt\n)\n=\n∑\ni\n=\n1\nN\na\nv\ni\nE\ni\n+\n∑\ni\n=\n1\nN\na\nr\ni\n(\nm\ni\nv\ni\n⋅\nd\nv\ni\nd\nt\n+\n∑\nj\n=\n1\nN\na\nv\nj\n⋅\n∇\nj\nU\ni\n)\n.\n{\\displaystyle \n\\mathbf{q}(t) = \\sum\\limits_{i=1}^{N_{a}} \\mathbf{v}_{i} E_{i} + \\sum\\limits_{i=1}^{N_{a}} \\mathbf{r}_{i} \\left( m_{i} \\mathbf{v}_{i} \\cdot \\frac{d\\mathbf{v}_{i}}{dt} + \\sum\\limits_{j=1}^{N_{a}} \\mathbf{v}_{j} \\cdot \\nabla_{j} U_{i} \\right). \n}\n\nUsing the equation of motions\n\nm\ni\nd\nv\ni\nd\nt\n=\n−\n∑\nj\n=\n1\nN\na\n∇\ni\nU\nj\n{\\displaystyle \nm_{i} \\frac{d \\mathbf{v}_{i}}{dt} = - \\sum\\limits_{j=1}^{N_{a}} \\nabla_{i} U_{j}\n}\n\nthe heat flux can be simplified to\n\nq\n(\nt\n)\n=\n∑\ni\n=\n1\nN\na\nv\ni\nE\ni\n−\n∑\ni\n=\n1\nN\na\n∑\nj\n=\n1\nN\na\nr\ni\n(\nv\ni\n⋅\n∇\ni\nU\nj\n)\n+\n∑\ni\n=\n1\nN\na\n∑\nj\n=\n1\nN\na\nr\ni\n(\nv\nj\n⋅\n∇\nj\nU\ni\n)\n=\n∑\ni\n=\n1\nN\na\nv\ni\nE\ni\n+\n∑\ni\n=\n1\nN\na\n∑\nj\n=\n1\nN\na\n(\nr\ni\n−\nr\nj\n)\n(\nv\nj\n⋅\n∇\nj\nU\ni\n)\n.\n{\\displaystyle \n\\mathbf{q}(t) = \\sum\\limits_{i=1}^{N_{a}} \\mathbf{v}_{i} E_{i} - \\sum\\limits_{i=1}^{N_{a}} \\sum\\limits_{j=1}^{N_{a}} \\mathbf{r}_{i} \\left( \\mathbf{v}_{i} \\cdot \\nabla_{i} U_{j} \\right) + \\sum\\limits_{i=1}^{N_{a}} \\sum\\limits_{j=1}^{N_{a}} \\mathbf{r}_{i} \\left( \\mathbf{v}_{j} \\cdot \\nabla_{j} U_{i} \\right) = \\sum\\limits_{i=1}^{N_{a}} \\mathbf{v}_{i} E_{i} + \\sum\\limits_{i=1}^{N_{a}} \\sum\\limits_{j=1}^{N_{a}} \\left( \\mathbf{r}_{i} - \\mathbf{r}_{j} \\right) \\left( \\mathbf{v}_{j} \\cdot \\nabla_{j} U_{i} \\right). \n}\n\nFinally (in a post-processing step), the thermal conductivity at temperature\nT\n{\\displaystyle T}\nin the Green-Kubo formalism can be calculated from the correlation of the heat flux\nq\n{\\displaystyle \\mathbf{q}}\nas\n\nκ\n=\n1\n3\nV\nk\nb\nT\n2\n∫\n0\n∞\n⟨\nq\n(\nt\n)\n⋅\nq\n(\n0\n)\n⟩\nd\nt\n,\n{\\displaystyle \n\\kappa = \\frac{1}{3Vk_{b}T^{2}} \\int\\limits_{0}^{\\infty} \\langle \\mathbf{q}(t) \\cdot \\mathbf{q}(0) \\rangle dt,\n}\n\nwhere\nV\n{\\displaystyle V}\nand\nk\nb\n{\\displaystyle k_{b}}\ndenotes the volume of the system and the Boltzmann constant, respectively.\n\nThe heat flux is written to the file\nML_HEAT\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_LEATOM"
    ]
  },
  "ML_LIB": {
    "default_value": "Default: ML_LIB = .TRUE. if compiled with VASPml library (precompiler flag -Dlibvaspml ) | = .FALSE. else",
    "description": "ML_LIB enables/disables the use of the VASPml C++ library for machine-learning features.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nSome machine learning modes of operation (\nML_MODE\n) are implemented twice in VASP, once in the original Fortran code and again in a C++ rewrite as part of the VASPml library. However, the supported features and\nINCAR\ntags may be\ndifferent\n. For example, the C++ library does not yet implement the thermodynamic integration method. The\nML_LIB\ntag allows to switch seamlessly between the two code paths without the need to recompile VASP.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE"
    ]
  },
  "ML_LMAX2": {
    "default_value": "Default: ML_LMAX2 = 3 for ML_LAFILT2 = .TRUE. | = 6 else",
    "description": "This tag specifies the maximum angular momentum quantum number L max {\\displaystyle L_\\max} of spherical harmonics used to expand atomic distributions within the machine learning force field method.",
    "detailed_description": "To construct an atomic environment descriptor the atomic probability density\n\nρ\ni\n(\nr\n)\n=\n∑\nj\n=\n1\nN\na\nf\nc\nu\nt\n(\nr\ni\nj\n)\ng\n(\nr\n−\nr\ni\nj\n)\n,\n{\\displaystyle \n\\rho_{i}\\left(\\mathbf{r}\\right) = \\sum\\limits_{j=1}^{N_{\\mathrm{a}}} f_{\\mathrm{cut}}\\left(r_{ij}\\right) g\\left(\\mathbf{r}-\\mathbf{r}_{ij}\\right),\n}\n\nwhere\ng\n(\nr\n)\n{\\displaystyle g\\left(\\mathbf{r}\\right)}\nis an approximation of the delta function, is expanded in terms of radial basis functions\nχ\nn\nl\n(\nr\n)\n{\\displaystyle \\chi_{nl}(r)}\nand spherical harmonics\nY\nl\nm\n(\nr\n^\n)\n{\\displaystyle Y_{lm}\\left(\\hat{\\mathbf{r}}\\right)}\n(see\nthis section\nfor more details):\n\nρ\ni\n(\nr\n)\n=\n∑\nl\n=\n1\nL\nm\na\nx\n∑\nm\n=\n−\nl\nl\n∑\nn\n=\n1\nN\nR\nl\nc\nn\nl\nm\ni\nχ\nn\nl\n(\nr\n)\nY\nl\nm\n(\nr\n^\n)\n,\n{\\displaystyle \n\\rho_{i} \\left( \\mathbf{r} \\right) = \\sum\\limits_{l=1}^{L_{\\mathrm{max}}} \\sum\\limits_{m=-l}^{l} \\sum\\limits_{n=1}^{N^{l}_{ \\mathrm{R}}} c_{nlm}^{i}\\chi_{nl} \\left( r \\right) Y_{lm} \\left( \\hat{\\mathbf{r}} \\right),\n}\n\nThe tag\nML_LMAX2\nspecifies the maximum angular momentum quantum number\nL\nmax\n{\\displaystyle L_\\max}\nof spherical harmonics used in this expansion.\n\nMind:\nThis tag is only relevant for the angular descriptor\nρ\ni\n(\n3\n)\n(\nr\n)\n{\\displaystyle \\rho^{(3)}_i(r)}\n. The corresponding number of expansion coefficients\np\nn\nν\nl\ni\n{\\displaystyle p_{n\\nu l}^{i}}\nscales\nlinearly\nwith\nL\nmax\n{\\displaystyle L_\\max}\n(however the calculation of the spherical harmonics scales quadratically) and is also depending on\nML_MRB2\nand the number of elements present.\n\nBy default an angular filtering (see\nML_LAFILT2\nand\nML_IAFILT2\n) with a filtering parameter of\nML_AFILT2\n=0.002 is used where a value of\nML_LMAX2\n=3 is perfectly safe for most applications. If you need to improve the accuracy, you might also try to increase it to\nML_LMAX2\n=4. If the angular filter is switched off, we recommend to use a value of\nML_LMAX2\n=6 (this is then the default value).",
    "related_tags": [
      "ML_LMLFF",
      "ML_MRB1",
      "ML_MRB2",
      "ML_LAFILT2",
      "ML_IAFILT2",
      "ML_AFILT2"
    ]
  },
  "ML_LMLFF": {
    "default_value": "ML_LMLFF = .FALSE.",
    "description": "Main control tag which enables/disables the use of machine learning force fields.",
    "detailed_description": "Mind:\nMachine learning force fields is available in VASP as of version 6.3.0\n\nIf\nML_LMLFF\n= .FALSE. machine learning force fields are disabled and all related\nINCAR\ntags, i.e. all tags starting with \"\nML_\n\", are ignored. If machine learning force fields are used by setting\nML_LMLFF\n= .TRUE., the VASP mode of operation depends on the choice of\nML_MODE\n. If\nML_MODE\nis not supplied in the\nINCAR\nfile then the default mode of operation is to run an MD simulation with on-the-fly machine learning, i.e.,\nML_MODE\n. This training is started \"from scratch\" if no\nML_AB\nfile is provided, otherwise a continuation run is performed.",
    "related_tags": [
      "ML_MODE",
      "ML_IALGO_LINREG",
      "ML_IWEIGHT",
      "ML_ICRITERIA",
      "ML_IREG",
      "ML_LSPARSDES",
      "ML_ISCALE_TOTEN",
      "ML_LCOUPLE",
      "ML_LHEAT",
      "ML_LEATOM",
      "ML_MB",
      "ML_MCONF"
    ]
  },
  "ML_LSPARSDES": {
    "default_value": "ML_LSPARSDES = .FALSE.",
    "description": "Specifies whether angular-descriptor sparsification is enabled within the machine learning force field method.",
    "detailed_description": "Mind:\nThis tag is only available as of VASP 6.4.3.\n\nWarning:\nThis tag only works for\nML_MODE\n=\nrefit\nor\nreftbayesian\n!\n\nTo use the\nsparsification of angular descriptors set\nthe following tags:\n\nML_LSPARSDES\n=\n.TRUE.\n.\nThe ratio of the selected descriptors to the total number of descriptors:\nML_RDES_SPARSDES\n. This tag controls the extent of the sparsification.\nThe number of the highest eigenvalues\nk\n{\\displaystyle k}\nto which the correlation is measured via the leverage scoring:\nML_NRANK_SPARSDES\n. This parameter usually does not need to be changed.\n\nWe advise the user to adjust this parameter carefully and test it individually for each system. This means e.g. plotting the accuracy of the calculation against the computational speed (Pareto curves) for different values of\nML_RDES_SPARSDES\n. The user can then choose a tradeoff between efficiency and accuracy. \nThe behavior is system dependent, however, we have experienced the following trends for our test cases: For\nML_DESC_TYPE\n=0 a descriptor sparsification of 50 percent\nML_RDES_SPARSDES\n=0.5 leaves the accuracy almost untouched. \nIf more spars descriptors are used such as e.g.\nML_DESC_TYPE\n=1, which already contain much fewer descriptors than the standard descriptor\nML_DESC_TYPE\n=0, a 50 percent sparsification for\nML_DESC_TYPE\n=1 results in noticeable accuracy loss.",
    "related_tags": [
      "ML_LMLFF",
      "ML_RDES_SPARSDES",
      "ML_NRANK_SPARSDES",
      "ML_DESC_TYPE"
    ]
  },
  "ML_LUSE_NAMES": {
    "default_value": "ML_LUSE_NAMES = .FALSE.",
    "description": "Decides whether training structures are additionally subdivided into groups internally due to their structure name.",
    "detailed_description": "This tag is important if the normalization via averages over subset standard deviations (\nML_IWEIGHT\n=3) is employed.\nBy default (\nML_LUSE_NAMES\n=\n.FALSE.\n) the division into subsets is based on the atom types and number of atoms per type. If two systems contain the same atom types and the same number of atoms per type then they are considered to be in the same subset. To further divide them into subsets set\nML_LUSE_NAMES\n=\n.TRUE.\nand choose different system names in the first line of the\nPOSCAR\nfile. This can be useful if training is performed for widely different materials, for instance, different phases with widely different energies. Without the finer subset assignment, the overall energy standard deviation might become large, reducing the weight of the energies too much of given subsets.",
    "related_tags": [
      "ML_LMLFF",
      "ML_WTOTEN",
      "ML_WTIFOR",
      "ML_WTSIF",
      "ML_IWEIGHT"
    ]
  },
  "ML_MB": {
    "default_value": "ML_MB = see below",
    "description": "This tag sets the maximum number of local reference configurations (i.e. basis functions in the kernel) in the machine learning force field method.",
    "detailed_description": "The defaults for\nML_MB\nare different for each different\nML_MODE\nsetting. Here are the defaults for each mode:\n\nML_MODE\n= train\n:\nNo\nML_AB\npresent (learning from scratch):\nmin(1500 , max(\nNSW\n, 2*\nML_MCONF_NEW\n* MAXAT_SP)\nML_AB\npresent (continuation of learning):\nMB_AB + min(1500, max(\nNSW\n, 2*\nML_MCONF_NEW\n* MAXAT_SP)\nML_MODE\n= select\n:\nMB_AB +\nML_MCONF_NEW\n* MAXAT_SP\nML_MODE\n= refit\n:\nMB_AB + MAXAT_SP\nML_MODE\n= refitbayesian\n:\nMB_AB + MAXAT_SP\nML_MODE\n= run\n:\nMB_AB\n\nusing the following definitions:\n\nMAXAT_SP\n= greatest number of atoms within all species among the current structures and the structures in the\nML_AB\nfile (if present).\nMB_AB\n= greatest number of local reference configurations within all species in the\nML_AB\nfile.\n\nThe default value for\nML_MODE\n= train\nand\nML_MODE\n= select\nis a relatively safe value for most materials. However one might need to increase it to a greater value for liquids, polymers and amorphous systems, or when a MLFF for many different polytypes is trained. By default (\nML_LBASIS_DISCARD\n= .TRUE.\n), if the number of local reference configurations would exceed\nML_MB\n, VASP would continue the calculation and disposes of these, but one should make extensive tests whether the generated MLFF is sufficiently accurate.\n\nIf VASP stops, subsequent training can be restarted from the existing ML_AB file. This avoids loss of already acquired training data.\n\nDepending on the calculation mode VASP adds a little overhead in the allocation of\nML_MB\narrays to buffer for new candidate structures. Here are the buffer sizes for each mode:\n\nML_MODE\n= train\n:\nNo\nML_AB\npresent (learning from scratch):\nmin(\nNSW\n,\nML_MCONF_NEW\n) * MAXAT_SP\nML_AB\npresent (continuation of learning):\nmin(\nNSW\n,\nML_MCONF_NEW\n) * MAXAT_SP\nML_MODE\n= select\n:\nML_MCONF_NEW\n* MAXAT_SP\nML_MODE\n= refit\n:\nMAXAT_SP\nML_MODE\n= refitbayesian\n:\nMAXAT_SP\nML_MODE\n= run\n:\n0\n\nThe flag\nML_MB\nalso determines the maximum number of rows of the design matrix.   This is usually a huge matrix. The design matrix is allocated statically at the beginning of the run, since several parts of the code use MPI shared memory and dynamic reallocation of these arrays can cause issues on many operating systems. An estimate of the size of the design matrix and all other large arrays is printed out to the\nML_LOGFILE\nbefore allocation. The design matrix is fully distributed in a block-cyclic fashion for scaLAPACK, and thus the memory requirement for each core scales inversely proportional to the number of used cores.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_MCONF_NEW",
      "ML_MCONF",
      "ML_LBASIS_DISCARD"
    ]
  },
  "ML_MB_MIN": {
    "default_value": "ML_MB_MIN = 3",
    "description": "ML_MB_MIN sets the minimum number of local reference configurations required for generation of a machine-learned force field.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.4.3. Previous versions do not support this tag but act as if its default was\nML_MB_MIN\n= 2\n.\n\nMachine-learned force fields based on the kernel method require a reasonable amount of reference atomic environments in order to provide meaningful predictions. Typically, the on-the-fly algorithm in VASP collects these local reference configurations (also called kernel basis functions) during an MD simulation (\nML_MODE\n= train\n). However, at the start of the trajectory usually only very few local reference configurations are available. How many depends on the system size, symmetry and number of atoms (per type). This tag controls how many local reference configurations are required\nfor each atom type\nbefore training of a force field is allowed. Setting a higher value may yield a more robust initial force field at the cost of  more\nab initio\ncalculations during the first few MD steps.\n\nIf a training is scheduled in the current step, i.e., the\nSTATUS\nline in the\nML_LOGFILE\nshows\nlearning\nor\ncritical\n, but not enough atomic environments were collected, a text message will be emitted in the\nMSG\nline. Here is an example:\n\n--------------------------------------------------------------------------------\nSTATUS                  1  critical  4      T      F         0         1\nLCONF                   1 Ni         0         4\nSPRSC                   1         1         1 Ni         4         1\nMSG                     1      info Number of local reference configurations after sparsification below ML_MB_MIN, skipping training.\nBEEF                    1   1.00000000E-06   3.46410162E-02   2.00000000E-02   2.00000000E-03   0.00000000E+00   0.00000000E+00\n--------------------------------------------------------------------------------\nSTATUS                  2  critical  4      T      F         0         2\nLCONF                   2 Ni         1         5\nSPRSC                   2         2         2 Ni         5         2\nMSG                     2      info Number of local reference configurations after sparsification below ML_MB_MIN, skipping training.\nBEEF                    2   1.00000000E-06   3.46410162E-02   2.00000000E-02   2.00000000E-03   0.00000000E+00   0.00000000E+00\n--------------------------------------------------------------------------------\nSTATUS                  3  critical  4      T      F         0         3\nLCONF                   3 Ni         2         6\nSPRSC                   3         3         3 Ni         6         3\nREGR                    3    1    1   6.42271768E+01   1.36891529E+00   6.43938951E-14   3.76458019E+01\nREGR                    3    1    2   7.43557292E+01   1.35099932E+00   5.48943502E-14   3.71479653E+01\nREGR                    3    1    3   7.81437752E+01   1.34829112E+00   5.21286212E-14   3.70727138E+01\nREGRF                   3    1    4   7.95268527E+01   1.34739777E+00   5.11880969E-14   3.70478685E+01    2.31498305E+15   3.30988608E+11\nNDESC                   3        12 Ni       113\nNDESC_SIC               3 Ni       113\nSTDAB                   3   1.41895828E-04   3.22944034E-02   9.66711031E-02\nERR                     3   1.45620371E-04   3.32055814E-02   9.84035846E-02\nCFE                     3   0.00000000E+00   0.00000000E+00   0.00000000E+00\nLASTE                   3   1.99936842E-04   5.14296619E-02   1.37823063E-01\nBEE                     3   1.00000000E-06   3.46410162E-02   2.00000000E-02   2.00000000E-03   0.00000000E+00   0.00000000E+00\nBEEF                    3   2.37926034E-05   2.21630107E-03   8.49321832E-04   2.00000000E-03   5.19041973E-02   3.66970792E-02\n-------------------------------------------------------------------------------- \n...\n\nHere, in the first two steps the\nML_MB_MIN\nthreshold prevents training of an MLFF, even if the Bayesian error estimation signals a\ncritical\nstep. The force field is then only generated in the third step, after the minimum number of three local reference configurations have been collected.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_MB",
      "ML_MCONF_NEW",
      "ML_MCONF",
      "ML_LBASIS_DISCARD"
    ]
  },
  "ML_MCONF": {
    "default_value": "ML_MCONF = see below",
    "description": "This tag sets the maximum number of structures stored in memory that are used for training in the machine learning force field method.",
    "detailed_description": "The defaults for\nML_MCONF\nare different for each different\nML_MODE\nsetting. Here are the defaults for each mode:\n\nML_MODE\n='TRAIN':\nNo\nML_AB\npresent (learning from scratch): min(1500, max(1,\nNSW\n))\nML_AB\npresent (continuation of learning): MCONF_AB + min(1500, max(1,\nNSW\n))\nML_MODE\n='SELECT': MCONF_AB + 1\nML_MODE\n='REFIT': MCONF_AB + 1\nML_MODE\n='REFITBAYESIAN': MCONF_AB + 1\nML_MODE\n='RUN': 1\n\nusing the following definition:\n\nMCONF_AB = Number of training structures read from the\nML_AB\nfile.\n\nThe default value for\nML_MODE\n=\nTRAIN\nis usually a safe value for solids and easy-to-learn liquids but should be set to a higher value as soon as it is reached. When this happens the code stops and gives an error instructing to increase\nML_MCONF\n.\n\nThis flag sets also the maximum number of rows for the design matrix, which is usually a huge matrix. The design matrix is to be allocated statically at the beginning of the program since several parts of the code use MPI shared memory and dynamic reallocation of these arrays can cause severe problems on some systems. So most of the main arrays are statically allocated in the code.\n\nAn estimate of the design matrix and all other large arrays are printed out to the\nML_LOGFILE\nbefore allocation. The design matrix is fully distributed in a block cyclic fashion for scaLAPACK and should almost perfectly linearly scale with the number of used processors.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MCONF_NEW",
      "ML_MB"
    ]
  },
  "ML_MCONF_NEW": {
    "default_value": "ML_MCONF_NEW = 5",
    "description": "This tag sets the number of configurations that are stored temporarily as candidates for the training data in the machine learning force field method.",
    "detailed_description": "Warning:\nThis value is close to optimal for on-the-fly learning,  and should usually not be changed.\n\nThe use of this tag in combination with the learning algorithms is described here:\nhere\n.\nIf force fields are reparameterized (\nML_MODE\n= select\n), calculations are usually more efficient if this parameter is increased to values around 10-16 and setting\nML_CDOUB\n= 4\n. This is particularly relevant if the ML_AB file is large.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MCONF",
      "ML_CTIFOR",
      "ML_CDOUB"
    ]
  },
  "ML_MHIS": {
    "default_value": "ML_MHIS = 10",
    "description": "This tag sets the number of estimated errors stored in memory to determine the threshold for error estimation in the machine learning force field method for ML_ICRITERIA =1. For ML_ICRITERIA =2, the history length is 50 x ML_MHIS (or hard coded to 400).",
    "detailed_description": "The use of this tag in combination with the learning algorithms is described here:\nhere\n.\n\nML_ICRITERIA\n=1: The ML code stores\nML_MHIS\nerrors from previous training steps: immediately after a re-training of the ML-FF, the estimated errors of the forces are reevaluated for the current structure (that was also just added as training structure). The average  and the maximum error of the forces is stored in the history. After\nML_MHIS\nupdates of the force field, the threshold\nML_CTIFOR\nis updated the first time and is then updated after every further update of the ML-FF. We recommend to read the section\nML_ICRITERIA\nfor further details.\n\nML_ICRITERIA\n=2: Averaging is performed over 50 x\nML_MHIS\nerror predictions. Every MD step is considered in the averaging (as opposed to above, where only structures after re-training are considered).",
    "related_tags": [
      "ML_LMLFF",
      "ML_ICRITERIA",
      "ML_CTIFOR",
      "ML_CX",
      "ML_CSLOPE",
      "ML_CSIG"
    ]
  },
  "ML_MODE": {
    "default_value": "ML_MODE = none",
    "description": "String-based tag selecting operation mode for machine learning force fields.",
    "detailed_description": "Mind:\nThis tag is only available as of VASP.6.4.0.\n\nThis tag acts as a \"super tag\" and selects the operation mode by selecting the defaults for all other tags. Every tag that is affected by this \"super tag\" can be overwritten by the user by simply specifying the value for that tag.\nThe following options are available for this tag:\n\nML_MODE\n= train\n: On-the-fly training\nForce predictions from the machine learning force field are used to drive the molecular dynamics (MD) simulation. However, if the error estimation performed in each time step indicates a high force error an ab initio calculation is performed instead and the collected energy, forces, and stress are used to improve the machine learning force field. There are two possible cases depending on, whether an\nML_AB\nis present in the calculation folder or not:\nNo\nML_AB\nfile found:\nOn-the-fly training is starting from scratch. Note that at the beginning of the MD run, when there is no force field available or it is still poorly trained,\nab initio\ncalculations will happen frequently. For VASP versions prior to 6.4.0 this corresponds to\nML_ISTART\n= 0\n.\nML_AB\nfile present:\nRestart on-the-fly training from existing training database. Before the MD run starts the\nML_AB\nfile (a copy of the\nML_ABN\nfrom a previous training run!) is read and the\nab initio\ndata (energies, forces, and stresses) and local reference configurations it contains are used to generate an initial force field. Subsequently, the on-the-fly training MD is started. For VASP versions prior to 6.4.0 this corresponds to\nML_ISTART\n= 1\n.\nTip:\nNone of the structures in the\nML_AB\nfile need to match he\nPOSCAR\nfile for the current MD training run in terms of the simulation box, elements, or number of atoms. However, if the same elements appear the initial force field is used for predictions in the current MD run.\nThe training data contained in the\nML_AB\nfile is included in the final machine learning force field, i.e., the\nML_FFN\nfile will define a force field applicable to both the structures on the\nML_AB\nfile as well as to the current MD simulation. This means that by restarting repeatedly with\nML_MODE\n= train\n, and copying the\nML_ABN\nfile from the previous run to\nML_AB\n(!), it is possible to iteratively extend the applicability of the a machine learning force field, e.g., by exploring different temperature ranges or element compositions.\nML_MODE\n= select\n: Re-selection of local reference configurations\nA new machine learning force field is generated from the\nab initio\ndata provided in the\nML_AB\nfile. The structures are read and processed one by one as if harvested in an MD simulation. In other words, the same steps are performed as in on-the-fly training but the source of the data are not actual\nab initio\ncalculations in an MD run but the series of structures available in the\nML_AB\nfile. The list of local reference configurations on the\nML_AB\nfile will be ignored. Instead a new collection of local reference configurations is determined and written to the resulting\nML_ABN\nfile.\nImportant:\nThis operation mode allows to generate a VASP machine learning force field from pre-computed or external\nab initio\ndata sets. In contrast to\nML_MODE\n= refit\nalso the local reference configurations are selected from the entire data set. For example, an\nML_AB\nfile created manually by extracting\nab initio\ndata (energies, forces, stresses) from\nOUTCAR\nfiles (or even other external sources) can be processed in this mode without prior knowledge of local reference configurations (only a dummy section must be added to the\nML_AB\nfile, see its documentation). Similar to on-the-fly training this mode generates\nML_FFN\nfiles and\nML_ABN\nwith\nlocal reference configurations.\nA new iteration through the training structures can lead to a frequent update of the force field. This is quite time-consuming. Hence, for this mode the default value of\nML_CDOUB\nis automatically increased from 2 to 4 which will result in a much less frequent update of the force field. This leads to much more efficient calculations while practically not changing the results.\nTip:\nIf calculations for\nML_MODE\n= select\nare too time-consuming, it is useful to increase\nML_MCONF_NEW\nto values around 10-16. Together with\nML_CDOUB\n= 4\n, this often accelerates the calculations by a factor of 2-4.\nThe\nML_AB\nfile may contain values for\nCTIFOR\nfor each training structure. These are the thresholds used to sample that structure from the previous training. The thresholds found on the\nML_AB\nwill be re-used unless a threshold is explicitly specified in the\nINCAR\nfile, by means of the\nML_CTIFOR\ntag. In the latter case the thresholds from the\nML_AB\nfile are ignored. In case the\nML_AB\ncontains\nno\nCTIFOR\ninformation and\nno\nthreshold is specified in the\nINCAR\nfile, the default value for\nML_CTIFOR\nis used.\nThis mode automatically sets\nNSW\n= 1\nand\nML_CDOUB\n= 4\n.For VASP versions prior to 6.4.0 this corresponds to\nML_ISTART\n= 3\n.\nWarning:\nML_MODE\n= select\nignores the structure in the\nPOSCAR\nand hence no error, force and stress predictions are made at the end of this calculation (instead zeros are written to stdout,\nOSZICAR\nand\nOUTCAR\n).\nML_MODE\n= refit\n: Refit a force field for \"fast\" evaluation\nSimilar to\nML_MODE\n= select\n, refitting is done based on an existing\nML_AB\nfile, but the number of local reference configurations for each species is taken from the\nML_AB\nfile. Sparsification is performed on the local reference configurations, so the resulting\nML_ABN\nfile will contain the same number or fewer local reference configurations than the\nML_AB\nfile.\nBy default the resulting force field is geared towards \"fast\" evaluation to speed up production runs (\nML_LFAST\n= .TRUE.\n). This comes at the cost of not being able to evaluate Bayesian error estimates.\nWarning:\nWe strongly advise to use\nML_MODE\n= refit\nif no Bayesian error estimates are required during production runs.\nThis mode automatically sets\nML_LFAST\n= .TRUE.\n,\nNSW\n= 1\n,\nML_IALGO_LINREG\n= 4\n,\nML_SIGW0\n= 1E-7\n,\nML_SIGV0\n= 1\nand\nML_EPS_LOW\n= 1E-11\n. For VASP versions prior to 6.4.0 this corresponds to\nML_ISTART\n= 4\n.\nML_MODE\n= refitbayesian\n: Refit a force field with Bayesian regression (deprecated)\nSame as\nML_MODE\n= refit\n, but Bayesian regression is employed. This results in lower accuracy and much slower force fields than using\nML_MODE\n= refit\nand should be used with caution. On the other hand, this mode allows the generation of\nML_FFN\nfiles that can calculate Bayesian error estimates in addition to predictions.\nThis modes sets\nNSW\n= 1\n,\nML_IALGO_LINREG\n= 1\nand\nML_LFAST\n= .FALSE.\n. For VASP versions prior to 6.4.0 this corresponds to\nML_ISTART\n= 4\n.\nML_MODE\n= run\n: Perform only force field predictions\nA previously trained machine learning force field is read from the\nML_FF\nfile, and the MD simulation is driven with predictions from the force field only.\nNo\nab initio\ncalculations are performed and\nno\nlearning is executed. This setting is typically used when the machine learning force field is considered mature and ready for production runs.\nOptionally, if the force field was refitted using\nML_MODE\n= refitbayesian\n, the Bayesian error estimate of the energies, forces, and stress can be computed and logged in the\nML_LOGFILE\n. The output frequency of the Bayesian errors can be set via the\nML_IERR\ntag, the default is 0.\nFor VASP versions prior to 6.4.0 this corresponds to\nML_ISTART\n= 2\n.\nML_MODE\n= none\n: The tag is ignored\n\nWarning:\nIf any option other than the above is chosen or there is a spelling error (be careful to write everything in upper case or lower case letters) the code will exit with an error.\n\nTip:\nSome choices of\nML_MODE\nwill automatically set other machine-learned force field tags. However, it is still possible to overwrite the defaults by specifying the corresponding tags in the\nINCAR\nfile.",
    "related_tags": [
      "ML_LMLFF",
      "ML_ISTART",
      "ML_LFAST",
      "ML_IERR",
      "ML_OUTBLOCK",
      "ML_OUTPUT_MODE",
      "ML_IALGO_LINREG",
      "ML_MCONF_NEW",
      "ML_CDOUB",
      "ML_CTIFOR"
    ]
  },
  "ML_MRB1": {
    "default_value": "ML_MRB1 = 12",
    "description": "This tag sets the number N R 0 {\\displaystyle N_\\text{R}^0} of radial basis functions used to expand the radial descriptor ρ i ( 2 ) ( r ) {\\displaystyle \\rho^{(2)}_i(r)} within the machine learning force field method.",
    "detailed_description": "The radial descriptor is constructed from\n\nρ\ni\n(\n2\n)\n(\nr\n)\n=\n1\n4\nπ\n∫\nρ\ni\n(\nr\nr\n^\n)\nd\nr\n^\n,\nwhere\nρ\ni\n(\nr\n)\n=\n∑\nj\n=\n1\nN\na\nf\nc\nu\nt\n(\nr\ni\nj\n)\ng\n(\nr\n−\nr\ni\nj\n)\n{\\displaystyle \n\\rho_{i}^{(2)}\\left(r\\right) = \\frac{1}{4\\pi} \\int \\rho_{i}\\left(r\\hat{\\mathbf{r}}\\right) d\\hat{\\mathbf{r}}, \\quad \\text{where} \\quad\n\\rho_{i}\\left(\\mathbf{r}\\right) = \\sum\\limits_{j=1}^{N_{\\mathrm{a}}} f_{\\mathrm{cut}}\\left(r_{ij}\\right) g\\left(\\mathbf{r}-\\mathbf{r}_{ij}\\right)\n}\n\nand\ng\n(\nr\n)\n{\\displaystyle g\\left(\\mathbf{r}\\right)}\nis an approximation of the delta function. In practice, the continuous function above is transformed into a discrete set of numbers by expanding it into a set of radial basis functions\nχ\nn\n0\n(\nr\n)\n{\\displaystyle \\chi_{n0}(r)}\n(see\nthis section\nfor more details):\n\nρ\ni\n(\n2\n)\n(\nr\n)\n=\n1\n4\nπ\n∑\nn\n=\n1\nN\nR\n0\nc\nn\n00\ni\nχ\nn\n0\n(\nr\n)\n.\n{\\displaystyle \n\\rho_{i}^{(2)}\\left(r\\right) = \\frac{1}{\\sqrt{4\\pi}} \\sum\\limits_{n=1}^{N^{0}_{\\mathrm{R}}} c_{n00}^{i} \\chi_{n0}\\left(r\\right).\n}\n\nThe tag\nML_MRB1\nsets the number\nN\nR\n0\n{\\displaystyle N_\\text{R}^0}\nof radial basis functions to use in this expansion.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MRB2",
      "ML_W1",
      "ML_RCUT1",
      "ML_SION1"
    ]
  },
  "ML_MRB2": {
    "default_value": "ML_MRB2 = 8",
    "description": "This tag sets the number N R l {\\displaystyle N_\\text{R}^l} (for all l {\\displaystyle l} ) of radial basis functions used to expand the angular descriptor within the machine learning force field method.",
    "detailed_description": "The angular descriptor is constructed from\n\nρ\ni\n(\n3\n)\n(\nr\n,\ns\n,\nθ\n)\n=\n∬\nd\nr\n^\nd\ns\n^\nδ\n(\nr\n^\n⋅\ns\n^\n−\nc\no\ns\nθ\n)\n∑\nj\n=\n1\nN\na\n∑\nk\n≠\nj\nN\na\nρ\ni\nk\n(\nr\nr\n^\n)\nρ\ni\nj\n(\ns\ns\n^\n)\n,\nwhere\nρ\ni\nj\n(\nr\n)\n=\nf\nc\nu\nt\n(\nr\ni\nj\n)\ng\n(\nr\n−\nr\ni\nj\n)\n{\\displaystyle \n\\rho_{i}^{(3)}\\left(r,s,\\theta\\right) = \\iint d\\hat{\\mathbf{r}} d\\hat{\\mathbf{s}}  \\delta\\left(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{s}} - \\mathrm{cos}\\theta\\right) \\sum\\limits_{j=1}^{N_{a}} \\sum\\limits_{k \\ne j}^{N_{a}} \\rho_{ik} \\left(r\\hat{\\mathbf{r}}\\right) \\rho_{ij} \\left(s\\hat{\\mathbf{s}}\\right), \\quad \\text{where} \\quad\n\\rho_{ij}\\left(\\mathbf{r}\\right) = f_{\\mathrm{cut}}\\left(r_{ij}\\right) g\\left(\\mathbf{r}-\\mathbf{r}_{ij}\\right)\n}\n\nand\ng\n(\nr\n)\n{\\displaystyle g\\left(\\mathbf{r}\\right)}\nis an approximation of the delta function. In practice, the continuous function above is transformed into a discrete set of numbers\np\nn\nν\nl\ni\n{\\displaystyle p_{n\\nu l}^{i}}\nby expanding it into a set of radial basis functions\nχ\nn\nl\n(\nr\n)\n{\\displaystyle \\chi_{nl}(r)}\nand Legendre polynomials\nP\nl\n(\nc\no\ns\nθ\n)\n{\\displaystyle P_{l}\\left(\\mathrm{cos}\\theta\\right)}\n(see\nthis section\nfor more details):\n\nρ\ni\n(\n3\n)\n(\nr\n,\ns\n,\nθ\n)\n=\n∑\nl\n=\n1\nL\nm\na\nx\n∑\nn\n=\n1\nN\nR\nl\n∑\nν\n=\n1\nN\nR\nl\n2\nl\n+\n1\n2\np\nn\nν\nl\ni\nχ\nn\nl\n(\nr\n)\nχ\nν\nl\n(\ns\n)\nP\nl\n(\nc\no\ns\nθ\n)\n.\n{\\displaystyle \n\\rho_{i}^{(3)}\\left(r,s,\\theta\\right) = \\sum\\limits_{l=1}^{L_{\\mathrm{max}}} \\sum\\limits_{n=1}^{N^{l}_{\\mathrm{R}}}\\sum\\limits_{\\nu=1}^{N^{l}_{\\mathrm{R}}} \\sqrt{\\frac{2l+1}{2}} p_{n\\nu l}^{i}\\chi_{nl}\\left(r\\right)\\chi_{\\nu l}\\left(s\\right)P_{l}\\left(\\mathrm{cos}\\theta\\right).\n}\n\nThe tag\nML_MRB2\nsets the number\nN\nR\nl\n{\\displaystyle N_\\text{R}^l}\nof radial basis functions to use in this expansion. The same number is used for all\nl\n{\\displaystyle l}\n.\n\nMind:\nThe number of angular descriptor expansion coefficients\np\nn\nν\nl\ni\n{\\displaystyle p_{n\\nu l}^{i}}\nscales\nquadratically\nwith\nN\nR\nl\n{\\displaystyle N_\\text{R}^l}\nset by this tag. It also depends on\nML_LMAX2\nand the number of elements.",
    "related_tags": [
      "ML_LMLFF",
      "ML_LMAX2",
      "ML_MRB1",
      "ML_W1",
      "ML_RCUT2",
      "ML_SION2"
    ]
  },
  "ML_NATOM_COUPLED": {
    "default_value": "ML_NATOM_COUPLED = 0",
    "description": "This tag specifies the number of atoms for which a coupling parameter is introduced to calculate the chemical potential within the machine learning force field method.",
    "detailed_description": "For thermodynamic integration calculations please have a look at the tag\nML_LCOUPLE\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_LCOUPLE",
      "ML_ICOUPLE",
      "ML_RCOUPLE"
    ]
  },
  "ML_NHYP": {
    "default_value": "ML_NHYP = 4",
    "description": "This tag specifies the polynomial power ζ {\\displaystyle \\zeta} of the kernel within the machine learning force field method (see this section ).",
    "detailed_description": "The value of\nML_NHYP\nmust be an integer number\n≥\n{\\displaystyle \\ge}\n1.",
    "related_tags": [
      "ML_RCUT1",
      "ML_SION1",
      "ML_RCUT2",
      "ML_SION2"
    ]
  },
  "ML_NMDINT": {
    "default_value": "Default: ML_NMDINT = 1 for ML_MODE = SELECT | = 10 else",
    "description": "Tag to control the minimum interval to get training samples in the machine learning force field method.",
    "detailed_description": "The usage of this tag in combination with the learning algorithms is described here:\nhere\n\nThis tag defines a lower threshold for taking new configurations from the MD, so that as long as the upper threshold for the Bayesian error (e.g.\nML_CDOUB\ntimes\nML_CTIFOR\n) is not exceeded,  at least\nML_NMDINT\nMD steps are preformed using the MLFF (i.e. no first principles calculation is performed). This avoids that many nearly identical structures are added.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MCONF_NEW",
      "ML_CDOUB",
      "ML_CTIFOR",
      "ML_MHIS"
    ]
  },
  "ML_NRANK_SPARSDES": {
    "default_value": "ML_NRANK_SPARSDES = 5",
    "description": "This tag sets the number of highest eigenvalues to which the correlation is measured within the angular descriptor sparsification (within the machine learning force field method).",
    "detailed_description": "Mind:\nThis tag is only available as of VASP 6.4.3.\n\nThis tag usually does not need to be changed by the user!\n\nFor details on the theory of angular descriptor sparsification see\nhere\n.\n\nFor details on how to use the sparsification see the tag\nML_LSPARSDES\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_LSPARSDES",
      "ML_RDES_SPARSDES",
      "ML_DESC_TYPE"
    ]
  },
  "ML_OUTBLOCK": {
    "default_value": "ML_OUTBLOCK = 1",
    "description": "Output distance in number of steps for molecular-dynamics simulations with machine-learned force fields in prediction-only mode ( ML_MODE = run ).",
    "detailed_description": "Important:\nThis tag is only available as of VASP.6.4.0. Unfortunately, the implementation of this feature was incomplete before VASP.6.4.3. In VASP versions prior to 6.4.3 there was still substantial remaining per-time-step output, in particular in\nvasprun.xml\nand\nvaspout.h5\n(see table below). If possible, please use VASP.6.4.3 or higher for production runs with potentially large file output.\n\nBy default VASP writes all results at every molecular-dynamics step (\nML_OUTBLOCK\n= 1\n). However, this may become inefficient when running long trajectories in production runs with a machine-learned force field in prediction-only mode (\nML_MODE\n= run\n). This is particularly true if the force field supports the fast execution mode, i.e., refitting was performed with\nML_MODE\n= refit\n. Then, depending on the system size, writing output each time step may hinder performance, cause heavy I/O load and create unnecessary large files. In order to circumvent these problems\nML_OUTBLOCK\n= n\ninstructs VASP to write screen and file output only every\nn\ntime steps.\n\nIn order to further increase the efficiency, calculation and output of pair-correlation functions can be completely switched off by setting\nML_OUTPUT_MODE\n= 0\n.\n\nWarning:\nThis tag will potentially override defaults and\nINCAR\nvalues of\nNBLOCK\n!\nNBLOCK\nwill be automatically set to the maximum of\nML_OUTBLOCK\nand\nNBLOCK\n.\n\nA comparison of the effects of\nNBLOCK\nand\nML_OUTBLOCK\non the output frequency of different files/properties is given in the following table. Here, \"yes\" means the output will only be written in the interval in time steps given by the tag value. On the other hand, \"no\" indicates that the output will be written every time step regardless of the tag value.\n\nINCAR\ntag controls output frequency: yes/no\nOutput file/property\nNBLOCK\nML_OUTBLOCK\n≤ 6.4.2\n≥ 6.4.3\nscreen output\nno\nyes\nyes\nOSZICAR\nno\nyes\nyes\nOUTCAR\n↳ energies and time\nno\nno\nyes\n↳ forces and stress\nyes\nyes\nyes\nCONTCAR\nno\nyes\nyes\nXDATCAR\nyes\nyes\nyes\nPCDAT\n(1)\nyes\nyes\nyes\nREPORT\nyes\nyes\nyes\nML_LOGFILE\nno\nyes\nyes\nML_HEAT\nno\nno\nyes\nML_EATOM\nno\nno\nyes\nvasprun.xml\n↳ energy\nno\nno\nyes\n↳ forces\n(1)\nno\nno\nyes\n↳ stress\n(1)\nno\nno\nyes\n↳ structure\n(1)\nno\nno\nyes\n↳ time\nno\nno\nyes\nvaspout.h5\n↳ energies\nno\nno\n(2)\nyes\n↳ forces\nno\nno\n(2)\nyes\n↳ stress\nno\nno\n(2)\nyes\n↳ position_ions\nyes\nyes\nyes\n↳ lattice_vectors\nyes\nyes\nyes\n↳ ion_velocities\nyes\nyes\nyes\n↳ pair_correlation\n(1)\nyes\nyes\nyes\n\n(1)\nML_OUTPUT_MODE\n= 0\ncan disable output completely\n\n(2) Zeros are written for intermediate steps",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_LFAST",
      "ML_IERR",
      "ML_OUTPUT_MODE",
      "NBLOCK"
    ]
  },
  "ML_OUTPUT_MODE": {
    "default_value": "Default: ML_OUTPUT_MODE = 0 if ML_MODE = run | = 1 else",
    "description": "This tag allows to disable certain file output which helps to increase performance in molecular-dynamics simulations with machine-learned force fields in prediction-only mode ( ML_MODE = run ).",
    "detailed_description": "Mind:\nThis tag is only available as of VASP.6.4.0.\n\nThis tag is useful in combination with\nML_OUTBLOCK\nto further reduce per-time-step calculations and file output. The following options exist for this tag:\n\nML_OUTPUT_MODE\n= 1\n:\nNormal operation\n, output is written as usual in ab-initio molecular-dynamics simulations.\nML_OUTPUT_MODE\n= 0\n:\nReduced file output mode\n, in contrast to normal operation the following changes apply:\nPair-correlation functions are not computed.\nNo output to\nPCDAT\nfile.\nNo\npair_correlation\noutput section in\nvaspout.h5\n.\nNo\nstructure\n,\nvarray name=\"forces\"\nand\nvarray name=\"stress\"\noutput sections in\nvasprun.xml\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_LFAST",
      "ML_IERR",
      "ML_OUTBLOCK"
    ]
  },
  "ML_RCOUPLE": {
    "default_value": "ML_RCOUPLE = 1.0",
    "description": "This tag specifies the value of the coupling parameter for the calculation of the chemical potential within the machine learning force field method.",
    "detailed_description": "For thermodynamic integration calculations please have a look at the tag\nML_LCOUPLE\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_LCOUPLE",
      "ML_NATOM_COUPLED",
      "ML_ICOUPLE"
    ]
  },
  "ML_RCUT1": {
    "default_value": "ML_RCUT1 = 8.0",
    "description": "Sets the cutoff radius R cut {\\displaystyle R_\\text{cut}} for the radial descriptor ρ i ( 2 ) ( r ) {\\displaystyle \\rho^{(2)}_i(r)} in Å {\\displaystyle \\AA} .",
    "detailed_description": "The radial descriptor for machine-learned force fields is constructed from\n\nρ\ni\n(\n2\n)\n(\nr\n)\n=\n1\n4\nπ\n∫\nρ\ni\n(\nr\nr\n^\n)\nd\nr\n^\n,\nwhere\nρ\ni\n(\nr\n)\n=\n∑\nj\n=\n1\nN\na\nf\nc\nu\nt\n(\nr\ni\nj\n)\ng\n(\nr\n−\nr\ni\nj\n)\n{\\displaystyle \n\\rho_{i}^{(2)}\\left(r\\right) = \\frac{1}{4\\pi} \\int \\rho_{i}\\left(r\\hat{\\mathbf{r}}\\right) d\\hat{\\mathbf{r}}, \\quad \\text{where} \\quad\n\\rho_{i}\\left(\\mathbf{r}\\right) = \\sum\\limits_{j=1}^{N_{\\mathrm{a}}} f_{\\mathrm{cut}}\\left(r_{ij}\\right) g\\left(\\mathbf{r}-\\mathbf{r}_{ij}\\right)\n}\n\nand\ng\n(\nr\n)\n{\\displaystyle g\\left(\\mathbf{r}\\right)}\nis an approximation of the delta function. A basis set expansion of\nρ\ni\n(\n2\n)\n(\nr\n)\n{\\displaystyle \\rho^{(2)}_i(r)}\nyields the expansion coefficients\nc\nn\n00\ni\n{\\displaystyle c_{n00}^{i}}\n, which are used in practice to describe the atomic environment; refer to the\ntheory of machine-learned force fields\nfor details. The tag\nML_RCUT1\nsets the cutoff radius\nR\ncut\n{\\displaystyle R_\\text{cut}}\nat which the cutoff function\nf\nc\nu\nt\n(\nr\ni\nj\n)\n{\\displaystyle f_{\\mathrm{cut}}\\left(r_{ij}\\right)}\ndecays to zero.\n\nMind:\nThe cutoff radius determines how many neighbor atoms\nN\na\n{\\displaystyle N_\\mathrm{a}}\nare considered to describe each central atom's environment. Hence, important features may be missed if the cutoff radius is too small. On the other hand, a large cutoff radius increases the computational cost of the descriptor as the cutoff sphere contains more neighbor atoms. A good compromise is always system-dependent. Therefore, different values should be tested to achieve satisfying accuracy\nand\nspeed.\n\nThe unit of the cut-off radius is\nÅ\n{\\displaystyle \\AA}\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_RCUT2",
      "ML_W1",
      "ML_SION1",
      "ML_SION2",
      "ML_MRB1",
      "ML_MRB2"
    ]
  },
  "ML_RCUT2": {
    "default_value": "ML_RCUT2 = 5.0",
    "description": "This flag sets the cutoff radius R cut {\\displaystyle R_\\text{cut}} for the angular descriptor ρ i ( 3 ) ( r ) {\\displaystyle \\rho^{(3)}_i(r)} in the machine learning force field method. The unit of the cut-off radius is Å {\\displaystyle \\AA} .",
    "detailed_description": "The angular descriptor is constructed from\n\nρ\ni\n(\n3\n)\n(\nr\n,\ns\n,\nθ\n)\n=\n∬\nd\nr\n^\nd\ns\n^\nδ\n(\nr\n^\n⋅\ns\n^\n−\nc\no\ns\nθ\n)\n∑\nj\n=\n1\nN\na\n∑\nk\n≠\nj\nN\na\nρ\ni\nk\n(\nr\nr\n^\n)\nρ\ni\nj\n(\ns\ns\n^\n)\n,\nwhere\nρ\ni\nj\n(\nr\n)\n=\nf\nc\nu\nt\n(\nr\ni\nj\n)\ng\n(\nr\n−\nr\ni\nj\n)\n{\\displaystyle \n\\rho_{i}^{(3)}\\left(r,s,\\theta\\right) = \\iint d\\hat{\\mathbf{r}} d\\hat{\\mathbf{s}}  \\delta\\left(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{s}} - \\mathrm{cos}\\theta\\right) \\sum\\limits_{j=1}^{N_{a}} \\sum\\limits_{k \\ne j}^{N_{a}} \\rho_{ik} \\left(r\\hat{\\mathbf{r}}\\right) \\rho_{ij} \\left(s\\hat{\\mathbf{s}}\\right), \\quad \\text{where} \\quad\n\\rho_{ij}\\left(\\mathbf{r}\\right) = f_{\\mathrm{cut}}\\left(r_{ij}\\right) g\\left(\\mathbf{r}-\\mathbf{r}_{ij}\\right)\n}\n\nand\ng\n(\nr\n)\n{\\displaystyle g\\left(\\mathbf{r}\\right)}\nis an approximation of the delta function. A basis set expansion of\nρ\ni\n(\n3\n)\n(\nr\n)\n{\\displaystyle \\rho^{(3)}_i(r)}\nyields the expansion coefficients\np\nn\nν\nl\ni\n{\\displaystyle p_{n\\nu l}^{i}}\nwhich are used in practice to describe the atomic environment (see\nthis section\nfor details). The tag\nML_RCUT2\nsets the cutoff radius\nR\ncut\n{\\displaystyle R_\\text{cut}}\nat which the cutoff function\nf\nc\nu\nt\n(\nr\ni\nj\n)\n{\\displaystyle f_{\\mathrm{cut}}\\left(r_{ij}\\right)}\ndecays to zero.\n\nMind:\nThe cutoff radius determines how many neighbor atoms\nN\na\n{\\displaystyle N_\\mathrm{a}}\nare taken into account to describe each central atom's environment. Hence, important features may be missed if the cutoff radius is set to a too small value. On the other hand, a large cutoff radius increases the computational cost as the cutoff sphere contains more neighbor atoms. A larger cutoff can also significantly degrade the learning efficiency. A good compromise is system-dependent, therefore different values should be tested to achieve satisfactory accuracy\nand\nspeed.\n\nFor materials containing only H, B, C, O, N, and F (i.e. organic molecules, polymers), the learning efficiency might increase when ML_RCUT2 is set to values around 4\nÅ\n{\\displaystyle \\AA}\n(that is, less training data are required to achieve a specific accuracy), wheres for materials with very long bonds, a larger value around 6\nÅ\n{\\displaystyle \\AA}\ncan improve the accuracy,",
    "related_tags": [
      "ML_LMLFF",
      "ML_RCUT1",
      "ML_W1",
      "ML_SION1",
      "ML_SION2",
      "ML_MRB1",
      "ML_MRB2"
    ]
  },
  "ML_RDES_SPARSDES": {
    "default_value": "ML_RDES_SPARSDES = 0.5",
    "description": "Sets the ratio of descriptors kept during angular-descriptor sparsification.",
    "detailed_description": "Mind:\nThis tag is only available as of VASP 6.4.3.\n\nDuring\nangular-descriptor sparsification\n(\nML_LSPARSDES\n=T), insignificant angular descriptors are removed based on a leverage scoring. The percentage of angular descriptors that are kept is determined by the value of\nML_RDES_SPARSDES\n, which must be chosen between\n0\n<\nr\n≤\n1\n{\\displaystyle 0 < r \\leq 1}\n. In practice, we recommend scanning a range between 0.1 to 0.9. Removing angular descriptors increases the performance of a force field, but it decreases accuracy at the same time. One method of finding the optimal tradeoff between accuracy and performance is to do a Pareto front with run time on the x-axis and accuracy on the y-axis.",
    "related_tags": [
      "ML_LMLFF",
      "ML_LSPARSDES",
      "ML_NRANK_SPARSDES",
      "ML_DESC_TYPE"
    ]
  },
  "ML_SCLC_CTIFOR": {
    "default_value": "ML_SCLC_CTIFOR = 0.6",
    "description": "Sets fraction by which the error threshold for the maximum forces is lowered in the selection of local reference calculations.",
    "detailed_description": "ML_CTIFOR\ndetermines whether a first-principles calculation is performed when training an MLFF. \nWhenever a first-principles calculation is performed, additional functions are added to the sparse representation of the kernel (local-reference configurations).\nML_SCLC_CTIFOR\ndetermines how many local-reference configurations are added to the sparse representation of the kernel.\nSpecifically, the local environment of those atoms with an estimated error larger than\nML_SCLC_CTIFOR\n*\nML_CTIFOR\nare\nadded as candidates for the sparse representational of the kernel. Note that changing\nML_SCLC_CTIFOR\ndoes not change the decision of whether a first-principles calculation is carried out or not, since this decision is entirely based on\nML_CTIFOR\n.\n\nThe default value of 0.6 is often a reasonably good compromise. If the value is decreased, obviously more functions are used for the sparse representation of the kernel. This always improves the initial learning efficiency but might slow the force-field calculations. \nSo\nML_SCLC_CTIFOR\ncompromises either learning efficiency or the speed of the evaluation of the MLFF.\nFor polymers and liquids, we found that decreasing\nML_SCLC_CTIFOR\nto values around  0.4 (or even smaller) can significantly improve learning efficiency.",
    "related_tags": [
      "ML_LMLFF",
      "ML_CTIFOR",
      "ML_CX",
      "ML_EPS_LOW"
    ]
  },
  "ML_SIGV0": {
    "default_value": "ML_SIGV0 = 1.0",
    "description": "This flag sets the noise parameter s v {\\displaystyle s_{\\mathrm{v}}} (see here for definition) for the fitting in the machine learning force field method.",
    "detailed_description": "If the regularization needs to be controlled manually, like e.g. in the fitting via singular value decomposition (\nML_MODE\n=\nREFIT\nor\nML_IALGO_LINREG\n=4), the best is to keep this parameter constant at 1 and control the regularization via the precision parameter\ns\nw\n{\\displaystyle s_{\\mathrm{w}}}\n(see\nML_SIGW0\n).\n\nFor the theory of this regularization parameter see\nthis section\n.\n\nRelated tags and sections\n\nML_LMLFF\n,\nML_IREG\n,\nML_SIGW0\n,\nML_IALGO_LINREG\n\nExamples that use this tag",
    "related_tags": []
  },
  "ML_SIGW0": {
    "default_value": "none Default: ML_SIGW0 = 1E-7 for ML_MODE = REFIT = 1.0 else",
    "description": "This flag sets the precision parameter s w {\\displaystyle s_{\\mathrm{w}}} (see here for definition) for the fitting in the machine learning force field method.",
    "detailed_description": "The default value for\nML_MODE\n=\nREFIT\nworks reliably in most calculations, however, sometimes it is necessary to increase the regularization parameter to avoid instabilities during finite temperature molecular dynamics simulations.\n\nSuppose the regularization needs to be controlled manually, like e.g. in the fitting via singular value decomposition (\nML_MODE\n=\nREFIT\nor\nML_IALGO_LINREG\n=4). The best is to control the regularization via this parameter and keep the noise parameter\ns\nv\n{\\displaystyle s_{\\mathrm{v}}}\n(see\nML_SIGV0\n) constant at 1. Useful values for\nML_SIGW0\nare typically between 1E-1 and 1E-9. When the value is increased the regularization is increased. This often slightly increases the training set error but also reduces potential instabilities. Hence, if instabilities are observed during molecular-dynamics simulations, one should try to increase\nML_SIGW0\nto say 1E-3, then refit, and repeat the molecular-dynamics simulations.\n\nMore on the theory of this regularization parameter can be found in\nthis section\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_MODE",
      "ML_IREG",
      "ML_SIGV0",
      "ML_IALGO_LINREG"
    ]
  },
  "ML_SION1": {
    "default_value": "ML_SION1 = 0.5",
    "description": "This tag specifies the width σ atom {\\displaystyle \\sigma_\\text{atom}} of the Gaussian functions used for broadening the atomic distributions of the radial descriptor ρ i ( 2 ) ( r ) {\\displaystyle \\rho^{(2)}_i(r)} within the machine learning force field method.",
    "detailed_description": "The radial descriptor is constructed from\n\nρ\ni\n(\n2\n)\n(\nr\n)\n=\n1\n4\nπ\n∫\nρ\ni\n(\nr\nr\n^\n)\nd\nr\n^\n,\nwhere\nρ\ni\n(\nr\n)\n=\n∑\nj\n=\n1\nN\na\nf\nc\nu\nt\n(\nr\ni\nj\n)\ng\n(\nr\n−\nr\ni\nj\n)\n{\\displaystyle \n\\rho_{i}^{(2)}\\left(r\\right) = \\frac{1}{4\\pi} \\int \\rho_{i}\\left(r\\hat{\\mathbf{r}}\\right) d\\hat{\\mathbf{r}}, \\quad \\text{where} \\quad\n\\rho_{i}\\left(\\mathbf{r}\\right) = \\sum\\limits_{j=1}^{N_{\\mathrm{a}}} f_{\\mathrm{cut}}\\left(r_{ij}\\right) g\\left(\\mathbf{r}-\\mathbf{r}_{ij}\\right)\n}\n\nand\ng\n(\nr\n)\n{\\displaystyle g\\left(\\mathbf{r}\\right)}\nis the following approximation of the delta function:\n\ng\n(\nr\n)\n=\n1\n2\nσ\na\nt\no\nm\nπ\ne\nx\np\n(\n−\n|\nr\n|\n2\n2\nσ\na\nt\no\nm\n2\n)\n.\n{\\displaystyle  \ng\\left(\\mathbf{r}\\right)=\\frac{1}{\\sqrt{2\\sigma_{\\mathrm{atom}}\\pi}}\\mathrm{exp}\\left(-\\frac{|\\mathbf{r}|^{2}}{2\\sigma_{\\mathrm{atom}}^{2}}\\right).\n}\n\nThe tag\nML_SION1\nsets the width\nσ\natom\n{\\displaystyle \\sigma_\\text{atom}}\nof the above Gaussian function (see\nthis section\nfor more details).\n\nTip:\nOur test calculations indicate that\nML_SION1\n=\nML_SION2\nresults in an optimal training performance. Furthermore, a value of 0.5 was found to be a good default value for both. However, the best choice is somewhat system-dependent. For instance, a smaller value for\nML_SION1\ncan increase the number of local reference configurations, and hence ultimately the quality of the MLFF. See also\nhere\n.\n\nThe unit of\nML_SION1\nis\nÅ\n{\\displaystyle \\AA}\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_SION2",
      "ML_RCUT1",
      "ML_RCUT2",
      "ML_MRB1",
      "ML_MRB2"
    ]
  },
  "ML_SION2": {
    "default_value": "ML_SION2 = ML_SION1",
    "description": "This tag specifies the width σ atom {\\displaystyle \\sigma_\\text{atom}} of the Gaussian functions used for broadening the atomic distributions of the angular descriptor ρ i ( 3 ) ( r ) {\\displaystyle \\rho^{(3)}_i(r)} within the machine learning force field method.",
    "detailed_description": "The angular descriptor is constructed from\n\nρ\ni\n(\n3\n)\n(\nr\n,\ns\n,\nθ\n)\n=\n∬\nd\nr\n^\nd\ns\n^\nδ\n(\nr\n^\n⋅\ns\n^\n−\nc\no\ns\nθ\n)\n∑\nj\n=\n1\nN\na\n∑\nk\n≠\nj\nN\na\nρ\ni\nk\n(\nr\nr\n^\n)\nρ\ni\nj\n(\ns\ns\n^\n)\n,\nwhere\nρ\ni\nj\n(\nr\n)\n=\nf\nc\nu\nt\n(\nr\ni\nj\n)\ng\n(\nr\n−\nr\ni\nj\n)\n{\\displaystyle \n\\rho_{i}^{(3)}\\left(r,s,\\theta\\right) = \\iint d\\hat{\\mathbf{r}} d\\hat{\\mathbf{s}}  \\delta\\left(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{s}} - \\mathrm{cos}\\theta\\right) \\sum\\limits_{j=1}^{N_{a}} \\sum\\limits_{k \\ne j}^{N_{a}} \\rho_{ik} \\left(r\\hat{\\mathbf{r}}\\right) \\rho_{ij} \\left(s\\hat{\\mathbf{s}}\\right), \\quad \\text{where} \\quad\n\\rho_{ij}\\left(\\mathbf{r}\\right) = f_{\\mathrm{cut}}\\left(r_{ij}\\right) g\\left(\\mathbf{r}-\\mathbf{r}_{ij}\\right)\n}\n\nand\ng\n(\nr\n)\n{\\displaystyle g\\left(\\mathbf{r}\\right)}\nis the following approximation of the delta function:\n\ng\n(\nr\n)\n=\n1\n2\nσ\na\nt\no\nm\nπ\ne\nx\np\n(\n−\n|\nr\n|\n2\n2\nσ\na\nt\no\nm\n2\n)\n.\n{\\displaystyle  \ng\\left(\\mathbf{r}\\right)=\\frac{1}{\\sqrt{2\\sigma_{\\mathrm{atom}}\\pi}}\\mathrm{exp}\\left(-\\frac{|\\mathbf{r}|^{2}}{2\\sigma_{\\mathrm{atom}}^{2}}\\right).\n}\n\nThe tag\nML_SION2\nsets the width\nσ\natom\n{\\displaystyle \\sigma_\\text{atom}}\nof the above Gaussian function (see\nthis section\nfor more details).\n\nTip:\nOur test calculations indicate that\nML_SION1\n=\nML_SION2\nresults in an optimal training performance. Furthermore, a value of 0.5 was found to be a good default value for both. However, the best choice is system-dependent, careful testing may improve machine learning results.\n\nThe unit of\nML_SION2\nis\nÅ\n{\\displaystyle \\AA}\n.",
    "related_tags": [
      "ML_LMLFF",
      "ML_SION1",
      "ML_RCUT1",
      "ML_RCUT2",
      "ML_MRB1",
      "ML_MRB2"
    ]
  },
  "ML_W1": {
    "default_value": "ML_W1 = 0.1",
    "description": "This tag defines the weight β {\\displaystyle \\beta} for the radial (and angular) descriptor within the machine learning force field method (see this section ).",
    "detailed_description": "The weight for the angular descriptor\nW\n2\n{\\displaystyle W_{2}}\nis internally computed from the weight of the radial descriptor\nW\n1\n{\\displaystyle W_{1}}\nas:\n\nW\n2\n=\n1.0\n−\nW\n1\n.\n{\\displaystyle W_{2}=1.0-W_{1}.}\n\nThe value for\nML_W1\nmust be chosen in the interval\n[\n0\n,\n1\n]\n{\\displaystyle [0, 1]}\n.\n\nBy default, the angular and radial descriptors are both used although the latter is weighed less. In principle a weight of 0 for one of them is selectable which allows the code to internally skip the respective computation. However, it is generally recommended to use both descriptors to achieve satisfying training results.",
    "related_tags": [
      "ML_LMLFF",
      "ML_RCUT1",
      "ML_RCUT2",
      "ML_SION1",
      "ML_SION2"
    ]
  },
  "ML_WTIFOR": {
    "default_value": "Default: ML_WTIFOR = 0.05 if ML_IWEIGHT =1 | = 1.0 otherwise",
    "description": "This tag sets the weight for the scaling of the forces in the training data within the machine learning force field method.",
    "detailed_description": "ML_IWEIGHT\n,\nML_WTOTEN\n,\nML_WTIFOR\n,\nML_WTSIF\nform a group of tags which set the normalization and weighting of ab initio training data, i.e.  energies, forces and stresses of the training structures. The main control tag is\nML_IWEIGHT\n, please also have a look at its detailed description. If\nML_IWEIGHT\n=1 the weight has unit eV/Angstrom and is used to divide the data by it. For\nML_IWEIGHT\n=2 and 3 the weights are unitless and multiplicative.",
    "related_tags": [
      "ML_LMLFF",
      "ML_IWEIGHT",
      "ML_WTOTEN",
      "ML_WTSIF",
      "ML_IALGO_LINREG"
    ]
  },
  "ML_WTOTEN": {
    "default_value": "Default: ML_WTOTEN = 0.005 if ML_IWEIGHT =1 | = 1.0 otherwise",
    "description": "Sets a scaling of the fitted potential energy.",
    "detailed_description": "For\nML_IWEIGHT\n=2 and 3 (default), the potential energy in the training data set is multiplied by\nML_WTOTEN\n(unitless). We recommend increasing\nML_WTOTEN\nif you plan to apply the force field in a simulation where the accuracy of the total energy is most important. This puts a focus on the energy error and is desirable, for instance, for the computation of defect-formation energies.\n\nFor\nML_IWEIGHT\n=1,\nML_WTOTEN\nhas the unit of eV/atom, and the potential energy in the training data set is divided by it.",
    "related_tags": [
      "ML_IWEIGHT",
      "ML_WTIFOR",
      "ML_WTSIF",
      "ML_IALGO_LINREG",
      "ML_LMLFF"
    ]
  },
  "ML_WTSIF": {
    "default_value": "Default: ML_WTSIF = 5.0 if ML_IWEIGHT =1 | = 1.0 otherwise",
    "description": "This tag sets the weight for the scaling of the stress in the training data within the machine learning force field method.",
    "detailed_description": "ML_IWEIGHT\n,\nML_WTOTEN\n,\nML_WTIFOR\n,\nML_WTSIF\nform a group of tags which set the normalization and weighting of ab initio training data, i.e.  energies, forces and stresses of the training structures. The main control tag is\nML_IWEIGHT\n, please also have a look at its detailed description. If\nML_IWEIGHT\n=1 the weight has unit kBar and is used to divide the data by it. For\nML_IWEIGHT\n=2 and 3 the weights are unitless and multiplicative.",
    "related_tags": [
      "ML_LMLFF",
      "ML_IWEIGHT",
      "ML_WTIFOR",
      "ML_WTOTEN",
      "ML_IALGO_LINREG"
    ]
  },
  "M_CONSTR": {
    "default_value": "M_CONSTR = 3*NIONS*0.0",
    "description": "M_CONSTR specifies the desired local magnetic moment (size and/or direction) for the constrained local moments approach.",
    "detailed_description": "The\nM_CONSTR\ntag sets the desired size and/or direction of the integrated local magnetic moments in cartesian coordinates.\n\nFor each ion 3 coordinates must be specified, i.e., for a system of\nN\nions\n\nM_CONSTR\n= M_1x M_1y M_1z  M_2x M_2y M_2z  ....  M_Nx M_Ny M_Nz\n\nFor\nI_CONSTRAINED_M\n=1 the norm of this vector is meaningless since only the direction will be constrained. For\nI_CONSTRAINED_M\n=2 both the norm as well as the direction of the moments specified by means of\nM_CONSTR\nare subject to constraints.\n\nSetting\n\nM_CONSTR\n=  ... 0 0 0 ...\n\nfor a certain ion is equivalent to imposing no constraints on the integrated local magnetic moment at this ionic site.\n\nFor an explanation of the constrained local moments approach see the description of the\nI_CONSTRAINED_M\ntag.",
    "related_tags": [
      "I_CONSTRAINED_M",
      "LAMBDA",
      "RWIGS",
      "LNONCOLLINEAR"
    ]
  },
  "NATURALO": {
    "default_value": "NATURALO = 0; for low scaling GW type calculations the default is 4",
    "description": "calculate RPA natural orbitals.",
    "detailed_description": "This flag should be used in combination with\nALGO\n= G0W0R or\nALGO\n= scGW0R.  The VASP code diagonalizes the RPA density\nmatrix and writes the final natural orbitals to the\nWAVECAR\nfile.\nThe one-electron occupancies on the\nWAVECAR\nfile can also be updated to the eigenvalues of the RPA density matrix. For\nALGO\n= G0W0R, the interacting Green's function is approximated as\n\nG\n=\nG\n0\n+\nG\n0\nΣ\nG\n0\n{\\displaystyle \nG = G_0 + G_0 \\Sigma G_0\n}\n\nwhereas for\nALGO\n= scGW0R the Dyson equation is solved\n\nG\n=\nG\n0\n+\nG\nΣ\nG\n0\n.\n{\\displaystyle \nG = G_0 + G \\Sigma G_0.\n}\n\nIn both cases, the RPA density matrix is determined as\nγ\n=\nlim\nτ\n→\n0\n−\nG\n(\nτ\n)\n{\\displaystyle  \\gamma= \\lim_{\\tau \\to 0^-} G(\\tau) }\n. More details on the use of RPA natural orbitals can be found in Ref.\n[1]\n.\n\nThe following settings are currently supported\n\nNATURALO\n=0 calculate the density matrix, diagonalize the matrix and write the natural orbitals and eigenvalues of the density matrix to\nWAVECAR\n. The eigenvalues of the density matrix are stored in the occupancy entries of the\nWAVECAR\nfile, whereas the one-electron DFT eigenvalues remain untouched. This setting is usually not particularly useful for practical calculations and should be used only by experts. Furthermore,\nLFINITE_TEMPERATURE\nshould not be combined with this setting.\n\nNATURALO\n=1 calculate the density matrix, diagonalize the matrix only in the sub-block of unoccupied states, and write the occupied Kohn Sham orbitals, as well as the natural orbitals corresponding to unoccupied states to the file\nWAVECAR\n. The unoccupied orbitals are ordered according to their occupancies in the RPA density matrix. The one-electron occupancies and KS-DFT eigenvalues are not updated from their KS values (the occupancies will remain 1 for occupied Kohn-Sham orbitals and 0 for natural orbitals representing the virtual manifold). This setting has been used in Ref.\n[1]\n. See also Ref.\n[2]\nfor further information. Note that all orbitals- even those with a tiny fractional occupancy -are treated as occupied orbitals and not updated: the algorithm should hence even work for metallic systems.\n\nNATURALO\n<0. Similar to\nNATURALO\n=1 but additionally conserves ABS|\nNATURALO\n| unoccupied Kohn-Sham states. This is expedient, for subsequent GW and BSE calculations to conserve  few unoccupied orbitals to their Kohn-Sham states.\n\nIf 10 is added (e.g.\nNATURALO\n=10,\nNATURALO\n=11) the density matrix is diagonalizes using a perturbative Loewdin algorithm that attempts to keep the orbital order strictly conserved: E.g. the natural orbital matching closest to each Kohn-Sham orbital will be determined and stored. Use this tag for metals.\n\nNATURALO\n=2 (or 12) is similar to 0, but the one-electron occupancies are not updated. In rare cases this might lead to inconsistencies, if the orbital order changes between DFT and the RPA density matrix (i.e. a previously occupied DFT orbitals posses a smaller occupation in the RPA density matrix than some unoccupied Kohn-Sham orbitals and are moved into the unoccupied block). This problem can be reduced using\nNATURALO\n=12, as described above. This flag, in combination with\nALGO\n= scGW0R, can be used to evaluate the GW-singles contribution to the correlation energy.\n[3]\nOne can deduct the HF singles and the GW singles energies from the energies after\n\nEnergies after diagonalization of HF Hamiltonian (single shot)\n    Hartree-Fock free energy of the ion-electron system (eV)\n\nEnergies after update of density matrix\n    Hartree-Fock free energy of the ion-electron system (eV)\n\nExperience has shown that there is very little difference between the natural orbitals obtained using\nALGO\n= G0W0R and\nALGO\n= scGW0R. We strongly recommend to use the more efficient and better tested algorithm\nALGO\n= G0W0R (with the exception of GW-singles) to determine natural orbitals. Furthermore, perform careful tests for\nNOMEGA\n: the RPA total energy converges much faster then the natural orbitals. Using a too small\nNOMEGA\ncan yield natural orbitals that are non-optimal, leading to very slow convergence of correlated calculations with respect to the number of natural orbitals.\nA crucial test is that the following line\n\ncorrelated contrib. to density matrix         0.0000004037        0.0000000000\n\nin the stdout and OUTCAR file shows values close to zero (for\nALGO\n= G0W0R). The above value is perfectly acceptable and the value decreases as\nNOMEGA\nincreases.\n\nNATURALO\n=4 preserves original (DFT) orbitals but updates the eigenvalues in the\nWAVECAR\nfile to the QP energies. This mode is useful if only quasi-particle energies are corrected with the GW method, for instance when selecting\nALGO\n=\nEVGW0R\n.\n\nMind:\navailable as of VASP.6.4:",
    "related_tags": [
      "ALGO",
      "ACFDT/RPA formalism",
      "GW calculations"
    ]
  },
  "NBANDS": {
    "default_value": "Default: NBANDS = max( NELECT /2+NIONS/2, NELECT *0.6)",
    "description": "NBANDS specifies the total number of KS or QP orbitals in the calculation.",
    "detailed_description": "The right choice of\nNBANDS\nstrongly depends on the type of the performed calculation and the system. As a minimum, VASP requires all occupied states + one empty band, otherwise, a warning is given.\n\nElectronic minimization\n\nIn the electronic minimization calculations, empty states do not contribute to the total energy, however, empty states are required to achieve a better convergence. \nIn iterative matrix-diagonalization algorithms (see\nALGO\n) eigenvectors close to the top of the calculated number of states converge much slower than the lowest eigenstates, thus it is important to choose a sufficiently large\nNBANDS\n.  Therefore, we recommend using the default settings for\nNBANDS\n, i.e.,\nNELECT/2 + NIONS/2\n, which is a safe choice in most cases. In some cases, it is also possible to decrease it to\nNELECT/2+NIONS/4\n, however, in some transition metals with open\nf\nshells a much larger number of empty bands might be required (up to\nNELECT/2+2*NIONS\n).  To check this parameter perform several calculations for a fixed potential (\nICHARG\n=12) with an increasing number of bands (e.g. starting from\nNELECT/2 + NIONS/2\n). An accuracy of\n10\n−\n6\n{\\displaystyle  10^{-6}}\nshould be obtained in 10-15 iterations.\n\nTip:\nNote that the\nRMM-DIIS\nscheme (\nALGO\n=Fast) is more sensitive to the number of bands than the default Davidson algorithm (\nALGO\n=Normal) and can require more bands for fast convergence.\n\nMany-body perturbation theory calculations\n\nIn the Many-Body Perturbation Theory calculations (\nGW\n,\nRPA\n, and\nBSE\n), a large number of empty orbitals is usually required, which can be much higher than the number of occupied states.  The convergence of the calculations with a large number of empty states can be very slow. In such cases, we recommend performing an exact diagonalization (\nALGO\n=Exact) of the Hamiltonian with empty bands starting from a converged charge density.\n\nParallelization\n\nWhen executed on multiple CPUs, VASP automatically increases the number of bands, so that\nNBANDS\nis divisible by the number of CPU cores.  If\nNCORE\n> 1,\nNBANDS\nis increased until it is divisible by the number of cores in a group (\nNCORE\n).  If\nKPAR\n> 1,\nNBANDS\nis increased until it is divisible by the number of cores in a group.\n\nSpin-polarized calculation\n\nIn the case of spin-polarized calculations, the default value for\nNBANDS\nis increased to account for the initial magnetic moments.\n\nNoncollinear calculation\n\nIn noncollinear calculations, the default\nNBANDS\nvalue is doubled to account for the spinors components.\n\nRelated tags and article\n\nNCORE\n,\nNBANDS\n,\nNBANDSGW\n,\nNBANDSV\n,\nNBANDSO\n,\nNPAR\n,\nKPAR",
    "related_tags": []
  },
  "NBANDSEXACT": {
    "default_value": "Default: NBANDSEXACT = -1 for LALL_IN_ONE =.FALSE. | = maximum number of plane waves for LALL_IN_ONE =.TRUE.",
    "description": "NBANDSEXACT specifies the number of bands used in the all-in-one mode of many-body perturbation theory calculations.",
    "detailed_description": "Mind:\navailable as of VASP.6.4.0\n\nIn the all-in-one mode, VASP automatically performs the necessary DFT steps prior to the many-body perturbation theory (MBPT) calculation, i.e. a DFT calculation with\nNBANDS\n, followed by an exact diagonalization of the Kohn-Sham Hamiltonian with\nNBANDSEXACT\nbands. \nNote,\nNBANDSEXACT\nis set by default to the maximum number of plane-waves given by the chosen energy cutoff for the orbitals\nENCUT\n. \nIn the all-in-one mode, the actual GW/RPA calculation is also performed with\nNBANDSEXACT\nbands. \nIf\nNBANDS_WAVE\nis not set, all orbitals are written to\nWAVECAR\n, which potentially becomes huge in file size.\n\nTip:\nThe\nNBANDS_WAVE\ntag can be used to limit the number of bands written to\nWAVECAR\nif\nLALL_IN_ONE\n=.TRUE.\n\nThe all-in-one mode is automatically enabled for\nALGO\n=[EV]GW[0]R, RPA[R],ACFDT[R] if\nNBANDS\nis not set.",
    "related_tags": [
      "ALGO",
      "NBANDS",
      "NBANDS_WAVE",
      "LALL_IN_ONE",
      "IALL_IN_ONE"
    ]
  },
  "NBANDSGW": {
    "default_value": "NBANDSGW = twice the number of occupied states",
    "description": "The flag determines how many QP energies are calculated and updated in GW type calculations.",
    "detailed_description": "This value usually needs to be increased somewhat for partially or fully self-consistent calculations. Very accurate results\nare only obtained when\nNBANDSGW\napproaches\nNBANDS\n, although this  dramatically increases the computational requirements.",
    "related_tags": [
      "NBANDS"
    ]
  },
  "NBANDSO": {
    "default_value": "Default: NBANDSO = number of occupied orbitals",
    "description": "NBANDSO determines how many occupied orbitals are included in the Casida/ BSE calculations or time propagation ( ALGO =TIMEEV.",
    "detailed_description": "For the time-propagation algorithm increasing\nNBANDSO\nonly modestly increases the compute time.\nFor BSE and Casida-type calculations, the compute time  grows with the third power of the number of included occupied and unoccupied bands\n\n(\nN\no\nc\nc\nN\nv\ni\nr\nt\nu\na\nl\nN\nk\n)\n3\n{\\displaystyle  (N_{\\mathrm{occ}} N_{\\mathrm{virtual}} N_{\\mathrm{k}})^{3} }\n\nand the memory requirements increase quadratically\n\n(\nN\no\nc\nc\nN\nv\ni\nr\nt\nu\na\nl\nN\nk\n)\n2\n{\\displaystyle  (N_{\\mathrm{occ}}N_{\\mathrm{virtual}} N_{\\mathrm{k}})^{2} }\n\nPlease be aware that symmetry is not exploited in the BSE code, hence memory requirements can be excessive. To allow for calculations on large systems, the BSE code distributes the BSE matrix among all available cores and uses ScaLAPACK for the diagonalization.\n\nVASP always uses the orbitals closest to the Fermi-level, and\nNBANDSO\n(\nN\no\nc\nc\n{\\displaystyle N_{\\mathrm{occ}}}\n) and\nNBANDSV\n(\nN\nv\ni\nr\nt\nu\na\nl\n{\\displaystyle N_{\\mathrm{virtual}}}\n) determines how many occupied and unoccupied orbitals are included. The defaults are fairly \"conservative\" and equal the total number of electrons/2 (this usually implies that all occupied states are included). For highly accurate results,\nNBANDSV\noften needs to be increased, whereas for large systems one is often forced to reduce both values to much smaller numbers. Sometimes qualitative results for bandlike  Wannier-Mott excitons can be obtained even with a single conduction and valence band.",
    "related_tags": [
      "NBANDSV",
      "BSE calculations",
      "Timepropagation"
    ]
  },
  "NBANDSV": {
    "default_value": "",
    "description": "NBANDSV determines how many unoccupied orbitals are included in the Casida/ BSE calculations or timepropagation .",
    "detailed_description": "For the time-propagation algorithm increasing\nNBANDSV\nonly modestly increases the compute time.\nFor BSE and Casida type calculations, the compute time  grows with the third power of the number of included occupied and unoccupied bands\n\n(\nN\no\nc\nc\nN\nv\ni\nr\nt\nu\na\nl\nN\nk\n)\n3\n{\\displaystyle  (N_{\\mathrm{occ}} N_{\\mathrm{virtual}} N_{\\mathrm{k}})^{3} }\n\nand the memory requirements increase quadratically\n\n(\nN\no\nc\nc\nN\nv\ni\nr\nt\nu\na\nl\nN\nk\n)\n2\n{\\displaystyle  (N_{\\mathrm{occ}}N_{\\mathrm{virtual}} N_{\\mathrm{k}})^{2} }\n\nPlease be aware that symmetry is not exploited in the BSE code, hence memory requirements can be excessive. To allow for calculations on large systems, the BSE code distributes the BSE matrix among all available cores and uses ScaLAPACK for the diagonalization.\n\nVASP always uses the orbitals closest to the Fermi-level, and\nNBANDSO\n(\nN\no\nc\nc\n{\\displaystyle N_{\\mathrm{occ}}}\n) and\nNBANDSV\n(\nN\nv\ni\nr\nt\nu\na\nl\n{\\displaystyle N_{\\mathrm{virtual}}}\n) determines how many occupied and unoccupied orbitals are included. The defaults are fairly \"conservative\" and equal the total number of electrons/2 (this usually implies that all occupied state are included). For highly accurate results,\nNBANDSV\noften needs to be increased, whereas for large systems one is often forced to reduce both values to much smaller numbers. Sometimes qualitative results for bandlike  Wannier-Mott excitons can be obtained even with a single conduction and valence band.\n\nRelated tag and articles\n\nNBANDSO\n,\nBSE calculations\n,\ntimepropagation\n\nExamples that use this tag",
    "related_tags": []
  },
  "NBANDS_WAVE": {
    "default_value": "Default: NBANDS_WAVE = NBANDSGW for LALL_IN_ONE =.TRUE. and NBANDS <1 | = NBANDS for LALL_IN_ONE =.TRUE. and NBANDS >0 | = NBANDSEXACT for LALL_IN_ONE =.FALSE. and NBANDS <1 | = NBANDS for LALL_IN_ONE =.FALSE. and NBANDS >0",
    "description": "NBANDS_WAVE specifies the number of bands written to WAVECAR in the all-in-one mode of many-body perturbation theory calculations, i.e., ALGO = ACFDT[R] , [EV]GW0[R] , GWR .",
    "detailed_description": "Mind:\navailable as of VASP.6.4.0\n\nIn the all-in-one mode, VASP automatically performs the necessary DFT steps prior to the many-body perturbation theory (MBPT) calculation, i.e. a DFT calculation with\nNBANDS\n, followed by an exact diagonalization of the Kohn-Sham Hamiltonian with\nNBANDSEXACT\nbands. \nNote,\nNBANDSEXACT\nis set by default to the maximum number of plane-waves given by the chosen energy cutoff for the orbitals\nENCUT\n. \nIn the all-in-one mode, the actual GW/RPA calculation is also performed with\nNBANDSEXACT\nbands. \nIf\nNBANDS_WAVE\nis not set, all orbitals are written to\nWAVECAR\n, which potentially becomes huge in file size.\n\nTip:\nThe\nNBANDS_WAVE\ntag can be used to limit the number of bands written to\nWAVECAR\nif\nLALL_IN_ONE\n=.TRUE.\n\nThe all-in-one mode is automatically enabled for\nALGO\n=[EV]GW[0]R, RPA[R],ACFDT[R] if\nNBANDS\nis not set.",
    "related_tags": [
      "ALGO",
      "NBANDS",
      "NBANDSEXACT",
      "IALL_IN_ONE",
      "LALL_IN_ONE"
    ]
  },
  "NBLK": {
    "default_value": "Default: NBLK = -1 VASP.4.6 | = 256 in VASP.5.2, if dfast",
    "description": "NBLK determines the blocking factor in many BLAS level 3 routines.",
    "detailed_description": "In some cases, VASP has to perform a unitary transformation of the current orbitals. This is done using a work array CBLOCK and the following FORTRAN code:\n\nDO 100 IBLOCK=0,NPL-1,NBLK\n         ILEN=MIN(NBLK,NPL-IBLOCK)\n         DO 200 N1=1,N\n            DO 200 M=1,ILEN\n            CBLOCK(M,N1)=C(M+IBLOCK,N1)\n            C(M+IBLOCK,N1)=0\n  200    CONTINUE\nC        C(IBLOCK+I,N)=SUM_(J,K) CH(I,K) CBLOCK(K,N)\n         CALL ZGEMM ('N', 'N', ILEN, N, N, (1.,0.), CBLOCK, NBLK, CH, N,\n              &   (1.,0.), C(IBLOCK+1,1), NDIM)\n  100 CONTINUE\n\nZGEMM is the matrix\n×\n{\\displaystyle \\times}\nmatrix  multiplication command of the BLAS package. The task performed by this call is indicated by the comment line written above the ZGEMM call. Generally\nNBLK\n=16 or 32 is large enough for super-scalar machines. A large value might be necessary on vector machines for optimal performance (\nNBLK\n=128).\n\nExamples that use this tag",
    "related_tags": []
  },
  "NBLOCK": {
    "default_value": "NBLOCK = 1",
    "description": "After NBLOCK ionic steps the pair-correlation function and the DOS are calculated and the ionic configuration is written to the XDATCAR -file.",
    "detailed_description": "It is recommended to leave\nNBLOCK\nto 1, since the computational overhead to determine the DOS and pair correlation function is minimal. Only for  molecular dynamics simulations with many 1000 steps or when using machine-learned force fields, it might be expedient to increase\nNBLOCK\nto say 10 or even 100, to avoid large\nXDATCAR\n-files and the evaluation of the pair correlation function at every step.\n\nTip:\nIf machine-learned force fields are used in prediction-only mode (\nML_MODE\n= run\n) prefer to use the\nML_OUTBLOCK\ntag instead of\nNBLOCK\nto control the output frequency.\n\nIn addition\n\nNBLOCK\ncontrols how often the kinetic energy is scaled if\nSMASS\n= -1\n.\n\nAfter\nKBLOCK\n*\nNBLOCK\nionic steps the averaged pair correlation function and DOS are written to the files\nPCDAT\nand\nDOSCAR\n. The internal accumulators are reset, and after another\nKBLOCK\n*\nNBLOCK\nsteps the new averaged quantities are written out.\n\nWarning:\nThe product of\nKBLOCK\nand\nNBLOCK\nshould not be larger than the number of steps\nNSW\n. If\nKBLOCK\n*\nNBLOCK\n>\nNSW\nbefore starting the main ion loop then\nKBLOCK\nis automatically reset to 1. Next, if the same conditions is still true,\nNBLOCK\nis reset to\nNSW\n. Also, mind that\nNBLOCK\nwill be at minimum\nML_OUTBLOCK\nin MLFF prediction-only MD runs.",
    "related_tags": [
      "PCDAT",
      "DOSCAR",
      "XDATCAR",
      "KBLOCK",
      "ML_OUTBLOCK"
    ]
  },
  "NBMOD": {
    "default_value": "Default: NBMOD = n if IBAND is set and contains n values | = -2 if EINT is set and IBAND is not set | = -1 if neither EINT nor IBAND are set",
    "description": "NBMOD controls how bands are selected when computing partial charge densities .",
    "detailed_description": "NBMOD\nis used with other tags to define the mode of band selection for partial charge densities in\nPARCHG\n,\nvaspout.h5\n, or\nCHGCAR\nfiles. There are several ways to set this tag.\n\nNBMOD\n= n: Use n bands\n\nIf a positive integer is passed,\nNBMOD\nrepresents the number of values in the array\nIBAND\n. If\nIBAND\nis specified,\nNBMOD\nis set automatically to the number of values passed in\nIBAND\n.\n\nTip:\nThere is no good reason to set\nNBMOD\nto a positive integer since it will be overwritten regardless if\nIBAND\nis set or not. Use the\nIBAND\ntag alone to enter this mode.\n\nNBMOD\n= 0: Use all bands\n\nAll bands, even unoccupied ones, are contributing to calculating the partial charge density. E.g. the resulting partial charge density in the\nPARCHG\nfile will sum up to twice the value of the number of total bands\nNBANDS\n.\n\nNBMOD\n= -1: Use all occupied bands\n\nThis mode writes the charge density of all occupied states to the\nCHGCAR\nfile, and no\nPARCHG\nfile is produced. In contrast to producing a\nCHGCAR\nfile from the\nWAVECAR\ninput without the partial charges methodology (e.g. by setting\nLPARD\n= .FALSE.,\nALGO\n= None, and\nNELM\n= 1), the\naugmentation occupancies\nis not included in the produced\nCHGCAR\nfile for\nNBMOD\n= -1. However, the fine FFT grid's valence charge density is equivalent.\n\nNBMOD\n= -2: Use an absolute energy interval to select contributing bands\n\nThe partial charge density is calculated for electrons in the energy interval specified by\nEINT\n.\n\nNBMOD\n= -3: Use an energy interval to select contributing bands and add the Fermi energy\nϵ\nf\n{\\displaystyle \\epsilon_f}\nto the passed values\n\nThe partial charge density is calculated for electrons in the energy interval specified by\nEINT\n. In this mode, the values in\nEINT\nare interpreted as relative to the Fermi energy\nϵ\nf\n{\\displaystyle \\epsilon_f}\n. E.g. if\nEINT\n= -0.1 0.5 and\nϵ\nf\n{\\displaystyle \\epsilon_f}\n= 2.43, the chosen energy interval will range from 2.33 to 2.93 eV.",
    "related_tags": [
      "LPARD",
      "IBAND",
      "EINT",
      "KPUSE",
      "LSEPB",
      "LSEPK",
      "LPARDH5",
      "PARCHG",
      "vaspout.h5",
      "Band-decomposed charge densities"
    ]
  },
  "NBSEBLOCKO": {
    "default_value": "Default: NBSEBLOCKO = -1",
    "description": "NBSEBLOCKO specifies the blocking factor for the occupied states when setting up the BSE Hamiltonian.",
    "detailed_description": "By default, the construction of the BSE Hamiltonian in VASP is parallelized over\nk\n-points, such that each MPI rank can compute a pair of\nk\n-points. This way the BSE Hamiltonian setup can be parallelized with\n\ntotal ranks\n=\nN\nK\nP\nT\nS\n×\n(\nN\nK\nP\nT\nS\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NKPTS\\times(NKPTS+1)/2}}\n\nor for spin-polarized case\n\ntotal ranks\n=\nN\nK\nP\nT\nS\n×\n2\n×\n(\nN\nK\nP\nT\nS\n×\n2\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NKPTS\\times 2\\times(NKPTS\\times 2+1)/2}}\n,\n\nwhere\nN\nK\nP\nT\nS\n{\\displaystyle \\mathrm{NKPTS}}\nis the total number of\nk\n-points in the full Brillouin zone. However, if a large number of MPI ranks is used in a calculation with too few\nk\n-point, this leads to load imbalance, where some of the MPI ranks will have no data to compute. In such cases, it is recommended to use parallelization over bands. If the parallelization over bands is used, all occupied (unoccupied) bands are divided into\n\nN\nB\nL\nK\nO\n=\nN\nB\nA\nN\nD\nS\nO\n/\nN\nB\nS\nE\nB\nL\nO\nC\nK\nO\n{\\displaystyle \\mathrm{NBLKO=NBANDSO/NBSEBLOCKO}}\n\nand\n\nN\nB\nL\nK\nV\n=\nN\nB\nA\nN\nD\nS\nV\n/\nN\nB\nS\nE\nB\nL\nO\nC\nK\nV\n{\\displaystyle \\mathrm{NBLKV=NBANDSV/NBSEBLOCKV}}\n\nblocks, respectively.\n\nSuch a band blocking allows VASP to parallelize the setup of the matrix with\n\ntotal ranks\n=\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n×\n(\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NBLKO\\times NBLKV\\times NKPTS\\times (NBLKO\\times NBLKV\\times NKPTS+1)/2}}\n\nor for spin-polarized case\n\ntotal ranks\n=\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n×\n2\n×\n(\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n×\n2\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NBLKO\\times NBLKV\\times NKPTS\\times 2\\times (NBLKO\\times NBLKV\\times NKPTS\\times 2+1)/2}}\n\nIf neither\nN\nB\nS\nE\nB\nL\nO\nC\nK\nV\n{\\displaystyle \\mathrm{NBSEBLOCKV}}\nnor\nN\nB\nS\nE\nB\nL\nO\nC\nK\nO\n{\\displaystyle \\mathrm{NBSEBLOCKO}}\nis specified, no paralliziation over bands is used and\nN\nB\nL\nK\nO\n=\n1\n{\\displaystyle \\mathrm{NBLKO=1}}\nand\nN\nB\nL\nK\nV\n=\n1\n{\\displaystyle \\mathrm{NBLKV=1}}\n.\n\nMind:\nParallelization over bands with\nNBSEBLOCKV\ndoes not work with the old BSE driver, i.e.,\nIBSE\n=0\n\nWe recommend using parallelization over bands only if the number of MPI ranks in the calculation exceeds\ntotal ranks\n{\\displaystyle \\text{total ranks}}\n.\n\nMind:\nThe\nNBSEBLOCKV\nand\nNBSEBLOCKO\ntags are available as of VASP.6.5.0\n\nRelated tags and sections\n\nBSE\n,\nNBSEBLOCKV\n,\nBSE calculations\n,\nTDDFT calculations",
    "related_tags": []
  },
  "NBSEBLOCKV": {
    "default_value": "Default: NBSEBLOCKV = -1",
    "description": "NBSEBLOCKV specifies the blocking factor for the unoccupied states when setting up the BSE Hamiltonian.",
    "detailed_description": "By default, the construction of the BSE Hamiltonian in VASP is parallelized over\nk\n-points, such that each MPI rank can compute a pair of\nk\n-points. This way the BSE Hamiltonian setup can be parallelized with\n\ntotal ranks\n=\nN\nK\nP\nT\nS\n×\n(\nN\nK\nP\nT\nS\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NKPTS\\times(NKPTS+1)/2}}\n\nor for spin-polarized case\n\ntotal ranks\n=\nN\nK\nP\nT\nS\n×\n2\n×\n(\nN\nK\nP\nT\nS\n×\n2\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NKPTS\\times 2\\times(NKPTS\\times 2+1)/2}}\n,\n\nwhere\nN\nK\nP\nT\nS\n{\\displaystyle \\mathrm{NKPTS}}\nis the total number of\nk\n-points in the full Brillouin zone. However, if a large number of MPI ranks is used in a calculation with too few\nk\n-point, this leads to load imbalance, where some of the MPI ranks will have no data to compute. In such cases, it is recommended to use parallelization over bands. If the parallelization over bands is used, all occupied (unoccupied) bands are divided into\n\nN\nB\nL\nK\nO\n=\nN\nB\nA\nN\nD\nS\nO\n/\nN\nB\nS\nE\nB\nL\nO\nC\nK\nO\n{\\displaystyle \\mathrm{NBLKO=NBANDSO/NBSEBLOCKO}}\n\nand\n\nN\nB\nL\nK\nV\n=\nN\nB\nA\nN\nD\nS\nV\n/\nN\nB\nS\nE\nB\nL\nO\nC\nK\nV\n{\\displaystyle \\mathrm{NBLKV=NBANDSV/NBSEBLOCKV}}\n\nblocks, respectively.\n\nSuch a band blocking allows VASP to parallelize the setup of the matrix with\n\ntotal ranks\n=\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n×\n(\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NBLKO\\times NBLKV\\times NKPTS\\times (NBLKO\\times NBLKV\\times NKPTS+1)/2}}\n\nor for spin-polarized case\n\ntotal ranks\n=\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n×\n2\n×\n(\nN\nB\nL\nK\nO\n×\nN\nB\nL\nK\nV\n×\nN\nK\nP\nT\nS\n×\n2\n+\n1\n)\n/\n2\n{\\displaystyle \\text{total ranks}=\\mathrm{NBLKO\\times NBLKV\\times NKPTS\\times 2\\times (NBLKO\\times NBLKV\\times NKPTS\\times 2+1)/2}}\n\nIf neither\nN\nB\nS\nE\nB\nL\nO\nC\nK\nV\n{\\displaystyle \\mathrm{NBSEBLOCKV}}\nnor\nN\nB\nS\nE\nB\nL\nO\nC\nK\nO\n{\\displaystyle \\mathrm{NBSEBLOCKO}}\nis specified, no paralliziation over bands is used and\nN\nB\nL\nK\nO\n=\n1\n{\\displaystyle \\mathrm{NBLKO=1}}\nand\nN\nB\nL\nK\nV\n=\n1\n{\\displaystyle \\mathrm{NBLKV=1}}\n.\n\nMind:\nParallelization over bands with\nNBSEBLOCKV\ndoes not work with the old BSE driver, i.e.,\nIBSE\n=0\n\nWe recommend using parallelization over bands only if the number of MPI ranks in the calculation exceeds\ntotal ranks\n{\\displaystyle \\text{total ranks}}\n.\n\nMind:\nThe\nNBSEBLOCKV\nand\nNBSEBLOCKO\ntags are available as of VASP.6.5.0\n\nRelated tags and sections\n\nBSE\n,\nNBSEBLOCKO\n,\nBSE calculations\n,\nTDDFT calculations",
    "related_tags": []
  },
  "NBSEEIG": {
    "default_value": "NBSEEIG = 0",
    "description": "NBSEEIG sets the number of BSE eigenvectors written to the BSEFATBAND file. If BSEHOLE or BSEELECTRON is set, NBSEEIG exciton wavefunctions are written to the CHG .XX files.",
    "detailed_description": "Related tags and sections\n\nBSE\n,\nBSEFATBAND\n,\nBSE calculations\n\nExamples that use this tag",
    "related_tags": []
  },
  "NCORE": {
    "default_value": "NCORE = 1",
    "description": "NCORE determines the number of compute cores that work on an individual orbital (available as of VASP.5.2.13).",
    "detailed_description": "VASP currently offers parallelization and data distribution over bands and/or over plane wave coefficients, and as of VASP.5.3.2, parallelization over\nk\n-points (no data distribution, see\nKPAR\n).\nTo achieve high efficiency on massively parallel systems or modern multi-core machines, it is strongly recommended to use all parallelization options available. Most algorithms work with any data distribution (except for the single band conjugated gradient, which is obsolete).\n\nNCORE\nis available from VASP.5.2.13 on, and is more handy than the previous parameter\nNPAR\n. The user should either specify\nNCORE\nor\nNPAR\n, where\nNPAR\ntakes a higher preference. The relation between both parameters is\n\nNCORE =number-of-cores /KPAR / NPAR\n\nNCORE\ndetermines how many cores share the work on an individual orbital. The current default is\nNCORE\n=1, meaning that one orbital is treated by one core.\nNPAR\nis then set to the total number of cores (divided by KPAR). If\nNCORE\nequals the total number of cores,\nNPAR\nis set to 1. This implies data distribution over plane wave coefficients only: all cores will work together on every individual band, i.e., the plane wave coefficients of each band are distributed over all cores. This is usually very slow and should be avoided.\n\nNCORE\n=1 is the optimal setting for small unit cells, and platforms with a small communication bandwidth. It is also a good choice for up to 8 cores. However, this mode substantially increases the memory requirements, because the non-local projector functions must be stored entirely on each core. In addition, substantial all-to-all communications are required to orthogonalize the bands.\n\nOn massively parallel systems and modern multi-core machines we strongly recommend to set\n\nNCORE = 2 up to number-of-cores-per-socket (or number-of-cores-per-node)\n\nFor large unit cells, we found that this can improve the performance by up to a factor four compared to the default, and it also significantly improves the stability of the code due to reduced memory requirements. Ideally,\nNCORE\nshould be a factor of the number-of-cores-per-socket (or number-of-cores-per-node), since this reduces communication between the sockets or nodes. The best value\nNCORE\ndepends somewhat on the number of atoms in the unit cell. Values around 4 are usually ideal for 100 atoms in the unit cell. For very large unit cells (more than 400 atoms) values around 12-16 are often optimal. If you run extensive simulations for similar systems, make your own tests.\n\nFinally, the optimal settings for\nNCORE\nand\nLPLANE\ndepend strongly on the type of machine you are using.\nSome recommended setups:\n\nLINUX cluster linked by Infiniband, modern multicore machines:\n\nOn a LINUX cluster with multicore machines linked by a fast network we recommend to set\n\nLPLANE = .TRUE.\nNCORE  = 2 up to number-of-cores-per-node\nLSCALU = .FALSE.\nNSIM   = 4\n\nIf very many nodes are used, it might be necessary to set LPLANE = .FALSE., but usually this offers only a very modest performance boost (if at all).\n\nLINUX cluster linked by 1 Gbit Ethernet, and LINUX clusters with single cores:\n\nOn a LINUX cluster linked by a relatively slow network, LPLANE must be set to .TRUE., and the NCORE should be equal to 1:\n\nLPLANE = .TRUE.\nNCORE  = 1\nLSCALU = .FALSE.\nNSIM   = 4\n\nMind that you need at least a 100 Mbit full duplex network, with a fast switch offering at least 2 Gbit switch capacity to find useful speedups. Multi-core machines should be always linked by an Infiniband, since Gbit is too slow for multi-core machines.\n\nMassively parallel machines with dedicated network (maybe Cray):\n\nOn massively parallel machines one is sometimes forced to use a large number of cores. In this case load balancing problems and problems with the communication bandwidth are likely to be experienced. In addition the local memory is fairly small on some massively parallel machines (too small keep the real space projectors in the cache using any reasonable VASP setting). Therefore, we recommend to set\nNCORE\non these machines to √\n# of cores\n(explicit timing can be helpful to find the optimum value). The use of\nLPLANE\n=.TRUE. is only recommended if the number of nodes is significantly smaller than\nNGX\n,\nNGY\nand\nNGZ\n.\n\nIn summary, the following setting is recommended\n\nLPLANE = .FALSE.\nNPAR   = sqrt(number of cores)\nNSIM   = 1",
    "related_tags": [
      "NPAR",
      "LPLANE",
      "LSCALU",
      "NSIM",
      "KPAR",
      "LSCALAPACK",
      "LSCAAWARE",
      "OpenACC GPU Port of VASP",
      "Combining MPI and OpenMP"
    ]
  },
  "NCORE_IN_IMAGE1": {
    "default_value": "NCORE_IN_IMAGE1 = 0",
    "description": "This tag specifies the number of cores in the first image.",
    "detailed_description": "This tag works for two images, specifically, if\nVCAIMAGES\nis set (this also sets\nIMAGES\n=2).\nVCAIMAGES\nsplits the available cores into two groups both working independently in the subdirectories\n01 and 02.\nThe tag\nNCORE_IN_IMAGE1\ndefines how many of cores are used for the first image (01). The remainder of the cores is used for the second image (working in the subdirectory 02).",
    "related_tags": [
      "VCAIMAGES",
      "IMAGES",
      "SCALEE"
    ]
  },
  "NCRPA_BANDS": {
    "default_value": "",
    "description": "Controls which bands are excluded in the constrained random phase approximation. Check also NTARGET_STATES .",
    "detailed_description": "This tag is effective for\nALGO\n=CRPA and ignored otherwise.\n\nFor instance\n\nNCRPA_BANDS = 21 22 23\n\nremoves all screening effects between bands 21, 22 and 23 in the random phase approximation of the screened Coulomb interaction.\n\nRelated tags and articles\n\nALGO\n,\nNTARGET_STATES\n\nExamples that use this tag",
    "related_tags": []
  },
  "NEDOS": {
    "default_value": "NEDOS = 301 {\\displaystyle 301}",
    "description": "Number of grid points for the electronic density of states (DOS) and dielectric function .",
    "detailed_description": "The energy range between\nEMIN\nand\nEMAX\nis divided into\nNEDOS\nintervals to obtain the grid points. The DOS for the corresponding energy is written in the\nDOSCAR\nfile.\n\nTip:\nCompare the DOS to the integrated DOS (also written on\nDOSCAR\n) to check if the default\nNEDOS\nis too small to resolve narrow peaks properly. At least one peak should show up at every step of the integrated DOS.\n\nThe smallest peak widths from the dispersion of the respective bands can be estimated by having a look at the Kohn-Sham eigenvalues written in\nOUTCAR\n.\nNEDOS\nhas to be chosen sufficiently large to resolve this dispersion. In addition, the\nenergy interval defined by\nEMIN\nand\nEMAX\ncan be modified.\n\nNEDOS\nis also used to set the total number of frequency points when calculating the\ndielectric function\n.",
    "related_tags": [
      "EMIN",
      "EMAX",
      "DOSCAR"
    ]
  },
  "NELECT": {
    "default_value": "NELECT = number of valence electrons",
    "description": "NELECT sets the number of electrons.",
    "detailed_description": "Warning:\nUnless you would like to perform a charged calculation, you should not set this line.\n\nThe number of electrons is determined automatically from the\nPOTCAR\n(ZVAL of the element) and\nPOSCAR\nfile (number of the atoms of the respective atom type) assuming the cell is charge-neutral.\nIf the number of electrons is not compatible with the number derived from the valence and the number of atoms a homogeneous background charge is assumed.\nIf the number of ions specified in the\nPOSCAR\nfile is 0 and\nNELECT\n=n, then the energy of a homogeneous electron gas is calculated.\n\nCharged calculations\n\nWarning:\nUsing the\nNELECT\ntag without the use of an appropriate correction leads to a very slow convergence of energies with respect to the size\nL\nof the supercell.\n\nThe required first-order correction to the energy caused by an excess charge is given by\n\ne\n2\nq\n2\nα\nL\nϵ\n{\\displaystyle \\frac{e^2q^2\\alpha}{L\\epsilon}}\n\nwhere\nq\nis the net charge of the system, α\nthe Madelung constant of a point charge\nq\nplaced in a homogeneous background charge\n-q\n, and ε \nthe dielectric constant of the system.\nFor atoms or molecules surrounded by vacuum, ε takes on the vacuum value ε=1.\nVASP can automatically correct this leading error, see\nElectrostatic corrections\nfor further information.\nIt is important to emphasize that the total energy cannot be corrected for charged slabs, since a charged slab results in an electrostatic potential that grows with the distance from the slab.\nThis non-convergence of the potential is a result of the interaction between the charged slab and the compensating background.\nA practical consequence of this non-convergence is that the total energy depends linearly on the width of the vacuum.\n\nWarning:\nPresently, no simple\na posteriori\ncorrection scheme is implemented in VASP for slab calculations. Total energies from charged slab calculations must be used with care. In certain cases, relative energies between two charged surface calculations may be useful",
    "related_tags": [
      "Monopole Dipole and Quadrupole corrections",
      "EPSILON",
      "DIPOL",
      "IDIPOL",
      "LMONO",
      "LDIPOL",
      "EFIELD"
    ]
  },
  "NELM": {
    "default_value": "NELM = 60",
    "description": "NELM sets the maximum number of electronic SC (self-consistency) steps.",
    "detailed_description": "Normally, there is no need to change the default value: if the self-consistency loop does not converge within 40 steps, it will probably not converge at all. In this case you should reconsider the tags\nIALGO\nor\nALGO\n,\nLSUBROT\n, and the\nmixing parameters\n.\n\nThe same stands for\nALGO\n= TIMEEV, as the value is set to be sufficient to ensure numerical stability when propagating in time. If you wish to set it by yourself, be advised that the input value must be greater than 100, otherwise VASP will ignore it and fall to the default settings.",
    "related_tags": [
      "NELMDL",
      "NELMIN"
    ]
  },
  "NELMDL": {
    "default_value": "Default: NELMDL = -12 if ISTART =0, INIWAV =1, and IALGO =48 or IALGO =50 | = 0 if WAVECAR is present | = -5 else",
    "description": "NELMDL specifies the number of non-self-consistent steps at the beginning.",
    "detailed_description": "If the orbitals are initialized using a random number generator (the default in VASP),  the initial orbitals are usually unreasonable and the iterative matrix diagonalization will require 5-10 steps to obtain reasonable orbitals. The charge density corresponding to the initial orbitals is also, at best, erratic. It is hence advisable to perform a few electronic steps while keeping the initial Hamiltonian fixed. This initial Hamiltonian is usually determined from a superposition of atomic charge densities (see\nICHARG\n).\n\nSuch a 'delay' is absolutely necessary if the SCF-convergence is slow and problematic (e.g. for surfaces or metallic clusters, low dimensional system). Without a delay, VASP will most likely not converge, or at least the convergence speed is slowed significantly.\n\nNELMDL\nmight be set to a positive or negative value. A negative value means that the delay is only performed in the first ionic step (usually the recommended option). A positive number means that a delay is employed after each ionic movement. This can improve the convergence speed in VASP.6 (see below) but is not recommended in VASP.5.\n\nFor calculations using a direct minimization of the Hamiltonian (\nALGO\n=ALL  or\nALGO\n=DAMPED), the Davidson algorithm is used during the delay phase and the Hamiltonian is kept fixed during these steps.\n\nSpecial considerations for VASP.6:\n\nFor calculations using a direct minimization of the Hamiltonian (\nALGO\n=ALL or\nALGO\n=DAMPED): if\nNELMDL\nis set, the Davidson algorithm is used in the first\nNELMDL\nsteps as described above. Using a positive\nNELMDL\n(i.e. delay in every ionic step) does not work reliably in VASP.5, due to issues in the orbital and charge density prediction. In VASP.6, using\nNELMDL\n=1 (or\nNELMDL\n=2) and direct minimization often improves the stability and efficiency of molecular dynamics simulations or relaxations (\nALGO\n=ALL or\nALGO\n=DAMPED). Note, however, that this might require one to prepare a reasonable\nWAVECAR\nfile since\nNELMDL\n=1/2 might not suffice to obtain a reasonable set of orbitals from the initial random numbers.\n\nFor HF-type calculations, if\nNELMDL\nis larger or equal to 3, VASP will perform\nNELMDL\nnon-selfconsistent steps using the Davidson algorithm, and a local Hamiltonian is calculated using the semi-local DFT functional corresponding to the chosen hybrid functional (i.e. PBE for HSE and PBE0). This is expedient if the ions move by a large distance between the ionic steps. Setting\nNELMDL\n=3 can thus improve the stability and performance during relaxations using HF-type Hamiltonians. Try to use\nALGO\n=All and\nNELMDL\n=3 if you encounter convergence issues during relaxations using HF-type Hamiltonians.",
    "related_tags": [
      "NELM",
      "NELMIN",
      "IALGO"
    ]
  },
  "NELMGW": {
    "default_value": "NELMGW = 1",
    "description": "NELMGW sets the number of self-consistent GW steps. Available as of 6.3.0.",
    "detailed_description": "This tag is effective for\nALGO\n=EVGW[0] | QPGW[0] | GW[0][R][K] and ignored otherwise.\nFor instance\n\nALGO\n= EVGW0\nNELMGW\n= 4\n\nperforms a\npartially self-consistent GW calculations\n, where\nG\n{\\displaystyle G}\nis updated four times.\n\nOmit\nNBANDS\nand\nNELM\nto select the\nsingle-step GW procedure\n.",
    "related_tags": [
      "ALGO",
      "GW calculations"
    ]
  },
  "NELMIN": {
    "default_value": "NELMIN = 2",
    "description": "NELMIN specifies the minimum number of electronic self-consistency steps.",
    "detailed_description": "It is rarely necessary to change the value of the\nNELMIN\ntag. In some cases, e.g., in\nmolecular-dynamics\nruns, or\nionic-minimization\nmethods, we recommend increasing the\nNELMIN\ntag to a value between 4 and 8.",
    "related_tags": [
      "NELM",
      "NELMDL"
    ]
  },
  "NFREE": {
    "default_value": "Default: NFREE = 1 if IBRION =2 | = 0 else",
    "description": "depending on IBRION , NFREE specifies the number of remembered steps in the history of ionic convergence runs, or the number of ionic displacements in frozen phonon calculations.",
    "detailed_description": "IBRION\n=1 (quasi-Newton algorithm for ionic relaxation):\n\n(i) If\nNFREE\nis set, only up to\nNFREE\nionic steps are kept in the iteration history (the rank of the approximate Hessian matrix is not larger than\nNFREE\n).\n\n(ii) If\nNFREE\nis\nnot\nspecified, the criterion whether information is removed from the iteration history is based on the eigenvalue spectrum of the inverse Hessian matrix: if one eigenvalue of the inverse Hessian matrix is larger than 8, information from previous steps is discarded.\nFor complex problems\nNFREE\ncan usually be set to a rather large value (i.e. 10-20), however systems of low dimensionality require a careful setting of\nNFREE\n(or preferably an exact  counting of the number of degrees of freedom). To increase\nNFREE\nbeyond 20 rarely improves convergence. If\nNFREE\nis set to too large, the RMM-DIIS algorithm might diverge.\n\nIBRION\n=5 (from VASP.4.5) or\nIBRION\n=6 (from VASP.5.1): frozen phonon approach to calculate the zone-center vibrational frequencies of a system.\n\nNFREE\ndetermines how many displacements are used for each direction and ion. The step size has to be given in\nINCAR\n, by the tag\nPOTIM\n.  Displacements should be small enough to ensure that the harmonic approximation is safely fulfilled.   If too large values are supplied in the input file, it is defaulted to 0.015 Å up from VASP.5.1 (but\nnot\nin all earlier releases). Expertise shows that this is a very reasonable compromise.\n\nNFREE\n= 2 uses central difference,\ni.e\neach ion is displaced in each direction by a small positive and negative displacement\n\n±\n{\\displaystyle \\pm}\nPOTIM\n*\nx\n^\n{\\displaystyle \\hat{x}  }\n,\n\n±\n{\\displaystyle \\pm}\nPOTIM\n*\ny\n^\n{\\displaystyle \\hat{y}  }\n,\n\n±\n{\\displaystyle \\pm}\nPOTIM\n*\nz\n^\n{\\displaystyle \\hat{z}  }\n,\n\nFor\nNFREE\n= 4, four displacements are used\n\n±\n{\\displaystyle \\pm}\nPOTIM\n*\nx\n^\n{\\displaystyle \\hat{x}  }\nand\n±\n{\\displaystyle \\pm}\n2 *\nPOTIM\n*\nx\n^\n{\\displaystyle \\hat{x}}\n,\n\n±\n{\\displaystyle \\pm}\nPOTIM\n*\ny\n^\n{\\displaystyle \\hat{y}  }\nand\n±\n{\\displaystyle \\pm}\n2 *\nPOTIM\n*\nx\n^\n{\\displaystyle \\hat{x}}\n,\n\n±\n{\\displaystyle \\pm}\nPOTIM\n*\nz\n^\n{\\displaystyle \\hat{z}  }\nand\n±\n{\\displaystyle \\pm}\n2 *\nPOTIM\n*\nx\n^\n{\\displaystyle \\hat{x}}\n,\n\nFor\nNFREE\n=1, only a single displacement is applied (it is strongly recommend to avoid\nNFREE\n=1).",
    "related_tags": [
      "IBRION",
      "POTIM"
    ]
  },
  "NGX": {
    "default_value": "NGX = set in accordance with PREC and ENCUT",
    "description": "NGX sets the number of grid points in the FFT grid along the first lattice vector.",
    "detailed_description": "By default\nNGX\nis set in accordance with the requested \"precision\" mode\nPREC\nand the plane wave kinetic energy cutoff\nENCUT\n:\n\nPREC\nNGX\nNormal\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingle (VASP.5)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingle (VASP.6)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingleN (VASP.6)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nAccurate\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nLow\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nMedium\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nHigh\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n\nwhere\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2}\n\nwith\nE\nc\nu\nt\n{\\displaystyle E_{\\rm cut}}\n=\nENCUT\n.\n\nAlternatively,\nNGX\ncan be set to a specific value in the\nINCAR\nfile.",
    "related_tags": [
      "NGY",
      "NGZ",
      "NGXF",
      "NGYF",
      "NGZF",
      "PREC",
      "ENCUT",
      "ENAUG"
    ]
  },
  "NGXF": {
    "default_value": "NGXF = set in accordance with PREC , NGX , ENCUT and ENAUG",
    "description": "NGXF sets the number of grid points in the \"fine\" FFT grid along the first lattice vector.",
    "detailed_description": "On this \"fine\" FFT mesh the localized augmentation charges are represented if ultrasoft pseudopotentials (USPPs) or the PAW method are used. In case USPPs are used, the local potentials (exchange-correlation, Hartree-potential and ionic potentials) are also calculated on this \"fine\" FFT-mesh.\n\nBy default\nNGXF\nis set in accordance with the requested \"precision\" mode\nPREC\n,\nNGX\n, and the plane wave kinetic energy cutoffs\nENCUT\nand\nENAUG\n:\n\nPREC\nNGX\nNGXF\nNormal\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGX\nSingle (VASP.5)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGX\nSingle (VASP.6)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGX\nSingleN (VASP.6)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGX\nAccurate\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGX\nLow\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\nMedium\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n4×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\nHigh\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n16/3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\n\nwhere\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\nE\na\nu\ng\n=\nℏ\n2\n2\nm\ne\nG\na\nu\ng\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2 \\qquad E_{\\rm aug}=\\frac{\\hbar^2}{2m_e}G_{\\rm aug}^2}\n\nwith\nE\nc\nu\nt\n{\\displaystyle E_{\\rm cut}}\n=\nENCUT\nand\nE\na\nu\ng\n{\\displaystyle E_{\\rm aug}}\n=\nENAUG\n.\n\nAlternatively,\nNGXF\ncan be set to a specific value in the\nINCAR\nfile.",
    "related_tags": [
      "NGX",
      "NGY",
      "NGZ",
      "NGYF",
      "NGZF",
      "PREC",
      "ENCUT",
      "ENAUG"
    ]
  },
  "NGY": {
    "default_value": "NGY = set in accordance with PREC and ENCUT",
    "description": "NGY sets the number of grid points in the FFT grid along the second lattice vector.",
    "detailed_description": "By default\nNGY\nis set in accordance with the requested \"precision\" mode\nPREC\nand the plane wave kinetic energy cutoff\nENCUT\n:\n\nPREC\nNGY\nNormal\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingle (VASP.5)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingle (VASP.6)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingleN (VASP.6)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nAccurate\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nLow\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nMedium\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nHigh\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n\nwhere\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2}\n\nwith\nE\nc\nu\nt\n{\\displaystyle E_{\\rm cut}}\n=\nENCUT\n.\n\nAlternatively,\nNGY\ncan be set to a specific value in the\nINCAR\nfile.",
    "related_tags": [
      "NGX",
      "NGZ",
      "NGXF",
      "NGYF",
      "NGZF",
      "PREC",
      "ENCUT",
      "ENAUG"
    ]
  },
  "NGYF": {
    "default_value": "NGYF = set in accordance with PREC , NGY , ENCUT and ENAUG",
    "description": "NGYF sets the number of grid points in the \"fine\" FFT grid along the second lattice vector.",
    "detailed_description": "On this \"fine\" FFT mesh the localized augmentation charges are represented if ultrasoft pseudopotentials (USPPs) or the PAW method are used. In case USPPs are used, the local potentials (exchange-correlation, Hartree-potential and ionic potentials) are also calculated on this \"fine\" FFT-mesh.\n\nBy default\nNGYF\nis set in accordance with the requested \"precision\" mode\nPREC\n,\nNGY\n, and the plane wave kinetic energy cutoffs\nENCUT\nand\nENAUG\n:\n\nPREC\nNGY\nNGYF\nNormal\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGY\nSingle (VASP.5)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGY\nSingle (VASP.6)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGY\nSingleN (VASP.6)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGY\nAccurate\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGY\nLow\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\nMedium\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n4×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\nHigh\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n16/3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\n\nwhere\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\nE\na\nu\ng\n=\nℏ\n2\n2\nm\ne\nG\na\nu\ng\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2 \\qquad E_{\\rm aug}=\\frac{\\hbar^2}{2m_e}G_{\\rm aug}^2}\n\nwith\nE\nc\nu\nt\n{\\displaystyle E_{\\rm cut}}\n=\nENCUT\nand\nE\na\nu\ng\n{\\displaystyle E_{\\rm aug}}\n=\nENAUG\n.\n\nAlternatively,\nNGYF\ncan be set to a specific value in the\nINCAR\nfile.",
    "related_tags": [
      "NGX",
      "NGY",
      "NGZ",
      "NGXF",
      "NGZF",
      "PREC",
      "ENCUT",
      "ENAUG"
    ]
  },
  "NGYROMAG": {
    "default_value": "NGYROMAG = NTYP*1.0",
    "description": "NGYROMAG specifies the nuclear gyromagnetic ratios (in MHz, for H 0 = 1 T) for the atomic types on the POTCAR file.",
    "detailed_description": "By means of the\nNGYROMAG\n-tag one can specify the nuclear gyromagnetic ratio:\n\nNGYROMAG = gamma_1  gamma_2 ... gamma_N\n\nwhere one should specify one number for each of the\nN\nspecies on the\nPOSCAR\nfile, i.e. if C, H, N, and O are listed as species in the\nPOSCAR\nfile, then there should be four numbers in\nNGYROMAG\n, regardless of how many total atoms there are.\n\nImportant:\nIf one does not set\nNGYROMAG\nin the\nINCAR\nfile, VASP assumes a factor of 1 for each species.\n\nNGYROMAG\nis given in units of MHz/T, see Ref.\n[1]\nfor a table of different gyromagnetic ratios. A more extensive list is available on\n[2]\nwhich converts isotopic magnetic moments from Ref.\n[3]\nand converts them using the definition of the gyromagnetic ratio defined in Ref.\n[4]\n.",
    "related_tags": [
      "LHYPERFINE",
      "Calculating the hyperfine coupling constant",
      "↑",
      "Gyromagnetic ratio, www.wikipedia.org (2025)",
      "Konstantin's gyromagnetic ratio table, https://www.kherb.io (2025)",
      "N. J. Stone, TABLE OF RECOMMENDED NUCLEAR MAGNETIC DIPOLE MOMENTS: PART I, LONG-LIVED STATES , (2019), p.13-43.",
      "E. Tiesinga, P. Mohr, P. Newell, B. Taylor, CODATA recommended values of the fundamental physical constants: 2018* , Rev. Mod. Phys. 93 , 025010 (2021)."
    ]
  },
  "NGZ": {
    "default_value": "NGZ = set in accordance with PREC and ENCUT",
    "description": "NGZ sets the number of grid points in the FFT grid along the third lattice vector.",
    "detailed_description": "By default\nNGZ\nis set in accordance with the requested \"precision\" mode\nPREC\nand the plane wave kinetic energy cutoff\nENCUT\n:\n\nPREC\nNGZ\nNormal\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingle (VASP.5)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingle (VASP.6)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nSingleN (VASP.6)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nAccurate\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nLow\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nMedium\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nHigh\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n\nwhere\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2}\n\nwith\nE\nc\nu\nt\n{\\displaystyle E_{\\rm cut}}\n=\nENCUT\n.\n\nAlternatively,\nNGZ\ncan be set to a specific value in the\nINCAR\nfile.",
    "related_tags": [
      "NGX",
      "NGY",
      "NGXF",
      "NGYF",
      "NGZF",
      "PREC",
      "ENCUT",
      "ENAUG"
    ]
  },
  "NGZF": {
    "default_value": "NGZF = set in accordance with PREC , NGZ , ENCUT and ENAUG",
    "description": "NGZF sets the number of grid points in the \"fine\" FFT grid along the first lattice vector.",
    "detailed_description": "On this \"fine\" FFT mesh the localized augmentation charges are represented if ultrasoft pseudopotentials (USPPs) or the PAW method are used. In case USPPs are used, the local potentials (exchange-correlation, Hartree-potential, and ionic potentials) are also calculated on this \"fine\" FFT-mesh.\n\nBy default\nNGZF\nis set in accordance with the requested \"precision\" mode\nPREC\n,\nNGZ\n, and the plane wave kinetic energy cutoffs\nENCUT\nand\nENAUG\n:\n\nPREC\nNGZ\nNGZF\nNormal\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGZ\nSingle (VASP.5)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGZ\nSingle (VASP.6)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGZ\nSingleN (VASP.6)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGZ\nAccurate\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGZ\nLow\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\nMedium\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n4×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\nHigh\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n16/3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\n\nwhere\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\nE\na\nu\ng\n=\nℏ\n2\n2\nm\ne\nG\na\nu\ng\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2 \\qquad E_{\\rm aug}=\\frac{\\hbar^2}{2m_e}G_{\\rm aug}^2}\n\nwith\nE\nc\nu\nt\n{\\displaystyle E_{\\rm cut}}\n=\nENCUT\nand\nE\na\nu\ng\n{\\displaystyle E_{\\rm aug}}\n=\nENAUG\n.\n\nAlternatively,\nNGZF\ncan be set to a specific value in the\nINCAR\nfile.",
    "related_tags": [
      "NGX",
      "NGY",
      "NGZ",
      "NGXF",
      "NGYF",
      "PREC",
      "ENCUT",
      "ENAUG"
    ]
  },
  "NHC_NCHAINS": {
    "default_value": "NHC_NCHAINS = 0",
    "description": "Length of the Nosé-Hoover chain.",
    "detailed_description": "NHC_NCHAINS\nsets the length of the chain for the\nNosé-Hoover–chain (NHC) thermostat\n. Typically, this tag is set to a value between 1 and 5. The maximal allowed value is 20.\n\nIn case\nNHC_NCHAINS\n=0, the thermostat is switched off and the underlying dynamics generate a\nmicrocanonical (NVE) ensemble\n.\nNHC_NCHAINS\n=1 corresponds to the\nstandard Nosé-Hoover thermostat\n.",
    "related_tags": [
      "NHC_PERIOD",
      "NHC thermostat"
    ]
  },
  "NHC_NRESPA": {
    "default_value": "NHC_NRESPA = 1",
    "description": "The number of subdivisions of the integration step used in propagation of thermostat variables in Nosé-Hoover–chain (NHC) thermostat .",
    "detailed_description": "NHC_NRESPA\nsets the number of subdivisions of the integration step used in propagation of thermostat variables in\nNosé-Hoover–chain (NHC) thermostat\n. This might be needed in accurate calculations where, due to rapidly varying terms appearing in thermostat variables propagators could cause significant drifts of total energy (including energy contributions due to thermostat), which is a conserved quantity.",
    "related_tags": [
      "NHC_PERIOD",
      "NHC_NS",
      "NHC thermostat"
    ]
  },
  "NHC_NS": {
    "default_value": "NHC_NS = 1",
    "description": "The number of subdivisions of each RESPA step used in the integration step used in propagation of thermostat variables in Nosé-Hoover–chain (NHC) thermostat .",
    "detailed_description": "The RESPA steps used in in propagation of thermostat variables in\nNosé-Hoover–chain (NHC) thermostat\nare treated by Suzuki-Yoshida scheme\n[1]\n[2]\n, whereby each step is subdivided further into\nNHC_NS\nparts. First, fourth, and sixth order schemes with, 1, 3, and 7 steps, respectively, are supported.",
    "related_tags": [
      "NHC_PERIOD",
      "NHC_NRESPA",
      "NHC thermostat",
      "↑",
      "M. Suzuki, J. Math. Phys. 26, 601 (1985).",
      "H. Yoshida, Phys. Lett. A 150, 262 (1990)."
    ]
  },
  "NICS": {
    "default_value": "",
    "description": "",
    "detailed_description": "",
    "related_tags": [
      "LCHIMAG",
      "NUCIND",
      "LNICSALL"
    ]
  },
  "NKRED": {
    "default_value": "NKRED = 1",
    "description": "NKRED specifies an uniform reduction factor for the q -point grid representation of the exact exchange potential and the correlation part in GW calculations.",
    "detailed_description": "One may restrict the sum over\nq\nin the\nFock exchange potential\n(or one of its short range counterparts) to a subset, {\nq\nk\n}, of the full (\nN\n1\n×\nN\n2\n×\nN\n3\n)\nk\n-point set, {\nk\n}, for which the following holds\n\nq\nk\n=\nb\n1\nn\n1\nC\n1\nN\n1\n+\nb\n2\nn\n2\nC\n2\nN\n2\n+\nb\n3\nn\n3\nC\n3\nN\n3\n,\n(\nn\ni\n=\n0\n,\n.\n.\n,\nN\ni\n−\n1\n)\n{\\displaystyle \n\\mathbf{q_k} = \\mathbf{b}_1 \\frac{n_1 C_1}{N_1} + \\mathbf{b}_2 \\frac{n_2 C_2}{N_2}\n+ \\mathbf{b}_3 \\frac{n_3 C_3}{N_3},\\quad(n_i=0,..,N_i-1)\n}\n\nwhere\nb\n1,2,3\nare the reciprocal lattice vectors of the primitive cell,\nand\nC\ni\nis the integer grid reduction factor along reciprocal lattice direction\nb\ni\n. This leads to a reduction in the computational workload by a factor:\n\n1\nC\n1\nC\n2\nC\n3\n{\\displaystyle \n\\frac{1}{C_1 C_2 C_3}\n}\n\nIn case one sets\nNKRED\n, the grid reduction factors will be uniformly set to\nC\n1\n=\nC\n2\n=\nC\n3\n=\nNKRED\n. If one wants to specify separate grid reduction factors for\nC\n1\n,\nC\n2\n, and\nC\n3\none should use\nC\n1\n=\nNKREDX\n,\nC\n2\n=\nNKREDY\n, and\nC\n3\n=\nNKREDZ\n, respectively.\n\nThis flag also applies to GW and RPA calculations with a similar speedup. In GW and RPA type calculations,\nanalogously to hybrid functional calculations the outermost loop over the momentum transfer\nq\nis reduced to a subgrid specified by the\nNKRED\nparameters.\n\nWarning:\nthere are circumstances under which\nNKRED\nand\nNKREDX\n,\nY\n,\nZ\nshould not be used!",
    "related_tags": [
      "NKREDX",
      "NKREDY",
      "NKREDZ",
      "EVENONLY",
      "ODDONLY",
      "downsampling"
    ]
  },
  "NKREDX": {
    "default_value": "NKREDX = 1",
    "description": "NKREDX specifies a reduction factor for the q -point grid representation of the exact exchange potential along reciprocal space direction b 1 .",
    "detailed_description": "One may restrict the sum over\nq\nin the\nFock exchange potential\n(or one of its short range counterparts) to a subset, {\nq\nk\n}, of the full (\nN\n1\n×\nN\n2\n×\nN\n3\n)\nk\n-point set, {\nk\n}, for which the following holds\n\nq\nk\n=\nb\n1\nn\n1\nC\n1\nN\n1\n+\nb\n2\nn\n2\nC\n2\nN\n2\n+\nb\n3\nn\n3\nC\n3\nN\n3\n,\n(\nn\ni\n=\n0\n,\n.\n.\n,\nN\ni\n−\n1\n)\n{\\displaystyle \n\\mathbf{q_k} = \\mathbf{b}_1 \\frac{n_1 C_1}{N_1} + \\mathbf{b}_2 \\frac{n_2 C_2}{N_2}\n+ \\mathbf{b}_3 \\frac{n_3 C_3}{N_3},\\quad(n_i=0,..,N_i-1)\n}\n\nwhere\nb\n1,2,3\nare the reciprocal lattice vectors of the primitive cell,\nand\nC\ni\nis the integer grid reduction factor along reciprocal lattice direction\nb\ni\n. This leads to a reduction in the computational workload by a factor:\n\n1\nC\n1\nC\n2\nC\n3\n{\\displaystyle \n\\frac{1}{C_1 C_2 C_3}\n}\n\nIn case one sets\nNKRED\n, the grid reduction factors will be uniformly set to\nC\n1\n=\nC\n2\n=\nC\n3\n=\nNKRED\n. If one wants to specify separate grid reduction factors for\nC\n1\n,\nC\n2\n, and\nC\n3\none should use\nC\n1\n=\nNKREDX\n,\nC\n2\n=\nNKREDY\n, and\nC\n3\n=\nNKREDZ\n, respectively.\n\nWarning:\nthere are circumstances under which\nNKRED\nand\nNKREDX\n,\nY\n,\nZ\nshould not be used!",
    "related_tags": [
      "NKRED",
      "NKREDY",
      "NKREDZ",
      "EVENONLY",
      "ODDONLY",
      "downsampling"
    ]
  },
  "NKREDY": {
    "default_value": "NKREDY = 1",
    "description": "NKREDY specifies a reduction factor for the q -point grid representation of the exact exchange potential along reciprocal space direction b 2 .",
    "detailed_description": "One may restrict the sum over\nq\nin the\nFock exchange potential\n(or one of its short range counterparts) to a subset, {\nq\nk\n}, of the full (\nN\n1\n×\nN\n2\n×\nN\n3\n)\nk\n-point set, {\nk\n}, for which the following holds\n\nq\nk\n=\nb\n1\nn\n1\nC\n1\nN\n1\n+\nb\n2\nn\n2\nC\n2\nN\n2\n+\nb\n3\nn\n3\nC\n3\nN\n3\n,\n(\nn\ni\n=\n0\n,\n.\n.\n,\nN\ni\n−\n1\n)\n{\\displaystyle \n\\mathbf{q_k} = \\mathbf{b}_1 \\frac{n_1 C_1}{N_1} + \\mathbf{b}_2 \\frac{n_2 C_2}{N_2}\n+ \\mathbf{b}_3 \\frac{n_3 C_3}{N_3},\\quad(n_i=0,..,N_i-1)\n}\n\nwhere\nb\n1,2,3\nare the reciprocal lattice vectors of the primitive cell,\nand\nC\ni\nis the integer grid reduction factor along reciprocal lattice direction\nb\ni\n. This leads to a reduction in the computational workload by a factor:\n\n1\nC\n1\nC\n2\nC\n3\n{\\displaystyle \n\\frac{1}{C_1 C_2 C_3}\n}\n\nIn case one sets\nNKRED\n, the grid reduction factors will be uniformly set to\nC\n1\n=\nC\n2\n=\nC\n3\n=\nNKRED\n. If one wants to specify separate grid reduction factors for\nC\n1\n,\nC\n2\n, and\nC\n3\none should use\nC\n1\n=\nNKREDX\n,\nC\n2\n=\nNKREDY\n, and\nC\n3\n=\nNKREDZ\n, respectively.\n\nWarning:\nthere are circumstances under which\nNKRED\nand\nNKREDX\n,\nY\n,\nZ\nshould not be used!",
    "related_tags": [
      "NKRED",
      "NKREDX",
      "NKREDZ",
      "EVENONLY",
      "ODDONLY",
      "downsampling"
    ]
  },
  "NKREDZ": {
    "default_value": "NKREDZ = 1",
    "description": "NKREDZ specifies a reduction factor for the q -point grid representation of the exact exchange potential along reciprocal space direction b 3 .",
    "detailed_description": "One may restrict the sum over\nq\nin the\nFock exchange potential\n(or one of its short range counterparts) to a subset, {\nq\nk\n}, of the full (\nN\n1\n×\nN\n2\n×\nN\n3\n)\nk\n-point set, {\nk\n}, for which the following holds\n\nq\nk\n=\nb\n1\nn\n1\nC\n1\nN\n1\n+\nb\n2\nn\n2\nC\n2\nN\n2\n+\nb\n3\nn\n3\nC\n3\nN\n3\n,\n(\nn\ni\n=\n0\n,\n.\n.\n,\nN\ni\n−\n1\n)\n{\\displaystyle \n\\mathbf{q_k} = \\mathbf{b}_1 \\frac{n_1 C_1}{N_1} + \\mathbf{b}_2 \\frac{n_2 C_2}{N_2}\n+ \\mathbf{b}_3 \\frac{n_3 C_3}{N_3},\\quad(n_i=0,..,N_i-1)\n}\n\nwhere\nb\n1,2,3\nare the reciprocal lattice vectors of the primitive cell,\nand\nC\ni\nis the integer grid reduction factor along reciprocal lattice direction\nb\ni\n. This leads to a reduction in the computational workload by a factor:\n\n1\nC\n1\nC\n2\nC\n3\n{\\displaystyle \n\\frac{1}{C_1 C_2 C_3}\n}\n\nIn case one sets\nNKRED\n, the grid reduction factors will be uniformly set to\nC\n1\n=\nC\n2\n=\nC\n3\n=\nNKRED\n. If one wants to specify separate grid reduction factors for\nC\n1\n,\nC\n2\n, and\nC\n3\none should use\nC\n1\n=\nNKREDX\n,\nC\n2\n=\nNKREDY\n, and\nC\n3\n=\nNKREDZ\n, respectively.\n\nWarning:\nthere are circumstances under which\nNKRED\nand\nNKREDX\n,\nY\n,\nZ\nshould not be used!",
    "related_tags": [
      "NKRED",
      "NKREDX",
      "NKREDY",
      "EVENONLY",
      "ODDONLY",
      "downsampling"
    ]
  },
  "NLSPLINE": {
    "default_value": "NLSPLINE = .FALSE.",
    "description": "construct the PAW projectors in reciprocal space using spline interpolation so that they are k -differentiable.",
    "detailed_description": "For\nNLSPLINE\n=.TRUE., the PAW projectors in reciprocal space (\nLREAL\n=.FALSE.) are set up using a spline interpolation so that they are\nk\ndifferentiable. This improves the susceptibility contribution to the chemical shifts. It only slightly affects the other contributions to the chemical shifts.\n\nIt is advised to set\nNLSPLINE\n=.TRUE. if and only if PAW projectors are applied in reciprocal space and chemical shifts are calculated, i.e., if and only if\nLREAL\n=.FALSE. and\nLCHIMAG\n=.TRUE. As this option also gives slightly different total energies, it is advised to use the default\nNLSPLINE\n=.FALSE. in all other calculations for reasons of compatibility.\n\nReal-space projectors are\nk\ndifferentiable by construction, hence do not require to set\nNLSPLINE\n=.TRUE.",
    "related_tags": [
      "LCHIMAG",
      "DQ",
      "ICHIBARE",
      "LNMR_SYM_RED"
    ]
  },
  "NMAXFOCKAE_and_LMAXFOCKAE": {
    "default_value": "Default: NMAXFOCKAE = 1",
    "description": "NMAXFOCKAE and LMAXFOCKAE determine whether the overlap densities in the Fock exchange and correlated wave function methods are accurately reconstructed on the plane wave grid (shape restoration). This flag generally only applies to the Fock-exchange part as well as many-body post DFT methods (GW, RPA, MP2, etc.).",
    "detailed_description": "Detailed Discussion\n\nIn the PAW method, the difference between the charge density of the all-electron partial waves\nϕ\nβ\n{\\displaystyle \\phi_\\beta}\nand\nthe pseudo partial waves\nϕ\n~\nβ\n{\\displaystyle \\tilde \\phi_\\beta}\n\nQ\nα\nβ\n(\nr\n)\n=\nϕ\nα\n∗\n(\nr\n)\nϕ\nβ\n(\nr\n)\n−\nϕ\n~\nα\n∗\n(\nr\n)\nϕ\n~\nβ\n(\nr\n)\n{\\displaystyle \nQ_{\\alpha\\beta}({\\mathbf r})= \\phi^*_\\alpha({\\mathbf r})\\phi_\\beta({\\mathbf r})  - \\tilde \\phi^*_\\alpha({\\mathbf r})\\tilde \\phi_\\beta({\\mathbf r})\n}\n\nis usually treated on spherical grids centered at each atom\n(one-center terms inside the PAW spheres, see\nPAW method\nand more detailed description for\nLMAXFOCK\n).  To describe long range electrostatic effects, the\nmoments\nof the differences of the all-electron and pseudo charge density \nalso need to be added on the plane wave grid (compensation density, see\nPAW method\n).\nThese compensation charges exactly restore the moments of the all-electron density on the plane wave\ngrid. For the Fock exchange the maximum\nL\nquantum number up to which  \nthe augmentation is done is controlled by\nLMAXFOCK\n.\n\nFor the RPA, GW, and most post DFT methods, the one-center terms are, however, presently\nnot implemented. Depending on the material, this can cause sizable errors\nin particular for 3d and (to a lesser extent) 2p, 4d and 5d elements.\nTo correct for this error, an alternative treatment is implemented\non the plane wave grid for the exchange and correlation contributions. \nThis  allows to restore the all-electron densities accurately already on the plane wave grid\nby specifying the flags\nLMAXFOCKAE\nand\nNMAXFOCKAE\n. This improved\ntreatment— termed shape restoration —is available for exchange as well as many body correlation contributions.\nFor exchange, the exact one-center terms are also implemented. This means shape restoration is not required and should not change the results.\n\nTo achieve the improved treatment on the plane wave grid,\nQ\nα\nβ\n(\nr\n)\n{\\displaystyle  Q_{\\alpha\\beta}({\\mathbf r}) }\nis Fourier transformed  to reciprocal space\nQ\nα\nβ\n(\nq\n)\n{\\displaystyle  Q_{\\alpha\\beta}(q) }\nand then expanded\nin a set of orthogonal functions localized at each atomic site. These augmentation charges\nare then added to the pseudo charge densities on the plane wave grid. Shape restoration is only accurate up to a certain plane wave cutoff, typically about 150 eV for\nNMAXFOCKAE\n=1, and 400 eV for\nNMAXFOCKAE\n= 2. Experience shows that\nNMAXFOCKAE\n=1 is sufficient to predict very accurate energy differences and quite accurate quasiparticle energies.\n\nFor\nLMAXFOCKAE\n=-1 (the default for DFT and Hartree-Fock calculations), only the moments of the all-electron charge densities are restored on the plane wave grid. This is the default for Hartree-Fock calculations, and the setting is very precise since for Hartree-Fock the one-center terms are implemented in radial grids as for DFT.\n\nIf\nLMAXFOCKAE\nis set to values larger than -1 (and\nNMAXFOCKAE\n=1), not only the moments of the all-electron charge density are restored on the plane wave grid, but also the all-electron charge density is restored up to a typical plane wave energy of 150 eV (controlled by\nQMAXFOCKAE\n). This setting yields very accurate results for post DFT methods (MP2, RPA, GW, etc.) for most sp bonded materials.\nLMAXFOCKAE\nis used to specify the maximum spherical (\nL\n) quantum number up \nto which this more accurate treatment is used. The default is\nLMAXFOCKAE\n=4 for post DFT methods.\nIf no accurate augmentation is desired by the user, simply set\nLMAXFOCKAE\n=-1 in the INCAR file.\n\nIf\nLMAXFOCKAE\nis set to values larger than -1 and\nNMAXFOCKAE\n=2, the charge density is restored accurately on the plane wave grid up to a typical plane wave energy of 400 eV. As before,\nLMAXFOCKAE\ncan be used to specify the maximum spherical (\nL\n) quantum number up \nto which this more accurate treatment is used.\nNMAXFOCKAE\n=2 yields very accurate results for \npost DFT methods (MP2, RPA, GW) even for difficult 3d elements. For RPA and MP2 total energy calculations, differences between\nNMAXFOCKAE\n=1 and\nNMAXFOCKAE\n=2 are usually tiny for total energy differences. Since the absolute correlation energies might change, it is, however, vital to use the same setting for\nNMAXFOCKAE\nand\nLMAXFOCKAE\n, if energy differences are calculated. \nFor GW calculations, increasing\nNMAXFOCKAE\nfrom 1 to 2 might change QP energies by 100-200 meV for 3d and late 4d and 5d elements. Despite the improve precision,\nNMAXFOCKAE\n=2 should be used with great caution. Specifically, noise and egg-box effects are introduced as\nNMAXFOCKAE\nis increased. So use\nthis flag only after extensive tests.\n\nThe setting for\nLMAXFOCKAE\nshould be also considered carefully. Generally, it suffices to set\nLMAXFOCKAE\nto twice the maximum\nl\nquantum number found in the\nPOTCAR\nfile.\nFor instance for sp elements,\nLMAXFOCKAE\n= 2 suffices. For d elements,\nLMAXFOCKAE\n= 4 suffices\n(a d electron can create charge densities with\nL\n-quantum numbers up to 4), whereas for f elements, users\nshould test whether\nLMAXFOCKAE\n= 6 is required.\n\nMore details on shape restoration are explained in Ref.\n[1]\nand\n[2]\n.\n\nUsefull Settings\n\nIn summary, useful manual settings of\nNMAXFOCKAE\nand\nLMAXFOCKAE\nare:\n\nLMAXFOCKAE\n=-1, to switch off the accurate augmentation altogether (reduces noise in correlation energies).\nLMAXFOCKAE\n=4 (or larger) to force an accurate treatment for the charge augmentation on the plane wave grid (can be selected even in Hartree-Fock type calculations, but causes some additional noise).\nNMAXFOCKAE\n=2, to select the very accurate augmentation on the plane wave grid. Please check whether the VASP default setting for\nLMAXFOCKAE\nsuffices (OUTCAR file). Use this setting only with care, as it can result in very noisy data for coarse FFT grids.",
    "related_tags": [
      "LMAXFOCK",
      "QMAXFOCKAE",
      "LFOCKAEDFT",
      "↑",
      "M. Shishkin and G. Kresse, Phys. Rev. B 74 , 035101 (2006).",
      "M. Unzog, A. Tal, G. Kresse, X-ray absorption using the projector augmented-wave method and the Bethe-Salpeter equation , Phys. Rev. B 106 , 155133 (2022)."
    ]
  },
  "NOMEGA": {
    "default_value": "Default: NOMEGA = 100 for GW calculations | = 12 for ACFDT calculations",
    "description": "NOMEGA specifies the number of (imaginary) frequency and imaginary time grid points.",
    "detailed_description": "Typically\nNOMEGA\nshould be chosen around 50-100 (for the parallel version,\nNOMEGA\nshould be dividable by the number of compute nodes to obtain maximum efficiency). For quick and memory conserving calculations, it is sufficient to set\nNOMEGA\nto values around\nNOMEGA\n= 20-30, but then you must expect errors of the order of 20-50 meV for the gap and 100-200 meV for the bottom of the conduction band. We furthermore recommend to increase\nNOMEGA\nnot beyond 100 for a\nk\n{\\displaystyle k}\n-point sampling of 4×4×4 points/atom: the joint DOS and the self-energy tend to possess spurious fine structure related to the finite\nk\n{\\displaystyle k}\n-point grid. This fine structure is smoothed when smaller values for\nNOMEGA\nare used or if more\nk\n{\\displaystyle k}\n-points are used. For 6×6×6\nk\n{\\displaystyle k}\n-points/atom\nNOMEGA\ncan be usually increased to 200-300 without noticing problems associated with this kind of noise.\n\nNote that the spectral method (see\nLSPECTRAL\n) scales very favorable with respect to the number of frequency points hence\nNOMEGA\n=30 is usually only slightly faster than\nNOMEGA\n=100.\n\nN.B: Low-scaling GW and RPA/ACFDT calculations require considerably fewer imaginary frequency (and time) points.",
    "related_tags": [
      "NOMEGAR",
      "NTAUPAR",
      "LSPECTRAL",
      "NOMEGA_DUMP"
    ]
  },
  "NOMEGAPAR": {
    "default_value": "Default: NOMEGAPAR = NOMEGA used in low scaling GW and RPA/ACFDT calculations.",
    "description": "NOMEGAPAR available as of VASP.6, specifies the number of processor groups sharing the same imaginary frequency grid points.",
    "detailed_description": "",
    "related_tags": [
      "NTAUPAR",
      "NOMEGA"
    ]
  },
  "NOMEGAR": {
    "default_value": "Default: NOMEGAR = NOMEGA for GW calculations | = 0 for ACFDT calculations",
    "description": "NOMEGAR specifies the number of frequency grid points along the real axis.",
    "detailed_description": "Usually\nNOMEGAR\nequals\nNOMEGA\n. If\nNOMEGAR\nis smaller than\nNOMEGA\n(for instance 0), frequencies along the imaginary time axis are included (this feature is currently not fully supported).",
    "related_tags": [
      "NOMEGA"
    ]
  },
  "NOMEGA_DUMP": {
    "default_value": "Default: NOMEGA_DUMP = -1",
    "description": "NOMEGA_DUMP selects the imaginary frequency point of screened potential in low-scaling GW calculations that is written to file.",
    "detailed_description": "Mind:\nThis tag can be used to obtain\nWFULLxxxx.tmp\nfor\nBSE calculations\n.\n\nNOMEGA_DUMP\nselects the imaginary frequency point of the screened Coulomb kernel that is written to\nWFULLxxxx.tmp\nin\nlow-scaling GW calculations\n. \nIf set to 0,\nWFULLxxxx.tmp\ncontains the screened Coulomb interaction W at\nω\n=\n0\n{\\displaystyle \\omega=0}\n.\nFor positive values, these files contain the screened Coulomb interaction at the corresponding imaginary frequency point. \nFor negative values,\nWFULLxxxx.tmp\nis not written.",
    "related_tags": [
      "ALGO",
      "NOMEGA"
    ]
  },
  "NPACO": {
    "default_value": "NPACO = 256",
    "description": "NPACO sets the number of slots in the pair-correlation function written to PCDAT .",
    "detailed_description": "VASP evaluates the pair-correlation function each\nNBLOCK\nsteps and writes the PC-function after\nNBLOCK\n×\nKBLOCK\nsteps to the\nPCDAT\nfile.",
    "related_tags": [
      "APACO",
      "NBLOCK",
      "KBLOCK",
      "PCDAT"
    ]
  },
  "NPAR": {
    "default_value": "NPAR = number of cores",
    "description": "NPAR determines the number of bands that are treated in parallel.",
    "detailed_description": "VASP currently offers parallelization and data distribution over bands and/or over plane wave coefficients, and as of VASP.5.3.2, parallelization over\nk\n-points (no data distribution, see\nKPAR\n).\nTo obtain high efficiency on massively parallel systems or modern multi-core machines, it is strongly recommended to use all at the same time. Most algorithms work with any data distribution (except for the single band conjugated gradient, which is considered to be obsolete).\n\nNPAR\ndetermines how many bands are treated in parallel. The current default is\nNPAR\n=\nnumber of cores\n, meaning that one orbital is treated by one core.\nNCORE\nis then set to 1. If\nNPAR\n=1,\nNCORE\nis set to the number of cores. This implies data distribution over plane wave coefficients only: all cores will work together on every individual band, i.e., the plane wave coefficients of each band are distributed over all cores. This is usually very slow and should be avoided.\n\nNPAR\n=\nnumber of cores\nis the optimal setting for platforms with a small communication bandwidth and is a good choice for up to 8 cores, as well as for machines with a single core per node and a Gigabit network. However, this mode substantially increases the memory requirements, because the non-local projector functions must be stored entirely on each core. In addition, substantial all-to-all communications are required to orthogonalize the bands. On massively parallel systems and modern multi-core machines we strongly urge to set\n\nNPAR\n≈\n\\#of\ncores\n{\\displaystyle \\textrm{NPAR}\\approx\\sqrt{\\textrm{\\#of}\\; \\textrm{cores}}}\n\nor\n\nNCORE\n=\n\\#of\ncores\nper\ncompute\nnode\n{\\displaystyle \\textrm{NCORE}=\\textrm{\\#of}\\;\\textrm{cores}\\;\\textrm{per}\\;\\textrm{compute}\\;\\textrm{node}}\n\nIn selected cases, we found that this improves the performance by a factor of up to four compared to the default, and it also significantly improves the stability of the code due to reduced memory requirements.\n\nNCORE\nis available from VASP.5.2.13 on, and is more handy than the previous parameter\nNPAR\n.\nThe user should either specify\nNCORE\nor\nNPAR\n, where\nNPAR\ntakes a higher preference.\nThe relation between both parameters is\n\nNCORE\n=\n\\#of\ncores\n/\nNPAR\n{\\displaystyle \\textrm{NCORE}=\\textrm{\\#of}\\; \\textrm{cores}/\\textrm{NPAR}}\n\nThe optimum settings for\nNPAR\nand\nLPLANE\ndepend strongly on the type of machine you are using.\nSome recommended setups:\n\nLINUX cluster linked by Infiniband, modern multicore machines:\n\nOn a LINUX cluster with multicore machines linked by a fast network we recommend to set\n\nLPLANE = .TRUE.\nNCORE  = number of cores per node (e.g. 4 or 8)\nLSCALU = .FALSE.\nNSIM   = 4\n\nIf very many nodes are used, it might be necessary to set\nLPLANE\n=.FALSE., but usually this offers very little advantage. For long (e.g. molecular dynamics runs), we recommend to optimize\nNPAR\nby trying short runs for different settings.\n\nLINUX cluster linked by 1 Gbit Ethernet, and LINUX clusters with single cores:\n\nOn a LINUX cluster linked by a relatively slow network,\nLPLANE\nmust be set to .TRUE., and the\nNPAR\nflag should be equal to the number of cores:\n\nLPLANE = .TRUE.\nNCORE  = 1\nLSCALU = .FALSE.\nNSIM   = 4\n\nMind that you need at least a 100 Mbit full duplex network, with a fast switch offering at least 2 Gbit switch capacity to find usefull speedups. Multi-core machines should be always linked by an Infiniband, since Gbit is too slow for multi-core machines.\n\nMassively parallel machines (Cray, Blue Gene):\n\nOn many massively parallel machines one is forced to use a huge number of cores. In this case load balancing problems and problems with the communication bandwidth are likely to be experienced. In addition the local memory is fairly small on some massively parallel machines; too small keep the real space projectors in the cache with any setting. Therefore, we recommend to set\nNPAR\non these machines to √\n# of cores\n(explicit timing can be helpful to find the optimum value). The use of\nLPLANE\n=.TRUE. is only recommended if the number of nodes is significantly smaller than\nNGX\n,\nNGY\nand\nNGZ\n.\n\nIn summary, the following setting is recommended\n\nLPLANE = .FALSE.\nNPAR   = sqrt(number of cores)\nNSIM   = 1",
    "related_tags": [
      "NCORE",
      "LPLANE",
      "LSCALU",
      "NSIM",
      "KPAR",
      "LSCALAPACK",
      "LSCAAWARE"
    ]
  },
  "NPPSTR": {
    "default_value": "",
    "description": "NPPSTR specifies the number of k-points on the strings in the IGPAR direction.",
    "detailed_description": "NPPSTR\nspecifies the number of k-points on the strings\nk\nj\n=\nk\n⊥\n+\nj\nG\n∥\n/\nN\nP\nP\nS\nT\nR\n{\\displaystyle \\bold{k}_{j} = \\bold{k}_{\\perp} + j\\bold{G}_{\\parallel}/\\mathrm{NPPSTR} }\n(with\nj\n=\n0\n,\n.\n.\n,\nN\nP\nP\nS\nT\nR\n−\n1\n{\\displaystyle  j=0,..,\\mathrm{NPPSTR}-1}\n). See also\nLBERRY\n.",
    "related_tags": [
      "IGPAR",
      "LBERRY"
    ]
  },
  "NRMM": {
    "default_value": "NRMM = 4",
    "description": "Maximum number of iterative steps for RMM-DIIS ( IALGO =4X) or Davidson algorithms ( IALGO =3X).",
    "detailed_description": "Note: This tag was formerly known as NDAV which is the name of the variable in the VASP source code.",
    "related_tags": [
      "IALGO"
    ]
  },
  "NSIM": {
    "default_value": "NSIM = 4",
    "description": "NSIM sets the number of bands that are optimized simultaneously by the RMM-DIIS algorithm.",
    "detailed_description": "The RMM-DIIS algorithm (\nIALGO\n=48) works in a blocked mode.\nNSIM\nbands are optimized at the same time. This allows to use matrix-matrix operations instead of matrix-vector operation for the evaluations of the non local projection operators in real space, and might speed up calculations on some machines. There should be no difference in the total energy and the convergence behavior between\nNSIM\n=1 and\nNSIM\n>1, only the performance should improve.",
    "related_tags": [
      "IALGO",
      "NCORE",
      "NPAR",
      "LPLANE",
      "LSCALU",
      "KPAR",
      "LSCALAPACK",
      "LSCAAWARE"
    ]
  },
  "NSTORB": {
    "default_value": "Default: NSTORB = -1",
    "description": "NSTORB specifies the number of stochastic orbitals per cycle in the stochastic MP2 algorithm.",
    "detailed_description": "NSTORB\ndefines the number of stochastic orbitals per cycle, i.e., the number of stochastic orbitals that define one stochastic sample. If the sample is not large enough, the calculations are repeated until the accuracy, defined by ESTOP, is reached.\n\nAs a rule of thumb, we recommend setting\n\nNSTORB\n=\nNBANDS\n.\n{\\displaystyle \n\\texttt{NSTORB} = \\sqrt{\\texttt{NBANDS}} \\;.\n}\n\nSee\nhere\nfor a small tutorial on stochastic Laplace transformed MP2 calculations.",
    "related_tags": [
      "NOMEGA",
      "ESTOP",
      "LSMP2LT",
      "LMP2LT",
      "NBANDS",
      "KPAR",
      "ALGO"
    ]
  },
  "NSUBSYS": {
    "default_value": "",
    "description": "NSUBSYS defines the atomic subsystems in calculations with multiple Anderson thermostats (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "Up to three user-defined atomic subsystems may be coupled with independent Andersen thermostats\n[1]\n(\nMDALGO\n=13).\n\nThese subsystems are defined by specifying the last atom for each subsystem (two or three values must be supplied). For instance, if total of 20 atoms is defined in the\nPOSCAR\n-file, and the initial 10 atoms belong to the subsystem 1, the next 7 atoms to the subsystem 2, and the last 3 atoms to the subsystem 3,\nNSUBSYS\nshould be defined as follows:\n\nNSUBSYS\n= 10 17 20\n\nNote that the last number in the previous example is actually redundant (clearly the last three atoms belong to the last subsystem) and does not have to be user-supplied.",
    "related_tags": [
      "TSUBSYS",
      "PSUBSYS",
      "MDALGO"
    ]
  },
  "NSW": {
    "default_value": "NSW = 0",
    "description": "NSW sets the maximum number of ionic steps.",
    "detailed_description": "IBRION\n= 0:\n\nNSW\ngives the number of steps in all\nmolecular dynamics\nruns. It\nhas\nto be supplied, otherwise VASP exits immediately after having started. We recommend splitting long MD runs containing ab-initio calculations into multiple calculations with\nNSW\n⪅20000. For\nML_MODE\n=run larger values of\nNSW\nshould be possible, but consider setting\nML_OUTBLOCK\n.\n\nIBRION\n!= 0:\n\nIn all minimization algorithms (quasi-Newton, conjugate gradient, and damped molecular dynamics)\nNSW\ndefines the maximum number of ionic steps.\n\nWithin each ionic step at most\nNELM\nelectronic steps are performed. It is fewer if the convergence criterium set by\nEDIFF\nis met before. Forces and stresses are calculated according to the setting of\nISIF\nfor each ionic step.",
    "related_tags": [
      "structure optimization",
      "NBLOCK",
      "KBLOCK",
      "ML_OUTBLOCK"
    ]
  },
  "NTARGET_STATES": {
    "default_value": "",
    "description": "Controls which Wannier states are excluded in constrained random phase approximation. Check also NCRPA_BANDS .",
    "detailed_description": "This tag is effective for\nALGO\n=CRPA and ignored otherwise.\nFor instance\n\nNTARGET_STATES = 1 2 4\n\nselects the Wannier state 1, 2 and 4, where the ordering of the Wannier states depends on the chosen basis set.\n\nRelated tags and articles\n\nALGO\n,\nNCRPA_BANDS\n,\nDMFT_BASIS\n\nExamples that use this tag",
    "related_tags": []
  },
  "NTAUPAR": {
    "default_value": "Default: NTAUPAR = depends on MAXMEM used in low scaling GW and RPA/ACFDT calculations.",
    "description": "NTAUPAR available as of VASP.6, specifies the number of MPI groups sharing same imaginary time grid points. The default value of NTAUPAR is set to the largest possible value supported on the compute nodes to speed up the GW or RPA calculation.",
    "detailed_description": "NTAUPAR has the biggest impact on memory usage as well as total runtime for low-scaling GW and RPA calculations. If not found in the\nINCAR\n, NTAUPAR is set automatically based on the value of\nMAXMEM\n(the available memory for each rank on each compute node), such that the GW and RPA job fits in the RAM on each compute node.\n\nIf\nMAXMEM\nis not set, VASP looks in \"/proc/meminfo\" for \"MemAvailable\" to set\nMAXMEM\ninternally, otherwise the code uses the value provided in the\nINCAR\n.\n\nNTAUPAR=\nNOMEGA\nis the maximum value possible, while NTAUPAR=1 is the smallest possible value.",
    "related_tags": [
      "NOMEGAPAR",
      "NOMEGA"
    ]
  },
  "NTEMPER": {
    "default_value": "NTEMPER = 200",
    "description": "NTEMPER specifies how often temperature swaps are attempted during parallel tempering. The flag must be used in combination with IMAGES and LTEMPER . NTEMPER =0, allows to perform several completely independent calculations.",
    "detailed_description": "NTEMPER\nmust be a positive integer or zero. Swaps are on average attempted after\nNTEMPER\nmolecular dynamics steps.\nSpecifically, a random number\nr\n{\\displaystyle  r }\nbetween [0,1[ is drawn. The next temperature swaps are attempted after\nNTEMPER\n×\n2\nr\n−\n1\n{\\displaystyle  \\times  2~ r -1 }\nsteps. Obviously, for\nNTEMPER\n=1 swaps are attempted at every MD step. In the present code version, temperature swaps are alternatively performed between images 1,2 and 3,4 and 5,6 etc., or upon the next swap between images 2,3 and 4,5 and 6,7 etc.\nThis implies that many swaps are attempted at the same time.\n\nFurthermore, no temperature swapping is attempted for\nNTEMPER\n=0. This allows many independent calculations to be performed in directories 01, 02, 03, ... which can be useful when performing many similar calculations for small systems or using machine-learned force fields on many-core machines (strong scaling is sometimes not particularly good for small systems).\n\nA final note is in place. If INCAR files exist in the subdirectories, the tag\nNTEMPER\nmust be set in all\nINCAR\nfiles of the subdirectories 01, 02, 03, and\nNTEMPER\nmust be identical. Failure to observe this rule can lead to unexpected behavior.",
    "related_tags": [
      "IMAGES",
      "LTEMPER"
    ]
  },
  "NUCIND": {
    "default_value": "NUCIND = .FALSE.",
    "description": "Allows the nucleus-independent chemical shielding (NICS) to be calculated.",
    "detailed_description": "Warning: Not yet released!\nThis page contains information about a feature that will be available in a future \nrelease of VASP. In other words, currently you cannot use it even with the latest version of VASP. The information may change significantly until it is released.\n\nIn conjunction with\nLCHIMAG\n= True\n,\nNUCIND\ncalculates the chemical shielding tensor\nσ\ni\nj\n(\nR\n)\n{\\displaystyle \\sigma_{ij}(\\mathbf{R})}\nat positions\nR\n{\\displaystyle \\textbf{R}}\noff-nucleus, hence nucleus-independent chemical shielding (NICS)\n[1]\n[2]\n. VASP calculates only from the plane wave\ngrid, there is no one-center augmentation.\n\nWhen\nNUCIND\n= True\n, by default these are calculated on the fine FFT grid\nNGXF\nx\nNGYF\nx\nNGZF\nin ppm. The output is written to\nNICS\n.\n\nIt is also written to\nvaspout.h5\n, if compiled with\nHDF5 support\n. You can find the data groups:\n\n/results/nics            Group\n/results/nics/grid       Dataset {3}\n/results/nics/structure  Group\n/results/nics/structure/position Group\n/results/nics/structure/position/direct_coordinates Dataset {SCALAR}\n/results/nics/structure/position/ion_sha256 Dataset {2}\n/results/nics/structure/position/ion_types Dataset {2}\n/results/nics/structure/position/lattice_vectors Dataset {3, 3}\n/results/nics/structure/position/number_ion_types Dataset {2}\n/results/nics/structure/position/position_ions Dataset {8, 3}\n/results/nics/structure/position/scale Dataset {SCALAR}\n/results/nics/structure/position/system Dataset {SCALAR}\n/results/nics/values     Dataset {9, 108, 108, 108}\n\nand use\npy4vasp\nto access these, e.g., using\n\nimport\npy4vasp\nas\npv\ncalc\n=\npv\n.\nCalculation\n.\nfrom_path\n(\n\".\"\n)\ncalc\n.\nnics\n.\nplot\n()\n\nto select the isotropic chemical shielding\nσ\ni\ns\no\n{\\displaystyle \\sigma_{iso}}\nin 3D space\n[3]\n[4]\n. It will produce an isosurface of the shielding (positive) and deshielding (negative) over the crystal structure.\n\nAlternatively, produce a 2D contour plot of the NICS in a plane\n[5]\n:\n\nimport\npy4vasp\nas\npv\ncalc\n=\npv\n.\nCalculation\n.\nfrom_path\n(\n\".\"\n)\ncalc\n.\nnics\n.\nto_contour\n(\na\n=\n0.5\n)\n\nIt will result in a contour plot showing the isotropic chemical shielding\nσ\ni\ns\no\n{\\displaystyle \\sigma_{iso}}\nin the selected plane. The plane is selected as a fraction\nx\nof the lattice vector. Here,\nx=0.5\ncorresponds to half of the primary lattice vector\na\n{\\displaystyle \\mathbf{a}}\n. For the other lattice vectors use\nb=x\nor\nc=x\n.\n\nFor both the 2D and 3D plots, the isotropic chemical shielding is used by default. You can alternatively select the other properties (see\nLCHIMAG\nfor details. Herzfeld-Berger convention is followed\n[6]\n) by inputting them as arguments into the functions, e.g.,\ncalc.nics.plot(\"anisotropic\")\nor\ncalc.nics.to_contour(\"span\", a=0.5)\n:\n\n\"isotropic\"\n(default) - plot the isotropic chemical shielding\nσ\ni\ns\no\n{\\displaystyle \\sigma_{iso}}\n\"anisotropic\"\n- plot the anisotropic chemical shielding\nσ\na\nn\ni\n{\\displaystyle \\sigma_{ani}}\n\"span\"\n- plots the span\nΩ\n{\\displaystyle \\Omega}\n\"skew\"\n- plot the skew\nκ\n{\\displaystyle \\kappa}\n\nPOSNICS\n\nAlternatively, if the\nPOSNICS\nfile is present, then the positions defined within that file will be used. The calculation takes longer as each point is calculated in serial and not in parallel as for the grid. However, there is far greater flexibility for defining physically relevant positions, e.g., hydrogen bonds, close to nuclei, or chemical bonds. These chemical shielding tensors are printed in the\nOUTCAR\nfile as follows, e.g., for the 100th NICS point:\n\nnics 100\n          1.187143         -0.003408         -0.000000\n         -0.002977         -1.893648         -0.000000\n         -0.000000         -0.000000         -0.326272\n\nIt is also written to\nvaspout.h5\n, if compiled with\nHDF5 support\n. You can find the data groups:\n\n/results/posnics         Group\n/results/posnics/label   Dataset {SCALAR}\n/results/posnics/positions Dataset {3, 10000}\n/results/posnics/values  Dataset {10000, 3, 3}\n\nand use\npy4vasp\nto access these, e.g., using\n\nimport\npy4vasp\nas\npv\ncalc\n=\npv\n.\nCalculation\n.\nfrom_path\n(\n\".\"\n)\ncalc\n.\nnics\n.\nread\n()\n\nto read the NICS values for the positions defined in\nPOSNICS\n. Since the grid is not necessarily regular, you will need to plot these yourself.",
    "related_tags": [
      "LCHIMAG",
      "NICS",
      "LNICSALL",
      "LPOSNICS",
      "POSNICS"
    ]
  },
  "NUM_WANN": {
    "default_value": "NUM_WANN = NBANDS",
    "description": "Controls the number of Wannier orbitals to be constructed.",
    "detailed_description": "This tag is used to determine the number of Wannier orbitals to be constructed in the\nSCDM method\n.\n\nSince VASP 6.2.0,\nNUM_WANN\nalso determines the number of Wannier orbitals to be used with wannier90.\nNote that the\nnum_wann\nvalue written to the\nwannier90.win\nfile is always the value of\nNUM_WANN\nknown by vasp.\n\nWhen using\nLOCPROJ\nfor Wannierization, it is not necessary to set\nNUM_WANN\n.\nIn this case, the number of Wannier orbitals is automatically set equal to the number of local functions.",
    "related_tags": [
      "LWANNIER90",
      "LSCDM",
      "CUTOFF_TYPE"
    ]
  },
  "NUPDOWN": {
    "default_value": "NUPDOWN = not set",
    "description": "Sets the difference between the number of electrons in the up and down spin components.",
    "detailed_description": "Allows calculations for a specific spin multiplet, i.e. the difference of the number of electrons in the up and down spin component will be kept fixed to the specified value. There is a word of caution required: If\nNUPDOWN\nis set in the\nINCAR\nfile the initial moment for the charge density should be the same. Otherwise convergence can slow down. When starting from atomic charge densities (\nICHARG\n=2), VASP will try to do this automatically by setting\nMAGMOM\nto\nNUPDOWN\n/\nNIONS\n. The user can of course overwrite this default by specifying a different\nMAGMOM\n(which should still result in the correct total moment). If one initializes the charge density from the one-electron wavefunctions, the initial moment is always correct, because VASP \"pushes\" the required number of electrons from the down to the up component. Initializing the charge density from the\nCHGCAR\nfile (\nICHARG\n=1), however, the initial moment is usually incorrect!\n\nIf no value is set (or\nNUPDOWN\n=-1) a full relaxation will be performed. This is also the default.",
    "related_tags": [
      "MAGMOM",
      "ICHARG"
    ]
  },
  "NWRITE": {
    "default_value": "NWRITE = 2",
    "description": "This tag determines how much will be written to the file OUTCAR ('verbosity tag').",
    "detailed_description": "The options for\nNWRITE\nare given in detail as\n\nNWRITE\n0\n1\n2\n3\ncontributions to electronic energy at each electronic iteration\nf\nf\ne\ne\nconvergence information\nf\nf\ne\ne\neigenvalues\nf+l\ni\ni\ne\nDOS + charge density\nf+l\ni\ni\ne\ntotal energy and electronic contributions\ni\ni\ni\ni\nstress\ni\ni\ni\ni\nbasis vectors\nf+l\ni\ni\ni\nforces\nf+l\ni\ni\ni\nlattice and space group information for\nISYM\n>0\nf\nf\nf\nf\nsymmetry operations for\nISYM\n>0\nf\ntiming information\nX\nX\n\nwhere the following abbreviations have been used\n\nf+l\nfirst and last ionic step\nf\nfirst ionic step\ni\neach ionic step\ne\neach electronic step\nX\nwhen applicable\n\nTip:\nFor long molecular-dynamics runs, use\nNWRITE\n=0 or\nNWRITE\n=1. For short runs use\nNWRITE\n=2.\nNWRITE\n=3 might give information if something goes wrong.\n\nNWRITE\n=4 is for debugging only.",
    "related_tags": [
      "OUTCAR",
      "IALGO",
      "IBRION",
      "MDALGO",
      "ISIF",
      "ISYM"
    ]
  },
  "OCCUPANCIES": {
    "default_value": "PLUGINS/OCCUPANCIES = .False.",
    "description": "PLUGINS/OCCUPANCIES calls the Python plugin for the occupancies interface for each ionic relaxation step",
    "detailed_description": "When\nPLUGINS/OCCUPANCIES\n=.TRUE., VASP calls the\noccupancies\nPython function at the end of each ionic relaxation step. \nThe primary use-case of this tag to recompute the occupancies after performing modifications through other plugins such as\nPLUGINS/LOCAL_POTENTIAL\n. It also allows changing\nNELECT\n,\nEFERMI\n,\nNUPDOWN\n,\nISMEAR\n,\nSIGMA\n,\nEMIN\nand\nEMAX\nat the end of each SCF step, to be reflected in the next step.\n\nExpected inputs\n\nThe\noccupancies\nPython function expects the following inputs,\n\ndef\noccupancies\n(\nconstants\n,\nadditions\n):\n\nwhere\nconstants\nand\nadditions\nand\nPython dataclasses\n.\nThe\nconstants\ndataclass consists of the following inputs, listed here with their associated\ndatatypes\n\n@dataclass\n(\nfrozen\n=\nTrue\n)\nclass\nConstantsOccupancies\n:\nNELECT\n:\nfloat\nEFERMI\n:\nfloat\nNUPDOWN\n:\nfloat\nISMEAR\n:\nint\nSIGMA\n:\nfloat\nEMIN\n:\nfloat\nEMAX\n:\nfloat\n\nThe\nadditions\ndataclass consists of the same quantities as the\nconstants\ntag.\n\nMind:\nCalling this interface implicitly triggers a recalculation of the occupancies\n\nModifying quantities\n\nModify the quantities listed in additions by adding to them.\n\nimport\nnumpy\nas\nnp\ndef\nstructure\n(\nconstants\n,\nadditions\n)\nadditions\n.\nNELECT\n+=\n1\n\nWarning:\nYou should not make modifications to quantities in\nconstants\n. We implemented some safeguards to prevent accidental modifications. Intentional changes will lead to erratic behavior because we may change the VASP code assuming these quantities are constant.",
    "related_tags": [
      "Plugins",
      "PLUGINS/FORCE_AND_STRESS",
      "PLUGINS/LOCAL_POTENTIAL",
      "PLUGINS/STRUCTURE"
    ]
  },
  "ODDONLY": {
    "default_value": "ODDONLY = .FALSE.",
    "description": "ODDONLY =.TRUE. selects a subset of k -points for the representation of the Fock exchange potential, with C 1 = C 2 = C 3 =1, and n 1 + n 2 + n 3 odd.",
    "detailed_description": "One may restrict the sum over\nq\nin the\nFock exchange potential\n(or one of its short range counterparts) to a subset, {\nq\nk\n}, of the full (\nN\n1\n×\nN\n2\n×\nN\n3\n)\nk\n-point set, {\nk\n}, for which the following holds\n\nq\nk\n=\nb\n1\nn\n1\nC\n1\nN\n1\n+\nb\n2\nn\n2\nC\n2\nN\n2\n+\nb\n3\nn\n3\nC\n3\nN\n3\n,\n(\nn\ni\n=\n0\n,\n.\n.\n,\nN\ni\n−\n1\n)\n{\\displaystyle \n\\mathbf{q_k} = \\mathbf{b}_1 \\frac{n_1 C_1}{N_1} + \\mathbf{b}_2 \\frac{n_2 C_2}{N_2}\n+ \\mathbf{b}_3 \\frac{n_3 C_3}{N_3},\\quad(n_i=0,..,N_i-1)\n}\n\nwhere\nb\n1,2,3\nare the reciprocal lattice vectors of the primitive cell,\nand\nC\ni\nis the integer grid reduction factor along reciprocal lattice direction\nb\ni\n.\n\nODDONLY\n=.TRUE. selects a subset of\nk\n-points with\nC\n1\n=\nC\n2\n=\nC\n3\n=1, and\nn\n1\n+\nn\n2\n+\nn\n3\nodd. It reduces the computational work load for HF type calculations by a factor two, but is only sensible for high symmetry cases (such as sc, fcc or bcc cells).\n\nWarning:\nthere are circumstances under which\nNKRED\nand\nNKREDX\n,\nY\n,\nZ\nshould not be used!",
    "related_tags": [
      "NKRED",
      "NKREDX",
      "NKREDY",
      "NKREDZ",
      "EVENONLY",
      "downsampling"
    ]
  },
  "ODDONLYGW": {
    "default_value": "ODDONLYGW = .FALSE.",
    "description": "ODDONLYGW allows to avoid the inclusion of the Γ {\\displaystyle \\Gamma} point in the evaluation of response functions (in GW calculations ).",
    "detailed_description": "The independent particle polarizability\nχ\nq\n0\n(\nG\n,\nG\n′\n,\nω\n)\n{\\displaystyle \\chi_{{\\mathbf{q}}}^0 ({\\mathbf{G}}, {\\mathbf{G}}', \\omega)}\nis given by:\n\nχ\nq\n0\n(\nG\n,\nG\n′\n,\nω\n)\n=\n1\nΩ\n∑\nn\n,\nn\n′\n,\nk\n2\nw\nk\n(\nf\nn\n′\nk\n+\nq\n−\nf\nn\nk\n)\n×\n⟨\nψ\nn\nk\n|\ne\n−\ni\n(\nq\n+\nG\n)\nr\n|\nψ\nn\n′\nk\n+\nq\n⟩\n⟨\nψ\nn\n′\nk\n+\nq\n|\ne\ni\n(\nq\n+\nG\n′\n)\nr\n′\n|\nψ\nn\nk\n⟩\nϵ\nn\n′\nk\n+\nq\n−\nϵ\nn\nk\n−\nω\n−\ni\nη\n{\\displaystyle \\chi_{{\\mathbf{q}}}^0 ({\\mathbf{G}}, {\\mathbf{G}}', \\omega) =\n\\frac{1}{\\Omega} \\sum_{n,n',{\\mathbf{k}}}2 w_{{\\mathbf{k}}}  (f_{n'{\\mathbf{k}}+{\\mathbf{q}}} - f_{n{\\mathbf{k}}})  \n\\times  \\frac{\\langle \\psi_{n{\\mathbf{k}}}| e^{-i ({\\mathbf{q}}+{\\mathbf{G}}){\\mathbf{r}}} | \\psi_{n'{\\mathbf{k}}+{\\mathbf{q}}}\\rangle\n\\langle \\psi_{n'{\\mathbf{k}}+{\\mathbf{q}}}| e^{i ({\\mathbf{q}}+{\\mathbf{G}}'){\\mathbf{r'}}} | \\psi_{n{\\mathbf{k}}}\\rangle}\n { \\epsilon_{n'{\\mathbf{k}}+{\\mathbf{q}}}-\\epsilon_{n{\\mathbf{k}}} -  \\omega - i \\eta } }\n\nIf the\nΓ\n{\\displaystyle \\Gamma}\npoint is included in the summation over\nk\n{\\displaystyle \\mathbf{k}}\n, convergence is very slow for some materials  (e.g. GaAs).\n\nTo deal with this problem the flag\nODDONLYGW\nhas been included.\nIn the automatic mode,  the\nk\n{\\displaystyle \\mathbf{k}}\n-grid is given by (see Sec. \\ref{sec:autok}):\n\nk\n→\n=\nb\n→\n1\nn\n1\nN\n1\n+\nb\n→\n2\nn\n2\nN\n2\n+\nb\n→\n3\nn\n3\nN\n3\n,\nn\n1\n=\n0...\n,\nN\n1\n−\n1\nn\n2\n=\n0...\n,\nN\n2\n−\n1\nn\n3\n=\n0...\n,\nN\n3\n−\n1.\n{\\displaystyle  \\vec{k} = \\vec{b}_{1} \\frac{n_{1}}{N_{1}} + \\vec{b}_{2} \\frac{n_{2}}{N_{2}}  + \\vec{b}_{3} \\frac{n_{3}}{N_{3}} ,\\qquad  n_1=0...,N_1-1 \\quad  n_2=0...,N_2-1 \\quad  n_3=0...,N_3-1. }",
    "related_tags": [
      "EVENONLYGW",
      "GW calculations"
    ]
  },
  "OFIELD_A": {
    "default_value": "",
    "description": "The tag OFIELD_A sets the desired order parameter Q 6 {\\displaystyle Q_6} in the Interface pinning method.",
    "detailed_description": "The bias potential in the\nInterface pinning\nmethod is written as\n\nU\nbias\n(\nR\n)\n=\nκ\n2\n(\nQ\n6\n(\nR\n)\n−\nA\n)\n2\n{\\displaystyle U_\\text{bias}(\\mathbf{R}) = \\frac\\kappa2 \\left(Q_6(\\mathbf{R}) - A\\right)^2 }\n.\n\nThe tag\nOFIELD_A\nsets the desired value of the order parameter\nA\n{\\displaystyle A}\n.",
    "related_tags": [
      "Interface pinning",
      "OFIELD_Q6_NEAR",
      "OFIELD_Q6_FAR",
      "OFIELD_KAPPA"
    ]
  },
  "OFIELD_KAPPA": {
    "default_value": "",
    "description": "The tag OFIELD_KAPPA sets the strength of the bias potential in the Interface pinning method.",
    "detailed_description": "The bias potential in the\nInterface pinning\nmethod is written as\n\nU\nbias\n(\nR\n)\n=\nκ\n2\n(\nQ\n6\n(\nR\n)\n−\nA\n)\n2\n{\\displaystyle U_\\text{bias}(\\mathbf{R}) = \\frac\\kappa2 \\left(Q_6(\\mathbf{R}) - A\\right)^2 }\n.\n\nThe tag\nOFIELD_KAPPA\nmethod sets the strength of the bias potential\nκ\n{\\displaystyle \\kappa}\n. The unit of\nκ\n{\\displaystyle \\kappa}\nis\neV\n/\n(\nunit\nof\nQ\n)\n2\n{\\displaystyle \\textrm{eV}/(\\textrm{unit} \\,\\, \\textrm{ of }\\,\\, Q)^2}\n.",
    "related_tags": [
      "Interface pinning",
      "OFIELD_Q6_NEAR",
      "OFIELD_Q6_FAR",
      "OFIELD_A"
    ]
  },
  "OFIELD_Q6_FAR": {
    "default_value": "",
    "description": "OFIELD_Q6_FAR sets the far fading distance for the computation of a continuous Q 6 {\\displaystyle Q_6} parameter in the interface-pinning method.",
    "detailed_description": "The unit of\nOFIELD_Q6_FAR\nis\nÅ\n{\\displaystyle \\AA}\n.",
    "related_tags": [
      "Interface pinning",
      "OFIELD_Q6_NEAR",
      "OFIELD_A",
      "OFIELD_KAPPA"
    ]
  },
  "OFIELD_Q6_NEAR": {
    "default_value": "",
    "description": "OFIELD_Q6_NEAR sets the near-fading distance (in Å {\\displaystyle \\AA} ) for the computation of a continuous Q 6 {\\displaystyle Q_6} parameter in the interface-pinning method.",
    "detailed_description": "",
    "related_tags": [
      "Interface pinning"
    ]
  },
  "OMEGAMAX": {
    "default_value": "OMEGAMAX = outermost node in dielectric function ϵ ( ω ) {\\displaystyle \\epsilon(\\omega)} /1.3",
    "description": "OMEGAMAX specifies the maximum frequency for the dense part of the frequency grid for GW calculations (old GW code, does not apply to GWR). For CRPA calculations, OMEGAMAX is the frequency point of the interaction. For BSE calculations OMEGAMAX determines the maximum energy difference for excitation pairs to be included. For calculations of the dielectric function via LOPTICS OMEGAMAX determines the maximum frequency of the calculated dielectric properties. Since the flag controls different aspects of the code, be careful when setting it (and remember to remove the tag, when you change the type of calculations).",
    "detailed_description": "GW type calculations:\n\nFor the frequency grid along the real and imaginary axis sophisticated schemes are used, which are based on simple model functions for the macroscopic dielectric function. The grid spacing is dense up to roughly 1.3*\nOMEGAMAX\nand becomes coarser for larger frequencies. The default value for\nOMEGAMAX\nis either determined by the outermost node in the dielectric function (corresponding to a singularity in the inverse of the dielectric function) or the energy difference between the valence band minimum and the conduction band minimum. The larger of these two values is used. Except for pseudopotentials with deep lying core states,\nOMEGAMAX\nis usually determined by the node in the dielectric function.\n\nFor\nACFDT calculations\n, only\nOMEGAMIN\nand\nOMEGATL\ndetermine the frequency grid (using a minimax algorithm).\n\nThe defaults have been carefully tested, and it is recommended to leave them unmodified, whenever possible. The grid should be solely controlled by\nNOMEGA\n. The only other value that can be modified is the complex shift\nCSHIFT\n. In principle,\nCSHIFT\nshould NOT be chosen independently of\nNOMEGA\nand\nOMEGAMAX\n: e.g. for less dense grids (smaller\nNOMEGA\n) the complex shift must be accordingly increased. The default for\nCSHIFT\nhas been chosen such that the calculations are converged to 10 meV with respect to\nNOMEGA\n: i.e. if\nCSHIFT\nis kept constant and\nNOMEGA\nis increased, the QP shifts should not change by more than 10 meV; at least for\nLSPECTRAL\n= .TRUE.. This was the case for the considered test materials. For\nLSPECTRAL\n= .FALSE. this does not apply. In this case it is recommended to set\nCSHIFT\nmanually and to perform careful convergence tests.\n\nFor\nLSPECTRAL\n= .TRUE. independent convergence tests with respect to\nNOMEGA\nand\nCSHIFT\nare usually not required, and it should be sufficient to control the technical parameters via the single parameter\nNOMEGA\n. Also note that too large values for\nNOMEGA\nin combination with coarse k-point grids can cause a decrease in precision (see\nNOMEGA\n).\n\nBSE and TD-DFT type calculations (see\nBSE calculations\n):\n\nIn this case,\nOMEGAMAX\nallows to reduce the number of conduction/ valence band pairs. Usually these are determined by\nNBANDSV\nand\nNBANDSO\n. The number of pairs is roughly proportional to the products of\nNBANDSV\n,\nNBANDSO\n, and the number of k-points in the full Brillouin zone. If\nOMEGAMAX\nis set, pairs for which the difference of the independent particle energy is larger than\nOMEGAMAX\nwill be removed from the basis set (and from the BSE calculations). This can improve performance, without significantly affecting the imaginary part of the dielectric function. The real part of the dielectric function is, however, rather sensitive to reducing\nOMEGAMAX\n,\nNBANDSV\n,\nNBANDSO\n.\n\nFrequency dependent dielectric matrix calculations (see\nLOPTICS\n):\n\nHere,\nOMEGAMAX\nsets the maximum frequency of the dielectric function calculated. The number of grid points is then defined via\nNEDOS\n. Note, that this parameter does not cut-off the number conduction/ valence band pairs considered in the dielectric function. Only the dielectric function itself is cut-off at this frequency. Hence, this does not affect computational effort significantly. It is advisable to choose\nOMEGAMAX\nhigh enough such that the excitation spectrum is well covered, to avoid artifacts at the cut off frequency due to the Gaussian and Lorentzian broadening (see section\nLOPTICS#Spectral broadening\n)",
    "related_tags": [
      "OMEGATL",
      "CSHIFT",
      "NOMEGA",
      "OMEGAMIN"
    ]
  },
  "OMEGAMIN": {
    "default_value": "OMEGAMIN = minimum transition energy (0.05 for metals)",
    "description": "OMEGAMIN sets the minimum frequency in the frequency grid.",
    "detailed_description": "",
    "related_tags": [
      "OMEGAMAX",
      "OMEGATL",
      "CSHIFT",
      "NOMEGA"
    ]
  },
  "OMEGATL": {
    "default_value": "OMEGATL = 10 × {\\displaystyle \\times} outermost node in dielectric function ϵ ( ω ) {\\displaystyle \\epsilon(\\omega)}",
    "description": "OMEGATL specifies the maximum frequency for the coarse part of the frequency grid.",
    "detailed_description": "For the frequency grid along the real and imaginary axis sophisticated schemes are used, which are based on simple model functions for the macroscopic dielectric function. The grid spacing is dense up to roughly 1.3*\nOMEGAMAX\nand becomes coarser for larger frequencies. \nThe default has been carefully tested, and it is recommended to leave it unmodified whenever possible.",
    "related_tags": [
      "OMEGAMAX",
      "OMEGAMIN",
      "CSHIFT",
      "NOMEGA"
    ]
  },
  "PARAM1": {
    "default_value": "PARAM1 = 0.1234",
    "description": "μ {\\displaystyle \\mu} for GGA =MK, β {\\displaystyle \\beta} for GGA =BO.",
    "detailed_description": "The\nPARAM1\ntag determines the value corresponding to different parameters depending on the\nGGA\nfunctional that is chosen:\n\nμ\n{\\displaystyle \\mu}\nin the optB86b\n[1]\n, B86R\n[2]\n, and DF3-opt2\n[3]\nexchange functionals, which have the same analytical form and correspond to\nGGA\n=MK.\nPARAM1\nshould in principle be set to 0.1234 for the optB86b-vdW nonlocal functional\n[1]\nor to\n10\n/\n81\n≈\n0.1234568\n{\\displaystyle 10/81\\approx0.1234568}\nfor the rev-vdW-DF2\n[2]\nand vdW-DF3-opt2\n[3]\nnonlocal functionals.\nβ\n{\\displaystyle \\beta}\nin the optB88\n[4]\nexchange functional or\nμ\n/\nκ\n{\\displaystyle \\mu/\\kappa}\nin the DF3-opt1\n[3]\nexchange functional, which have the same analytical form and correspond to\nGGA\n=BO.\nPARAM1\nshould in principle be set to\n0.22\n/\n1.2\n≈\n0.1833333333\n{\\displaystyle 0.22/1.2\\approx0.1833333333}\nfor the optB88-vdW nonlocal functional\n[4]\nor to\n(\n10\n/\n81\n)\n/\n1.1\n≈\n0.1122334456\n{\\displaystyle (10/81)/1.1\\approx0.1122334456}\nfor the vdW-DF3-opt1\n[3]\nnonlocal functional.\n\nThe complete\nINCAR\nfile for the nonlocal van der Waals functionals mentioned above can be found at\nNonlocal vdW-DF functionals\n.",
    "related_tags": [
      "PARAM2",
      "GGA",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "PARAM2": {
    "default_value": "PARAM2 = 1.0",
    "description": "κ {\\displaystyle \\kappa} for GGA =MK, or μ {\\displaystyle \\mu} for GGA =BO.",
    "detailed_description": "The\nPARAM2\ntag determines the value corresponding to different parameters depending on the\nGGA\nfunctional that is chosen:\n\nκ\n{\\displaystyle \\kappa}\nin the optB86b\n[1]\n(\nκ\n{\\displaystyle \\kappa}\nis not shown in this work since implicitly set to 1.0), B86R\n[2]\n, and DF3-opt2\n[3]\nexchange functionals, which have the same analytical form and correspond to\nGGA\n=MK.\nPARAM2\nshould in principle be set to 1.0 for the nonlocal optB86b-vdW functional\n[1]\n, to 0.711357 for the nonlocal rev-vdW-DF2\n[2]\nfunctional, or to\n0.58\n{\\displaystyle 0.58}\nfor the vdW-DF3-opt2 nonlocal functional\n[3]\n.\nμ\n{\\displaystyle \\mu}\nin the optB88\n[4]\nand DF3-opt1\n[3]\nexchange functionals, which have the same analytical form and correspond to\nGGA\n=BO.\nPARAM2\nshould in principle be set to 0.22 for the nonlocal optB88-vdW functional\n[4]\nor to\n10\n/\n81\n≈\n0.1234568\n{\\displaystyle 10/81\\approx0.1234568}\nfor the vdW-DF3-opt1\n[3]\nnonlocal functional.\n\nThe complete\nINCAR\nfile for the nonlocal van der Waals functionals mentioned above can be found at\nNonlocal vdW-DF functionals\n.",
    "related_tags": [
      "PARAM1",
      "GGA",
      "Nonlocal vdW-DF functionals"
    ]
  },
  "PFLAT": {
    "default_value": "",
    "description": "Control flag for the output of the profiling routines.",
    "detailed_description": "If specified as\nPMASS\n=\n.TRUE.\n, only the flat profile is printed out in the\nOUTCAR\n.\n\nExamples that use this tag",
    "related_tags": []
  },
  "PHON_BORN_CHARGES": {
    "default_value": "Default: PHON_BORN_CHARGES = None",
    "description": "PHON_BORN_CHARGES sets the Born effective charges to be used for the dipole-dipole corrections in the computation of the phonon dispersion. This is only used when LPHON_POLAR =.TRUE.",
    "detailed_description": "If the material is non-metallic and polar (i.e. two or more atoms in the unit cell carry nonzero Born effective charge tensors), a special treatment of the long-range dipole-dipole interaction is required to obtain a smooth phonon dispersion.\nThis is activated by setting\nLPHON_POLAR\n=.TRUE. and supplying the static dielectric tensor (\nPHON_DIELECTRIC\n) and the Born-effective charges (\nPHON_BORN_CHARGES\n) which can be obtained in a separate VASP calculation using the\nLEPSILON\nor\nLCALCEPS\ntag.\nThe dipole-dipole part of the interatomic force-constants is evaluated using an Ewald summation with the number of\nG\n{\\displaystyle \\mathbf{G}}\nvectors determined by the cutoff length (\nPHON_G_CUTOFF\n).\n\nMind:\nOnly available as of VASP 6.3.2.",
    "related_tags": [
      "QPOINTS",
      "LPHON_DISPERSION",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_G_CUTOFF"
    ]
  },
  "PHON_DIELECTRIC": {
    "default_value": "Default: PHON_DIELECTRIC = None",
    "description": "PHON_DIELECTRIC sets the static dielectric tensor to be used for the dipole-dipole corrections in the computation of the phonon dispersion. This is only used when LPHON_POLAR =.TRUE.",
    "detailed_description": "If the material is non-metallic and polar (i.e. two or more atoms in the unit cell carry nonzero Born effective charge tensors), a special treatment of the long-range dipole-dipole interaction is required to obtain a smooth phonon dispersion.\nThis is activated by setting\nLPHON_POLAR\n=.TRUE. and supplying the static dielectric tensor (\nPHON_DIELECTRIC\n) and the Born-effective charges (\nPHON_BORN_CHARGES\n) which can be obtained in a separate VASP calculation using the\nLEPSILON\nor\nLCALCEPS\ntag.\nThe dipole-dipole part of the interatomic force-constants is evaluated using an Ewald summation with the number of\nG\n{\\displaystyle \\mathbf{G}}\nvectors determined by the cutoff length (\nPHON_G_CUTOFF\n).\n\nMind:\nOnly available as of VASP 6.3.2.",
    "related_tags": [
      "QPOINTS",
      "LPHON_DISPERSION",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF"
    ]
  },
  "PHON_DOS": {
    "default_value": "Default: PHON_DOS = 0",
    "description": "Select the approach to use when computing the phonon density-of-states (DOS).",
    "detailed_description": "The possible values are\n\nPHON_DOS\nFunction\n0\nThe phonon DOS computation is not performed.\n1\nA gaussian broadening function with a width specified by\nPHON_SIGMA\nis used.\n2\nThe tetrahedron method is used.\n\nTo get a representative density of states the\nQPOINTS\nfile should specify a regular mesh.\nWhen line mode in the\nQPOINTS\nfile and gaussian smearing (PHON_DOS=1) is used, the phonon density of states will still be computed but the results are not reliable.\n\nMind:\nOnly available as of VASP 6.4.0.",
    "related_tags": [
      "QPOINTS",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF",
      "PHON_SIGMA",
      "PHON_NEDOS"
    ]
  },
  "PHON_G_CUTOFF": {
    "default_value": "Default: PHON_G_CUTOFF = 8.0",
    "description": "PHON_G_CUTOFF sets the cutoff radius in reciprocal space used to determine the number of G {\\displaystyle \\mathbf{G}} vectors involved in the Ewald sum in polar phonon calculations.",
    "detailed_description": "The Ewald sum that accounts for the long-range electrostatic interactions in phonon calculations runs over all G-vectors inside a cutoff sphere.\nThe radius of this sphere is given by\nPHON_G_CUTOFF\nas a multiple of the longest reciprocal lattice vector of the primitive cell (as detected by VASP).\nSpecifying the cutoff this way (as opposed to an absolute length or energy) ensures a default value that is relatively system-independent.\n\nThe default value of\nPHON_G_CUTOFF\nis a safe choice in most cases.\nLowering\nPHON_G_CUTOFF\ncan result in faster phonon calculations.\nHowever, ensure that the phonon spectrum is properly converged.\nIf you run into convergence problems, try raising the value until the phonon dispersion converges.\n\nFor more information on polar phonon calculations, see\nLPHON_POLAR\n.\n\nMind:\nOnly available as of VASP 6.3.2.",
    "related_tags": [
      "QPOINTS",
      "LPHON_DISPERSION",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES"
    ]
  },
  "PHON_LBOSE": {
    "default_value": "PHON_LBOSE = .TRUE.",
    "description": "Determines whether structures in the sampling are created according to Bose-Einstein or Maxwell-Boltzmann statistics.",
    "detailed_description": "For\nPHON_LBOSE\n=\n.TRUE.\nBose-Einstein statistics is used.\n\nFor\nPHON_LBOSE\n=\n.FALSE.\nMaxwell-Boltzmann statistics is used.\n\nFor further usage of this tag see:\nElectron-phonon interactions from Monte-Carlo sampling\n.\n\nImportant\n: This tag does not work together with\nPHON_NSTRUCT\n=0.\n\nMind:\nThis feature is available for VASP >= 6.0.",
    "related_tags": [
      "Electron-phonon interactions from Monte-Carlo sampling",
      "PHON_LMC",
      "PHON_NSTRUCT",
      "PHON_TLIST",
      "PHON_NTLIST",
      "TEBEG"
    ]
  },
  "PHON_LMC": {
    "default_value": "PHON_LMC = .FALSE.",
    "description": "Controls whether electron-phonon interactions from Monte-Carlo sampling are calculated or not.",
    "detailed_description": "For further usage of this tag see:\nElectron-phonon interactions from Monte-Carlo sampling\n.\n\nMind:\nThis feature is available for VASP >= 6.0.",
    "related_tags": [
      "Electron-phonon interactions from Monte-Carlo sampling",
      "PHON_NSTRUCT",
      "PHON_LBOSE",
      "PHON_NTLIST",
      "PHON_TLIST"
    ]
  },
  "PHON_NEDOS": {
    "default_value": "Default: PHON_NEDOS = 2000",
    "description": "Sets the number of frequency points to compute the phonon density of states.",
    "detailed_description": "The density of states is computed between\n[\nω\nmin\n−\n5\nσ\n,\nω\nmax\n+\n5\nσ\n]\n{\\displaystyle [\\omega_{\\text{min}}-5\\sigma,\\omega_{\\text{max}}+5\\sigma]}\nwith\nω\nmin\n{\\displaystyle \\omega_{\\text{min}}}\nand\nω\nmax\n{\\displaystyle \\omega_{\\text{max}}}\nthe lowest and highest phonon frequency and\nσ\n{\\displaystyle \\sigma}\nthe broadening\nPHON_SIGMA\n.\n\nMind:\nOnly available as of VASP 6.4.0.",
    "related_tags": [
      "QPOINTS",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF"
    ]
  },
  "PHON_NSTRUCT": {
    "default_value": "PHON_NSTRUCT = none",
    "description": "Sets the number of structures for electron-phonon interactions from Monte-Carlo (MC) sampling.",
    "detailed_description": "For\nPHON_NSTRUCT\n=-1 the eigenvalues and eigenvectors of the dynamic matrix are written to the file\nDYNMATFULL\n.\n\nFor\nPHON_NSTRUCT\n=0 the ZG configuration\n[1]\n(one-shot) method is executed.\n\nFor\nPHON_NSTRUCT\n>0 that many MC structures are prepared.\n\nFor further usage of this tag see:\nElectron-phonon interactions from Monte-Carlo sampling\n.\n\nMind:\nThis feature is available for VASP >= 6.0.",
    "related_tags": [
      "Electron-phonon interactions from Monte-Carlo sampling",
      "PHON_LMC",
      "PHON_LBOSE",
      "PHON_NTLIST",
      "PHON_TLIST",
      "TEBEG"
    ]
  },
  "PHON_NTLIST": {
    "default_value": "PHON_NTLIST = none",
    "description": "Sets the number of temperatures for the stochastic approach to electron-phonon interactions .",
    "detailed_description": "PHON_NTLIST\ncorresponds to the number of entries read from the list of temperatures defined by\nPHON_TLIST\n.\nFor a how-to on the\nstochastic approach to electron-phonon interactions\nsee\nElectron-phonon interactions from Monte-Carlo sampling\n.\n\nMind:\nThis feature is available for VASP >= 6.0.",
    "related_tags": [
      "Electron-phonon interactions from Monte-Carlo sampling",
      "PHON_LMC",
      "PHON_NSTRUCT",
      "PHON_TLIST",
      "PHON_LBOSE"
    ]
  },
  "PHON_NWRITE": {
    "default_value": "Default: PHON_NWRITE = 1",
    "description": "PHON_NWRITE determines how much output is written to the OUTCAR file when computing the phonon dispersion LPHON_DISPERSION =.TRUE.",
    "detailed_description": "Positive numbers mean human-readable output, and negative numbers mean one-line format. The available options are:\n\nPHON_NWRITE\nDescription\n2\nFor each q point, write the same as 1 and then the phonon modes with the displacement of each atom in the three cartesian directions per line.\n1\nFor each q point, q-point coordinates are written in one line and the phonon frequencies are written one branch per line in different units.\n0\nNo phonon output is written to OUTCAR.\n-1\nFor each q point, only a single line is written containing q-point coordinates and frequencies.\n-2\nFor each q point, q-point coordinates and frequencies are written in separate blocks and frequencies are reported in different units.\n-3\nLike -2, but in addition, the phonon eigenvectors are written for each q point.\n\nMind:\nOnly available as of VASP 6.3.2.",
    "related_tags": [
      "QPOINTS",
      "LPHON_DISPERSION",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF"
    ]
  },
  "PHON_SIGMA": {
    "default_value": "Default: PHON_SIGMA = 0.0005 eV",
    "description": "Set the width of the Gaussian function in eV to compute the phonon density of states.",
    "detailed_description": "The density of states is computed between\n[\nω\nmin\n−\n5\nσ\n,\nω\nmax\n+\n5\nσ\n]\n{\\displaystyle [\\omega_{\\text{min}}-5\\sigma,\\omega_{\\text{max}}+5\\sigma]}\nwith\nω\nmin\n{\\displaystyle \\omega_{\\text{min}}}\nand\nω\nmax\n{\\displaystyle \\omega_{\\text{max}}}\nthe lowest and highest phonon frequency and\nσ\n{\\displaystyle \\sigma}\nthe broadening\nPHON_SIGMA\n.\nThe number of energy points in this interval is set by\nPHON_NEDOS\n.\n\nMind:\nOnly available as of VASP 6.4.0.",
    "related_tags": [
      "QPOINTS",
      "PHON_NWRITE",
      "LPHON_POLAR",
      "PHON_DIELECTRIC",
      "PHON_BORN_CHARGES",
      "PHON_G_CUTOFF"
    ]
  },
  "PHON_TLIST": {
    "default_value": "PHON_TLIST = none",
    "description": "Provides the list of temperatures for that the electron-phonon interaction using the ZG configuration [1] is evaluated.",
    "detailed_description": "Also, the number of temperatures defined in\nPHON_NTLIST\nhas to be defined together with this tag.\n\nFor further usage of this tag see:\nElectron-phonon interactions from Monte-Carlo sampling\n.\n\nMind:\nThis feature is available for VASP >= 6.0.",
    "related_tags": [
      "Electron-phonon interactions from Monte-Carlo sampling",
      "PHON_LMC",
      "PHON_NSTRUCT",
      "PHON_NTLIST"
    ]
  },
  "PLEVEL": {
    "default_value": "",
    "description": "Control tag for the output of the profiling routines.",
    "detailed_description": "If specified all routines with a level higher than\nPLEVEL\n=\nlevel\nare not printed out in the\nOUTCAR\n.\n\nExamples that use this tag",
    "related_tags": []
  },
  "PMASS": {
    "default_value": "PMASS = 1000",
    "description": "PMASS assigns a fictitious mass (in amu) to the lattice degrees-of-freedom in case of Parrinello-Rahman dynamics (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "When running\nNpT\nsimulations with a\nLangevin thermostat\n[1]\n(\nMDALGO\n=3), using the method of\nParrinello and Rahman\n,\n[2]\n[3]\na fictitious mass (in amu) for the lattice degrees-of-freedom has to be assigned using the\nPMASS\ntag.\nThe friction coefficient for lattice degrees-of-freedom have to be specified (in ps\n-1\n) by means of the\nLANGEVIN_GAMMA_L\ntag.\n\nThe friction coefficients γ for the atomic degrees-of-freedom are specified using the\nLANGEVIN_GAMMA\ntag.\n\nThe optimal setting for\nPMASS\ndepends very much on the particular system at hand and can be considered as a compromise between two opposing factors: too large values lead to very slow variation of lattice degrees of freedom (and hence the sampling becomes inefficient) while too small value can lead to too large geometric changes in an MD step and hence may cause numerical problems. We strongly recommend to make careful tests with various settings before performing the production run.",
    "related_tags": [
      "LANGEVIN_GAMMA_L",
      "LANGEVIN_GAMMA",
      "MDALGO"
    ]
  },
  "POMASS": {
    "default_value": "POMASS = values read from POTCAR",
    "description": "Array of masses of the atoms in atomic units.",
    "detailed_description": "POMASS\ndetermines the atomic mass of each atomic species. For standard calculations this tag should be omitted since the atomic masses for each species are read from the\nPOTCAR\nfile (they are also called\nPOMASS\nthere). However if one needs to change the atomic mass of some species, e.g., the mass of Hydrogen atoms in\nmolecular dynamics\ncalculations, the atomic masses of all species need to be set with this tag in the order they appear on the\nPOTCAR\nfile. After setting\nPOMASS\nto different values in the\nINCAR\nfile than on the\nPOTCAR\nfile the following message will occur on stdout when running VASP, informing the user that the mass has changed:\n\nWARNING: mass on POTCAR and INCAR are incompatible.\n\nIf any incompatibilities exist, e.g. the number of entries doesn't agree with that on the\nPOTCAR\n, VASP will stop.\n\nRelated tags and sections\n\nZVAL\n\nExamples that use this tag",
    "related_tags": []
  },
  "POSNICS": {
    "default_value": "",
    "description": "",
    "detailed_description": "",
    "related_tags": [
      "LCHIMAG",
      "NUCIND",
      "LPOSNICS"
    ]
  },
  "POTIM": {
    "default_value": "Default: POTIM = none, must be set if IBRION = 0 (MD) | = 0.5 if IBRION = 1, 2, and 3 (ionic relaxation), and 5 (up to VASP.4.6) | = 0.015 if IBRION =5, and 6 (as of VASP.5.1)",
    "description": "POTIM sets the time step in molecular dynamics or the step width in ionic relaxations.",
    "detailed_description": "For\nIBRION\n= 0,\nPOTIM\ngives the time step (in fs) in all ab-initio Molecular Dynamics runs, it\nhas\nto be supplied therefore, otherwise VASP crashes immediately after having started.\n\nFor\nIBRION\n=1, 2, and 3, which corresponds to ionic relaxation using a quasi-Newton algorithm, conjugate-gradient algorithm, and damped molecular dynamics, respectively, the\nPOTIM\ntag serves as a scaling constant for the step widths. The quasi-Newton algorithm is especially sensitive to the choice of this parameter.\n\nFor\nIBRION\n= 5, and 6, a phonon calculations using the finite differences approach is done, where\nPOTIM\nis the width of the displacement of each ion to calculate the Hessian Matrix.\n\nVASP.4.6 and older releases:\nPOTIM\nhas to be small enough to ensure that the displacements are within the harmonic limit. The vibrational frequencies using the frozen phonon approach are based on the harmonic approximation.\n\nMind:\nFor VASP.5.1 and newer releases,\nPOTIM\nis automatically reset to 0.015 Å, if the supplied value for\nPOTIM\nis unreasonably large.",
    "related_tags": [
      "structure optimization",
      "IBRION",
      "NFREE"
    ]
  },
  "PREC": {
    "default_value": "Default: PREC = Medium for VASP.4.X | = Normal since VASP.5.X",
    "description": "PREC specifies the \"precision\" mode.",
    "detailed_description": "PREC\nsets default values for the energy cutoff\nENCUT\n, the FFT grids (\nNGX\n,\nNGY\n,\nNGZ\n) and (\nNGXF\n,\nNGYF\n,\nNGZF\n), and the accuracy of the projectors in real space\nROPT\n(used only when\nLREAL\n=.TRUE.). Details are given below in the table.\n\nWe recommend using\nPREC\n=Normal or\nPREC\n=Accurate.\nPREC\n=Normal can be used for most routine calculations.\nPREC\n=Accurate leads to a denser grid (\nNGX\n,\nNGY\n,\nNGZ\n). Thus, it reduces egg-box effects and strictly avoids any\naliasing/wrap-around errors\n.\nPREC\n=Normal and\nPREC\n=Accurate use an augmentation fine grid (\nNGXF\n,\nNGYF\n,\nNGZF\n) that is twice larger than the grid (\nNGX\n,\nNGY\n,\nNGZ\n) used for the representation of the pseudo-orbitals.\nPREC\n=Accurate increases the memory requirements somewhat, but it should be used (in combination with an increased value for\nENCUT\n) when a very good accuracy is required, e.g., for accurate forces, for phonons and stress tensor or in general when second derivatives are computed. The accuracy of forces can also be sometimes further improved by specifying\nADDGRID\n=.TRUE., however, reports from users are somewhat contradictory about whether this really helps.\n\nMind:\nThe value of a parameter set by\nPREC\n(e.g.,\nENCUT\n) can be overridden by specifying explicitly the value of that parameter in the\nINCAR\nfile.\nPREC\n=Normal and\nPREC\n=Accurate are only available in VASP.4.5 and newer versions. The setting\nPREC\n=Single is only available as of VASP.5.1, and has been updated in VASP.6.\n\nDeprecated:\nThe old settings\nPREC\n=Medium and\nPREC\n=High are no longer recommended and are available (as well as\nPREC\n=Low) only for backward compatibility. Essentially,\nPREC\n=High only increases the energy cutoff by 30 %, which can also be achieved by just manually increasing\nENCUT\n.\n\nImportant:\nSetting\nPREC\n=Accurate does not necessarily mean that the results are converged. The convergence of the results with respect to the energy cutoff\nENCUT\nhas to be checked separately.\nWe strongly recommend specifying the energy cutoff\nENCUT\nalways manually in the\nINCAR\nfile to ensure the same accuracy between calculations. Otherwise, the default\nENCUT\nmay differ among the different calculations (e.g., for the calculation of the cohesive energy), with the consequence that the total energies, for instance, can not be compared.\nSetting\nENAUG\nhas an effect only if\nPREC\nis set to one of the deprecated settings (Low, Medium or High); otherwise, it is ignored.\n\nDefault values set by\nPREC\n\nDefault values set by\nPREC\nfor the parameters\nENCUT\n, (\nNGX\n,\nNGY\n,\nNGZ\n), (\nNGXF\n,\nNGYF\n,\nNGZF\n) and\nROPT\n:\n\nPREC\nENCUT\nNGX\n,\nY\n,\nZ\nNGXF\n,\nYF\n,\nZF\nROPT\n(\nLREAL\n=A)\nROPT\n(\nLREAL\n=O)\nNormal\nmax(\nENMAX\n)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGX\n-5×10\n-4\n1.0\nSingle (VASP.5)\nmax(\nENMAX\n)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGX\n-5×10\n-4\n1.0\nSingle (VASP.6)\nmax(\nENMAX\n)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGX\n-5×10\n-4\n1.0\nSingleN (VASP.6)\nmax(\nENMAX\n)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nNGX\n-5×10\n-4\n1.0\nAccurate\nmax(\nENMAX\n)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n2×\nNGX\n-2.5×10\n-4\n1.0\nDeprecated settings:\nLow\nmax(\nENMIN\n)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\n-1×10\n-2\n2/3\nMedium\nmax(\nENMAX\n)\n3/2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n4×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\n-2×10\n-3\n1.0\nHigh\n1.3×max(\nENMAX\n)\n2×\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\n16/3×\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\n-4×10\n-4\n1.5\n\nwhere max(\nENMAX\n) and max(\nENMIN\n) are the maxima of\nENMAX\nand\nENMIN\nfound in the\nPOTCAR\nfile, and\nG\nc\nu\nt\n{\\displaystyle G_{\\rm cut}}\nand\nG\na\nu\ng\n{\\displaystyle G_{\\rm aug}}\nare defined by\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\nE\na\nu\ng\n=\nℏ\n2\n2\nm\ne\nG\na\nu\ng\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2 \\qquad E_{\\rm aug}=\\frac{\\hbar^2}{2m_e}G_{\\rm aug}^2}\n\nwith\nE\nc\nu\nt\n{\\displaystyle E_{\\rm cut}}\n=\nENCUT\nand\nE\na\nu\ng\n{\\displaystyle E_{\\rm aug}}\n=\nENAUG\n.\n\nFurther remarks\n\nWith\nPREC\n=Normal, Single, and Accurate the grid (\nNGXF\n,\nNGYF\n,\nNGZF\n) representing the augmentation charges, charge densities and potentials has either the same size (\nPREC\n=Single) or the double size (\nPREC\n=Normal or Accurate) as the grid (\nNGX\n,\nNGY\n,\nNGZ\n). With the deprecated (and no longer recommended) settings for\nPREC\n(Low, Medium and High), the grid (\nNGXF\n,\nNGYF\n,\nNGZF\n) is determined by some heuristic formula from\nENAUG\n.\n\nPREC\n=Single uses the same grid (\nNGX\n,\nNGY\n,\nNGZ\n) as\nPREC\n=Normal in VASP.5, but the same grid as\nPREC\n=Accurate in VASP.6. However, the double grid technique is not used, i.e., (\nNGXF\n,\nNGYF\n,\nNGZF\n)=(\nNGX\n,\nNGY\n,\nNGZ\n). This is convenient if one needs to cut down on storage demands or if one wants to reduce the size of the files\nCHG\nand\nCHGCAR\n. Furthermore,\nPREC\n=Single avoids high-frequency oscillations caused by the double-grid technique and the resulting Fourier interpolation. It is often expedient for scanning tunneling simulations or other calculations where high-frequency wiggles of the charge density in the vacuum region are undesirable.\n\nPREC\n=Medium and\nPREC\n=Normal should usually be sufficiently accurate and lead to errors of less than 1 meV/atom.\n\nPREC\n=High should guarantee that the absolute energies are converged to a few meV and the stress tensor converged within a few kBar.",
    "related_tags": [
      "NGX",
      "NGY",
      "NGZ",
      "NGXF",
      "NGYF",
      "NGZF",
      "ENCUT",
      "ENAUG",
      "ENMIN",
      "ENMAX",
      "ROPT",
      "LREAL",
      "ADDGRID",
      "PRECFOCK"
    ]
  },
  "PRECFOCK": {
    "default_value": "Default: PRECFOCK = Fast for RPAR calculations | = Single if PREC =Single or SingleN | = Normal else",
    "description": "PRECFOCK controls the FFT grids used in the exact exchange routines (Hartree-Fock and hybrid functionals).",
    "detailed_description": "The FFT grid used for the exact exchange contributions can be chose to be different from the one used for the Hartree and DFT potentials. Information on the  FFT grid that is used in the exact Fock exchange routines is written to the\nOUTCAR\nfile after the lines\n\nFFT grid for exact exchange (Hartree Fock)\n\nWe recommend to set\nPRECFOCK\n=Normal for routine calculations.\nIf speed is an issue, you can also use\nPRECFOCK\n=Fast (e.g. use this to pre-converge the orbitals). For very high precision, in particular for phonon calculations,\nPRECFOCK\n=Accurate is recommended.\nThe two setting,\nPRECFOCK\n=Medium and\nPRECFOCK\n=Low are not recommended, but have been kept to maintain compatibility with older VASP versions.\n\nGenerally, as opposed to gradient corrected density functionals, the exact exchange energy is rather insensitive to the FFT grids, and in many cases a rather coarse grid can be used to calculate the overlap densities and the exact exchange (Fock) potential.\nExact exchange\nrequires one to evaluation the overlap density\n\nψ\nk\nn\n∗\n(\nr\n)\nψ\nq\nm\n(\nr\n)\n{\\displaystyle \\psi_{\\mathbf{k}n}^{*}(\\mathbf{r})\\psi_{\\mathbf{q}m}(\\mathbf{r})}\n\nbetween two orbitals. Strictly speaking, errors in the convolution (aliasing errors) are only avoided, if the FFT grid contains all Fourier components up to twice the plane wave with the largest wave vector, 2|G\ncut\n|. As usual, |G\ncut\n| is determined by the plane wave cutoff (\nENCUT\n). \nA grid avoiding aliasing errors is chosen by setting\nPRECFOCK\n=Accurate. In this case, the FFT grid for the exact exchange is identical to the FFT grid used for the orbitals for\nPREC\n=Accurate in the DFT part.\nPRECFOCK\n=Accurate is the recommended setting for very accurate calculations.\n\nFor\nPRECFOCK\n=Low and Fast, the smallest possible FFT grid that just encloses the cutoff sphere (G\ncut\n|) is used. This accelerates the calculations by roughly a factor two to three, but causes slight errors in the total energies and some noise in the calculated forces. To reduce the noise, the augmentation charges\nare made very soft for\nPRECFOCK\n=Fast (whereas\nPRECFOCK\n=Low uses the standard augmentation charges also used for DFT).\n\nFor\nPRECFOCK\n=Normal, the FFT grid for the exact exchange is identical to the FFT grid used for the orbitals for\nPREC\n=Normal in the DFT part. In this case, the grid density is between the ones for\nPRECFOCK\n=Accurate and\nPRECFOCK\n=Fast. This is often a very reasonable comprise and hence recommended for most routine calculations.\n\nFor\nPRECFOCK\n=Fast, Normal and Accurate, the augmentation charges (required to restore the norm and dipoles of the overlap density on the plane wave grid) are softened, such that an accurate presentation on the plane wave grid is possible even for relatively coarse FFT grids. The sphere size is printed out after\n\nRadii for the augmentation spheres in the nonlocal exchange\n\nSince VASP always uses one-center terms to correct for the difference between all-electron and pseudo orbitals, the precise shape of the augmentation charges matters little for exchange \nenergies. Still it is recommended to keep PRECFOCK and PREC the same if relative energies are calculated (for instance adsorption energies, energies differences between different phases, etc.).\n\nThe following table summarizes the possible setting:\n\nPRECFOCK\nFFT-grid\nAugmentation charge\nQuality\nComment\nNormal\n3/2×G\ncut\nidentical to std. FFT for PREC=Normal\nsoft augmentation charge\na\naccurate forces and energy\ngood compromise\nAccurate\n2×G\ncut\nidentical to std. FFT for PREC=Accurate\nsoft augmentation charge\na\nvery accurate forces and energy\nfor phonons\nFast\nG\ncut\nd\nvery soft augmentation charge\nb\nsome noise in forces/good energy\nneed for speed\nMedium\nstrictly identical to std. FFT\nidentical to standard DFT\nidentical to standard DFT\noutdated\nSingle\nc\nstrictly identical to std. FFT\nidentical to standard DFT\nidentical to standard DFT\nif compatibility between Hartree and exchange is desired\nLow\nG\ncut\nidentical to standard DFT\nlarge noise in forces/energy errors\noutdated\na\nradius for augmentation sphere is increased by factor 1.25 compared to default.\nb\nradius is increased by factor 1.35 compared to default except for\ns\n-like charge; for the\ns\n-channel the radius of the augmentation sphere is increased by a factor 1.25.\nc\nif user selects\nPREC\n= Single or\nPREC\n= SingleN, the default for PRECFOCK also becomes Single.\n\nMedium and Single are synonyms. They are useful the select the same treatment for the Hartree  and exchange term. This can be advantageously for correlated wave function calculations to obtain a numerically exact balance and compensation between Hartree and exchange (for instance for the upcoming auxiliary field Monte-Carlo module in VASP). For conventional Hartree-Fock or hybrid functional calculations, Normal or Accurate should be used.\n\nIn this table, G\ncut\nis determined by the relation\n\nE\nc\nu\nt\n=\nℏ\n2\n2\nm\ne\nG\nc\nu\nt\n2\n{\\displaystyle E_{\\rm cut}=\\frac{\\hbar^2}{2m_e}G_{\\rm cut}^2}\n\nwith E\ncut\n=\nENCUT\n.\n\nEven\nPRECFOCK\n=Fast yields fairly low noise in the forces and virtually no egg-box effects (aliasing errors). In the forces, the noise is usually below 0.01 eV/Å. For\nPRECFOCK\n=N and\nPRECFOCK\n=A, noise is usually not an issue, and the accuracy is sufficient even for phonon calculations in large supercells.\n\nAny combination of\nPREC\nand\nPRECFOCK\nis allowed by the code. Useful settings of increasing precision are however:\n\nPREC = Normal ; PRECFOCK = Fast       ! if your are in need for speed\nPREC = Normal ; PRECFOCK = Normal     ! the default\nPREC = Accurate ; PRECFOCK = Normal   ! increase the precision for DFT part; since exchange dominates the compute time, only slightly slower\nPREC = Accurate ; PRECFOCK = Accurate ! highest accuracy, suggested for phonons",
    "related_tags": [
      "PREC",
      "ENCUT",
      "List of hybrid functionals",
      "Hybrid functionals: formalism"
    ]
  },
  "PROUTINE": {
    "default_value": "",
    "description": "Control flag for the output of the profiling routines.",
    "detailed_description": "If specified only the routine with the name\nPROUTINE\n=\nroutine\nis taken into account.\n\nExamples that use this tag",
    "related_tags": []
  },
  "PSTRESS": {
    "default_value": "PSTRESS = 0",
    "description": "Sets the external pressure in kB or adds corrections to the stress tensor.",
    "detailed_description": "The unit of\nPSTRESS\nis kB.\n\nDuring\nionic minimization\n, an energy term\nE\n=\nV\n×\nP\nS\nT\nR\nE\nS\nS\n{\\displaystyle  E= V \\times \\mathrm{PSTRESS} }\nis added to the total energy and the value of\nPSTRESS\nis subtracted from  the diagonals of the stress tensor. This allows to perform structure optimization at a specific external pressure.\n\nIn\nmolecular-dynamics calculations\nwithin the\nNpT ensemble\n,\nPSTRESS\ncontrols the target pressure for the Parinello-Rahman\n[1]\n[2]\nbarostat.\n\nGenerally, if a negative value is supplied, the system is under effective tensile strain and during relaxations (or molecular dynamics simulations) the volume \nwill increase. If a positive value is supplied, the system is under compressive strain; this will decrease the volume during relaxations and molecular dynamics simulations.\n\nPSTRESS\ncan also be used to correct errors caused by the Pulay stress, i.e., errors in the calculated stress tensor caused by the incomplete plane wave basis set. To correct for Pulay-stress errors, set\nPSTRESS\nto the negative value of the Pulay stress. The Pulay stress is computed by taking the difference between the external pressure at the desired cutoff and a very large energy cutoff (check the  lines 'external pressure' in the\nOUTCAR\nfile and calculate \npressure at cutoff you want to use\n−\n{\\displaystyle  -  }\npressure at large cutoff; this must be a negative value). Before using this tag in this manner, please read the following section carefully:\nVolume relaxation\n.\n\nExamples that use this tag\n\n↑\nM. Parrinello and A. Rahman, Phys. Rev. Lett.\n45\n, 1196 (1980).\n↑\nM. Parrinello and A. Rahman, J. Appl. Phys.\n52\n, 7182 (1981).",
    "related_tags": []
  },
  "PSUBSYS": {
    "default_value": "",
    "description": "PSUBSYS sets the collision probabilities for the atoms in each atomic subsystem in calculations with multiple Anderson thermostats (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "Up to three user-defined atomic subsystems may be coupled with independent Andersen thermostats\n[1]\n(\nMDALGO\n=13).\n\nThe collision probabilities for the atoms in each atomic subsystem is set by means of the\nPSUBSYS\ntag (one has to specify one number for each subsystem).\n\nNote: 0 ≤\nPSUBSYS\n≤ 1\n\nRelated Tags and Sections\n\nNSUBSYS\n,\nTSUBSYS\n,\nMDALGO\n\nExamples that use this tag\n\nReferences\n\n↑\nH. C. Andersen, J. Chem. Phys. 72, 2384 (1980).",
    "related_tags": []
  },
  "PTHRESHOLD": {
    "default_value": "",
    "description": "Control flag for the output of the profiling routines.",
    "detailed_description": "If specified all routines with less execution time than\nPTHRESHOLD\n=\ntime\nare not printed out in the\nOUTCAR\nfile.\n\nExamples that use this tag",
    "related_tags": []
  },
  "Profiling": {
    "default_value": "",
    "description": "",
    "detailed_description": "",
    "related_tags": []
  },
  "QMAXFOCKAE": {
    "default_value": "",
    "description": "Controls at which wave vectors the local augmentation charges are fitted to obtain an accurate charge augmentation on the plane-wave grid.",
    "detailed_description": "We do not recommend setting these tags manually, except after careful inspection of the VASP code (fast_aug.F). The default values are 6.0 Å\n-1\nif\nNMAXFOCKAE\n=1 (corresponding to 140 eV), and 5.0 and 10 Å\n-1\n(corresponding to 95 eV and 380 eV) for\nNMAXFOCKAE\n=2.",
    "related_tags": [
      "NMAXFOCKAE",
      "LMAXFOCKAE",
      "LFOCKAEDFT"
    ]
  },
  "QSPIRAL": {
    "default_value": "QSPIRAL = 3*0.0",
    "description": "the QSPIRAL -tag specifies the spin spiral propagation vector.",
    "detailed_description": "QSPIRAL\nspecifies the spin spiral propagation vector in direct coordinates of the reciprocal lattice.\n\nSee the\ndescription of spin spiral calculations\nfor more details.",
    "related_tags": [
      "Spin spirals",
      "LSPIRAL",
      "LZEROZ"
    ]
  },
  "QUAD_EFG": {
    "default_value": "QUAD_EFG = NTYP*1.0",
    "description": "nuclear quadrupole moment (in millbarn) for the atomic types on the POTCAR file.",
    "detailed_description": "Setting the\nQUAD_EFG\ntag allows the conversion of the\nV\nzz\n(see\nLEFG\n) values into the quadrupole coupling constants\nC\nq\noften encountered in NMR literature.\nThe conversion formula is as follows (\nQ\nis the element and isotope specific quadrupole moment):\n\nC\nq\n=\ne\nQ\nV\nz\nz\nh\n.\n{\\displaystyle \nC_q = \\frac{e Q V_{zz}}{h}.\n}\n\nTip:\nSeveral definitions of\nC\nq\n{\\displaystyle  C_q}\nare used in the NMR community.\n\nThe\nQUAD_EFG\ntag specifies the nuclear quadrupole moment in millibarns for each atomic species, in the same\norder as in the\nPOTCAR\nfile. The output\nC\nq\nis in MHz. An online compilation of nuclear quadrupole moments can be found online in a database\n[1]\nor in Ref.\n[2]\n(updated numbers in Ref.\n[3]\n).\n\nSuppose a solid contains Al, C, and Si, then the\nQUAD_EFG\ntag could read:\n\nQUAD_EFG = 146.6 33.27 0.0\n\n27\nAl is the stable isotope of Al with a natural abundance of 100% and\nQ\n=146.6.\nThe stable isotopes\n12\nC and\n13\nC are not quadrupolar nuclei, however, the radioactive\n11\nC is. It has\nQ\n=33.27. For Si, all stable isotopes have I≤1/2, making it redundant to calculate a\nC\nq\n. No moments are known for the other isotopes.\n\nImportant:\nFor heavy nuclei inaccuracies are to be expected because of an incomplete treatment of relativistic effects.",
    "related_tags": [
      "LEFG"
    ]
  },
  "RANDOM_SEED": {
    "default_value": "RANDOM_SEED = based on the system clock",
    "description": "RANDOM_SEED specifies the seed of the random-number generator (compile VASP with -Dtbdyn ).",
    "detailed_description": "The random-number generator (RNG) generates a sequence of random numbers, which is initialized by the tag\nRANDOM_SEED\n.\nFor example, in molecular dynamics simulations, the RNG can be used to initialize atomic velocities. Hence, the seed for the RNG influences the trajectory of a molecular dynamics simulation.\nThe three integers of\nRANDOM_SEED\nmust fulfill these conditions:\n\n0 <= RANDOM_SEED(1) < 900000000\n0 <= RANDOM_SEED(2) < 1000000\n0 <= RANDOM_SEED(3)\n\nA typical input for the\nRANDOM_SEED\nlooks like this:\n\nRANDOM_SEED\n=         248489752                0                0\n\nThe initial value of\nRANDOM_SEED\nand the value after each MD step are written to the\nREPORT\nfile.\n\nTip:\nIf multiple molecular dynamics runs with different random seeds result in inconsistent time averages, then not enough configurations were sampled. Hence, longer or more trajectories are required to get converged ensemble averages.\n\nMind:\nIf no\nRANDOM_SEED\nis set in the\nINCAR\nthen the used value will depend on the system time. For example, in molecular dynamics simulations, initial velocities will be different each time VASP is executed (if\nTEBEG\nis used and no velocities are provided in the\nPOSCAR\nfile). Hence, the trajectories will diverge. If reproducibility is desired the\nRANDOM_SEED\nhas to be set manually.",
    "related_tags": [
      "IBRION",
      "MDALGO"
    ]
  },
  "ROPT": {
    "default_value": "Default: ROPT = -5E-4 if LREAL =Auto and PREC =Normal | = -5E-4 if LREAL =Auto and PREC =Single or SingleN | = -2.5E-4 if LREAL =Auto and PREC =Accurate | = -0.01 if LREAL =Auto and PREC =Low | = -0.002 if LREAL =Auto and PREC =Medium | = -4E-4 if LREAL =Auto and PREC =High",
    "description": "ROPT determines how accurately the projectors are represented in real space. With LREAL =On, the real space projectors are optimized using an algorithm proposed by King-Smith et al. [1] LREAL =Auto [2] is the recommended scheme since it is considerably more accurate, resulting in more localized projector functions than with the King-Smith et al. method.",
    "detailed_description": "Mind:\nWhether the user supplies negative or positive values in the INCAR file is irrelevant. With\nLREAL\n=Auto and On,\nROPT\nare internally set to negative and positive values, respectively.\nLREAL\n=On is outdated and should be only used, if compatibility to old calculations is desired.\n\nDepending on their value, VASP interprets\nROPT\nentries in one of two ways:\n\nABS|\nROPT\n| ≥ 0.1: \"conventional\"-mode:\n\nSets the number of real space points within the cutoff sphere for a particular species to approximately 1000×\nROPT\n. So for instance, the line\n\nROPT\n= 0.7 1.5\n\nwill set the number of real space points within the cutoff sphere for the first species to approximately 700, and that for the second species to 1500.\n\nABS|\nROPT\n| < 0.1 : \"precision\"-mode:\n\nIn this case, the real-space operators will be optimized for an accuracy of approximately\nROPT\neV/atom.  So, for instance specifying the following line in the\nINCAR\nfile\n\nROPT\n= 1E-3 1E-3\n\ntells VASP to optimize the real-space projector operators for species 1 and 2 for an accuracy of approximately 1 meV/atom (10\n-3\n). The estimate is, however, fairly rough: this means that even if an error of say 0.5 meV/atom is selected, the actual error might well approach 5 meV/atom for transition metals with many electrons. It is recommended to first perform reference calculations using\nLREAL\n=.FALSE., then switch to\nLREAL\n=Auto and decrease\nROPT\nuntil the desired accuracy is reached.\n\nThe \"precision\" and \"conventional\" modes may be intermixed, i.e., it is possible to specify\n\nROPT\n= 0.7 -1E-3\n\nIn this case, the number of real space points within the cutoff sphere for the first species will be approximately 700, whereas the real space projector functions for the second species are optimized for an accuracy of approximately 1 meV. We recommend to use the \"precision\" mode with a target accuracy of around 2x10\n-4\n- 10\n-3\neV/atom.\n\nIf you use the \"conventional\" mode, in which the number of grid points in the real space projection sphere is specified, you have to select\nROPT\ncarefully, especially if a hard species is mixed with a soft species. In that case the following lines in the\nOUTCAR\nfile must be checked (here is the output for\nLREAL\n=Auto, however, the one for\nLREAL\n=On is quite similar)\n\nOptimization of the real space projectors\nmaximal supplied QI-value         = 13.98\noptimisation between [QCUT,QGAM] = [  8.81, 17.62] = [ 21.73, 86.94] Ry\nOptimized for a Real-space Cutoff    1.41 Angstroem\n  l    n(q)    QCUT    max X(q) W(low)/X(q) W(high)/X(q)  e(spline)\n  2      6     8.810    59.645    0.61E-03    0.18E-02    0.11E-06\n  2      6     8.810    58.460    0.65E-03    0.19E-02    0.12E-06\n  0      7     8.810    97.683    0.18E-02    0.15E-03    0.13E-06\n  0      7     8.810    53.223    0.17E-02    0.15E-03    0.12E-06\n  1      7     8.810    13.596    0.47E-02    0.65E-02    0.33E-06\n  1      7     8.810     7.885    0.35E-02    0.48E-02    0.25E-06\n\nQCUT\nand\nQGAM\nare parameters chosen for the generation of this particular PAW dataset (or ultrasoft pseudopotential). The most important information is given in the columns\nW(low)/X(q)\nand\nW(high)/X(q)\nfor\nLREAL\n=Auto). In these columns, the values  must be as small as possible. If these values are too large increase the\nROPT\nvalue from the default value (or decrease it if it smaller than 0.1). As a rule of thumb, the maximum allowed value in this column is 10\n-3\nfor\nPREC\n=Normal. (For\nPREC\n=Low errors might be around 10\n-2\n. If W(q)/X(q) is larger than 10\n-2\nthe errors introduced by the real space projections can be substantial. In this case\nROPT\nmust be specified in the\nINCAR\nfile to avoid incorrect results.\n\nRelated tags and sections\n\nLREAL\n,\nPREC\n\nExamples that use this tag\n\nReferences\n\n↑\nR. D. King-Smith, M. C. Payne, and J. S. Lin,\nReal-space implementation of nonlocal pseudopotentials for first-principles total-energy calculations\n, Phys. Rev. B\n44\n, 13063 (1991).\n↑\nG. Kresse, Unpublished.",
    "related_tags": []
  },
  "RSMBJ": {
    "default_value": "RSMBJ = 7",
    "description": "sets the r s t h {\\displaystyle r_{s}^{\\mathrm{th}}} parameter (in bohr) in the LMBJ potential.",
    "detailed_description": "See the description of the\nMETAGGA\ntag.",
    "related_tags": [
      "METAGGA",
      "CMBJ",
      "CMBJA",
      "CMBJB",
      "CMBJE",
      "SMBJ",
      "LASPH",
      "LMAXTAU",
      "LMIXTAU"
    ]
  },
  "RWIGS": {
    "default_value": "RWIGS = -1",
    "description": "RWIGS specifies the Wigner-Seitz radius (in Å {\\displaystyle \\AA} ) for each atom type.",
    "detailed_description": "RWIGS\nhas\nto be supplied for each atom type if\nLORBIT\nis set to <10. In this case,  the\nspd\n- and site projected wave function character of each band is evaluated, and the local partial DOS (see sections\nPROCAR\nand\nDOSCAR\n) and local magnetic moments are calculated.\n\nIf\nLORBIT\n>= 10,\nRWIGS\nis ignored\n\nRWIGS\nmust\nbe set in calculations with constraining the local magnetic moments (see\nI_CONSTRAINED_M\n)\n\nFor\nmono-atomic systems\nRWIGS\ncan be defined\nunambiguously. The sum of the volume of the spheres around each atom should be\nthe same as the total volume of the cell (assuming that you do not have a\nvacuum region within your cell).  This is in the spirit of atomic sphere calculations.\nVASP writes a line\n\nVolume of Typ   1:     98.5 %\n\nto the\nOUTCAR\nfile. You should use a\nRWIGS\nvalue which yields a\nvolume of approximately 100%.\n\nFor systems consisting of\nmore than one atom type\n, there is no unambiguous way to define\nRWIGS\nand\nseveral choices are possible.  In all cases, the sum of\nthe volume of the spheres should be close to the total\nvolume of the cell (i.e the sum of the values given by VASP should be\naround 100%).\n\nOne possible choice is to set\nRWIGS\nsuch that the overlap between the spheres is minimized.\n\na more elaborate way is to apply a Bader-type charge analysis to estimate the radius of an atom in a specific compound.\n\nin most cases, it is simplest to choose the radius of each sphere such that they are close to the covalent radius as tabulated in most periodic tables. This simple criterion can be used in most cases, and it relies at least on some ``physical intuition\n.\n\nPlease keep in mind that results are\nqualitative\ni.e. there is no unambiguous way to determine the location of an electron\n(and hence the local magnetic moments). With the current implementation, it is for instance\nhardly possible to determine charge transfer. What can be derived from the partial DOS is the typical character of a peak in a DOS.\nQuantitative results can be obtained only by careful comparison with a reference system  (e.g. bulk versus surface).",
    "related_tags": [
      "LORBIT",
      "I_CONSTRAINED_M",
      "Spin spirals"
    ]
  },
  "SAXIS": {
    "default_value": "SAXIS = (0, 0, 1)",
    "description": "Set the global spin-quantization axis w.r.t. Cartesian coordinates.",
    "detailed_description": "SAXIS\nspecifies the relative orientation of spinor space spanned by the Pauli matrices\n{\nσ\n1\n{\\displaystyle \\{\\sigma_1}\n,\nσ\n2\n{\\displaystyle \\sigma_2}\n,\nσ\n3\n}\n{\\displaystyle \\mathbf{\\sigma}_3\\}}\nwith respect to Cartesian coordinates\n{\nx\n^\n,\ny\n^\n,\nz\n^\n}\n{\\displaystyle \\{\\hat x, \\hat y, \\hat z\\} }\n. The default is\nσ\n1\n=\nx\n^\n{\\displaystyle \\sigma_1=\\hat x}\n,\nσ\n2\n=\ny\n^\n{\\displaystyle \\sigma_2 =\\hat y}\n,\nσ\n3\n=\nz\n^\n{\\displaystyle \\sigma_3 = \\hat z}\n.\nThe direction of the spin-quantization axis\nσ\n3\n{\\displaystyle \\sigma_3}\nwith respect to Cartesian coordinates is set\n\nSAXIS\n=   s\nx\ns\ny\ns\nz\n! global spin-quantization axis\n\nsuch that\nσ\n3\n=\ns\n/\n|\ns\n|\n{\\displaystyle \\sigma_3=\\mathbf{s}/|\\mathbf{s}|}\n, i.e.,\nσ\n3\n{\\displaystyle \\sigma_3}\npoints along\ns\n=\n(\ns\nx\n,\ns\ny\n,\ns\nz\n)\nT\n{\\displaystyle \\mathbf{s}=(s_x,s_y,s_z)^T}\n. The directions of\nσ\n1\n{\\displaystyle \\sigma_1}\nand\nσ\n2\n{\\displaystyle \\sigma_2}\nare a consequence of rotating\nσ\n3\n{\\displaystyle \\sigma_3}\nto point along\ns\n{\\displaystyle \\mathbf{s}}\nas described below.\n\nThe relative orientation of spinor space with respect to real space becomes important in case spin-orbit coupling is included (\nLSORBIT\n=True). All magnetic moments and spinor-like quantities written or read by VASP are given in the basis of the spinor space\n{\nσ\n1\n{\\displaystyle \\{\\sigma_1}\n,\nσ\n2\n{\\displaystyle \\sigma_2}\n,\nσ\n3\n}\n{\\displaystyle \\mathbf{\\sigma}_3\\}}\n. This includes the\nMAGMOM\ntag in the\nINCAR\nfile, the total and local magnetizations in the\nOUTCAR\nand\nPROCAR\nfile, the spinor-like orbitals in the\nWAVECAR\nfile, and the magnetization density in the\nCHGCAR\nfile.\n\nCoordinate system\n\nFig 1. Euler angles\nα\n{\\displaystyle \\alpha}\nand\nβ\n{\\displaystyle \\beta}\ndefined by\ns\n=\n(\ns\nx\n,\ns\ny\n,\ns\nz\n)\nT\n{\\displaystyle \\mathbf{s}=(s_x,s_y,s_z)^T}\n.\n\nThe default orientation is\nσ\n1\n=\nx\n^\n{\\displaystyle \\sigma_1=\\hat x}\n,\nσ\n2\n=\ny\n^\n{\\displaystyle \\sigma_2 =\\hat y}\n,\nσ\n3\n=\nz\n^\n{\\displaystyle \\sigma_3 = \\hat z}\n. \nTo set\nσ\n^\n3\n=\ns\n/\n|\ns\n|\n{\\displaystyle \\hat{\\sigma}_3=s/|s|}\n, VASP applies two rotations with Euler angles\n\nα\n=\narctan\n⁡\n2\n(\ns\ny\ns\nx\n)\n∈\n[\n−\nπ\n,\nπ\n]\nβ\n=\narctan\n⁡\n2\n(\ns\nx\n2\n+\ns\ny\n2\ns\nz\n)\n∈\n[\n0\n,\nπ\n]\n.\n{\\displaystyle \n\\begin{align}\n\\alpha&=\\arctan2\\left(\\frac{s_y}{s_x}\\right) \\in [-\\pi,\\pi]\\\\\n\\beta&=\\arctan2\\left(\\frac{\\sqrt{s_x^2+s_y^2}}{s_z}\\right) \\in [0,\\pi].\n\\end{align}\n}\n\nHere,\nα\n{\\displaystyle \\alpha}\nis the angle between the projection of\nSAXIS\nonto the\nxy\nplane (s\nx\n,s\ny\n,0) and the Cartesian vector\nx\n^\n{\\displaystyle \\hat x}\n, and\nβ\n{\\displaystyle \\beta}\nis the angle between the vector\nSAXIS\nand the Cartesian vector\nz\n^\n{\\displaystyle \\hat z}\n, see Fig. 1. Search for `Euler angles` in the\nOUTCAR\nfile to see what VASP uses. For the default\ns\n=\n(\n0\n,\n0\n,\n1\n)\n{\\displaystyle \\mathbf{s}=(0,0,1)}\n,\nα\n=\n0\n{\\displaystyle \\alpha=0}\nand\nβ\n=\n0\n{\\displaystyle \\beta=0}\n.\n\nThe transformation of a vector\nm\n=\n(\nm\n1\n,\nm\n2\n,\nm\n3\n)\nT\n{\\displaystyle \\mathbf{m}=(m_1,m_2,m_3)^T}\ngiven in the basis\n{\nσ\n1\n{\\displaystyle \\{\\sigma_1}\n,\nσ\n2\n{\\displaystyle \\sigma_2}\n,\nσ\n3\n}\n{\\displaystyle \\mathbf{\\sigma}_3\\}}\ninto\nm\n′\n=\n(\nm\nx\n,\nm\ny\n,\nm\nz\n)\nT\n{\\displaystyle \\mathbf{m}'=(m_x,m_y,m_z)^T}\nin Cartesian coordinates and its inverse transformation read\n\nm\n=\nm\n1\nσ\n1\n+\nm\n2\nσ\n2\n+\nm\n3\nσ\n3\nm\n′\n=\nm\nx\nx\n^\n+\nm\ny\ny\n^\n+\nm\nz\nz\n^\nm\n′\n=\nR\nz\nα\nR\ny\nβ\nm\nm\n=\nR\ny\n−\nβ\nR\nz\n−\nα\nm\n′\n{\\displaystyle \n\\begin{align}\n\\mathbf{m}&= m_1 \\sigma_1 + m_2 \\sigma_2 + m_3 \\sigma_3 \\\\\n\\mathbf{m}'&= m_x \\hat x + m_y \\hat y + m_z \\hat z \\\\\n\\mathbf{m}'&= R_z^\\alpha R_y^\\beta \\mathbf{m} \\\\\n\\mathbf{m} &=  R_y^{-\\beta} R_z^{-\\alpha} \\mathbf{m}' \\\\\n\\end{align}\n}\n\nwhere the rotation matrices are\n\nR\nz\nα\n=\n(\ncos\n⁡\n(\nα\n)\n−\nsin\n⁡\n(\nα\n)\n0\nsin\n⁡\n(\nα\n)\ncos\n⁡\n(\nα\n)\n0\n0\n0\n1\n)\n,\nR\ny\nβ\n=\n(\ncos\n⁡\n(\nβ\n)\n0\nsin\n⁡\n(\nβ\n)\n0\n1\n0\n−\nsin\n⁡\n(\nβ\n)\n0\ncos\n⁡\n(\nβ\n)\n)\n.\n{\\displaystyle \nR_z^\\alpha = \\left(\\begin{matrix}\n  \\cos(\\alpha) & -\\sin(\\alpha) & 0 \\\\\n  \\sin(\\alpha) & \\cos(\\alpha)  & 0 \\\\\n         0     & 0             & 1 \\\\\n \\end{matrix}\\right), \\quad\nR_y^\\beta = \\left(\\begin{matrix}\n  \\cos(\\beta)  &  0 & \\sin(\\beta) \\\\\n       0       &  1 &    0        \\\\\n  -\\sin(\\beta) &  0 & \\cos(\\beta) \\\\\n \\end{matrix}\\right).\n}\n\nMind:\nApply the proper basis transformation when comparing vector-like quantities and spinor-like quantities.\n\nFor instance, when\nLORBMOM\n=True the orbital angular momentum is written to the\nOUTCAR\nfile in Cartesian coordinates. Thus, when comparing the orbital angular momentum (vector-like quantity) and the magnetization (spinor-like quantity), one has to perform a basis transformation on one of the quantities unless the bases agree (default).\n\nExample\n\nIn case the bases have the same orientation, i.e.,\nσ\n1\n=\nx\n^\n{\\displaystyle \\sigma_1=\\hat x}\n,\nσ\n2\n=\ny\n^\n{\\displaystyle \\sigma_2 =\\hat y}\n,\nσ\n3\n=\nz\n^\n{\\displaystyle \\sigma_3 = \\hat z}\n(default)\n\nm\nx\n=\nm\n1\n,\nm\ny\n=\nm\n2\n,\nm\nz\n=\nm\n3\n.\n{\\displaystyle \n\\begin{align}\nm_x & = & m_1, \\\\ \nm_y & = & m_2, \\\\ \nm_z & = & m_3. \n\\end{align}\n}\nFor a single site this implies setting\n\nMAGMOM\n= m\nx\nm\ny\nm\nz\n! magnetic moment in Cartesian coordinates\nSAXIS\n=  0 0 1   ! default\n\nFig 2. Example with\ns\n=\n(\n1\n,\n1\n,\n0\n)\nT\n{\\displaystyle \\mathbf{s}=(1,1,0)^T}\nand Euler angles\nα\n=\nπ\n/\n4\n{\\displaystyle \\alpha=\\pi/4}\nand\nβ\n=\nπ\n/\n2\n{\\displaystyle \\beta=\\pi/2}\n.\n\nAnother good choice is setting\ns\n{\\displaystyle \\mathbf{s}}\nto point along the direction of the on-site magnetic moment such that\n\nm\nx\n=\nsin\n⁡\n(\nβ\n)\ncos\n⁡\n(\nα\n)\nm\n=\nm\ns\nx\n/\ns\nx\n2\n+\ns\ny\n2\n+\ns\nz\n2\nm\ny\n=\nsin\n⁡\n(\nβ\n)\nsin\n⁡\n(\nα\n)\nm\n=\nm\ns\ny\n/\ns\nx\n2\n+\ns\ny\n2\n+\ns\nz\n2\nm\nz\n=\ncos\n⁡\n(\nβ\n)\nm\n=\nm\ns\nz\n/\ns\nx\n2\n+\ns\ny\n2\n+\ns\nz\n2\n,\n{\\displaystyle \n\\begin{align}\nm_x & = & \\sin(\\beta)\\cos(\\alpha) m &= m\\, s_x / \\sqrt{s_x^2+s_y^2+s_z^2} \\\\\nm_y & = & \\sin(\\beta)\\sin(\\alpha) m &= m\\, s_y / \\sqrt{s_x^2+s_y^2+s_z^2} \\\\\nm_z & = & \\cos(\\beta) m &= m\\, s_z / \\sqrt{s_x^2+s_y^2+s_z^2},\n\\end{align}\n}\nwhere\nm\n{\\displaystyle m}\nis the total on-site magnetic moment.\nFor a single site, this case implies setting\n\nMAGMOM\n= 0 0 m   ! magnetic moment along sigma3\nSAXIS\n=  s\nx\ns\ny\ns\nz\n! direction of sigma3\n\nThus, there are two methods to rotate the initial magnetization in an arbitrary direction: either by changing the initial magnetic moments\nMAGMOM\nor by changing\nSAXIS\n. Both methods should, in principle, yield exactly the same energy, but for implementation reasons, the second method might be more precise.\n\nIn case\n\nSAXIS\n=  1 1 0   ! alpha=pi/4, beta=pi/2\n\nthe spinor space\n{\nσ\n1\n{\\displaystyle \\{\\sigma_1}\n,\nσ\n2\n{\\displaystyle \\sigma_2}\n,\nσ\n3\n}\n{\\displaystyle \\mathbf{\\sigma}_3\\}}\nwill be rotated with respect to real space\n{\nx\n^\n,\ny\n^\n,\nz\n^\n}\n{\\displaystyle \\{\\hat x, \\hat y, \\hat z\\} }\nas shown in Fig. 2.",
    "related_tags": [
      "LNONCOLLINEAR",
      "MAGMOM",
      "LSORBIT"
    ]
  },
  "SCALEE": {
    "default_value": "SCALEE = 1",
    "description": "This tag specifies the coupling parameter of the energies and forces between a fully interacting system and a reference system.",
    "detailed_description": "The tag\nSCALEE\nsets the coupling parameter\nλ\n{\\displaystyle \\lambda}\nand hence controls the Hamiltonian of the calculation. \nBy default\nSCALEE\n=1 and the scaling of the energies and forces via the coupling constant is internally skipped in the code. To enable the scaling\nSCALEE\n≠\n{\\displaystyle \\ne}\n1 has to be specified.\n\nMore information using this tag is given\nhere\n.",
    "related_tags": [
      "VCAIMAGES",
      "IMAGES",
      "NCORE IN IMAGE1",
      "PHON_NSTRUCT",
      "IBRION"
    ]
  },
  "SCISSOR": {
    "default_value": "Default: SCISSOR = 0",
    "description": "SCISSOR specifies the shift for the scissor operator in eV.",
    "detailed_description": "The scissor operator in\nBSE\nand\nGW\ncalculations shifts the unoccupied states relative to the valence states\n[1]\n. For example, the scissor operator can be used in the BSE calculations to match the band gap to the known experimental value, thus achieving the right offset in the calculated spectrum. Notably, unlike the self-energy operator in GW, the scissor operator applies a universal shift to all conduction states, i.e., the shift is independent of energy or momentum and leaves the valence states unchanged. The scissor operator only shifts empty states, thus partially occupied orbitals are not affected by it.",
    "related_tags": [
      "BSE calculations"
    ]
  },
  "SCSRAD": {
    "default_value": "SCSRAD = 120",
    "description": "SCSRAD defines the cutoff radius (in Å {\\displaystyle \\AA} ) used in the calculation of τ i j {\\displaystyle \\tau_{ij}} within the Tkatchenko-Scheffler method Self-consistent screening in Tkatchenko-Scheffler method .",
    "detailed_description": "",
    "related_tags": [
      "Self-consistent screening in Tkatchenko-Scheffler method"
    ]
  },
  "SHAKEMAXITER": {
    "default_value": "SHAKEMAXITER = 1000",
    "description": "SHAKEMAXITER specifies the maximum number of iterations in the SHAKE algorithm (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "Constrained molecular dynamics (\nMDALGO\n=1 | 2) are performed using a\nSHAKE algorithm\n.\n[1]\n\nIf the error for all geometric constraints does not decrease below a predefined tolerance (\nSHAKETOL\n) within the allowed number of iterations, VASP terminates with an error message. \nThe aforementioned maximum number of iterations is set by means of the\nSHAKEMAXITER\ntag.",
    "related_tags": [
      "SHAKETOL",
      "MDALGO"
    ]
  },
  "SHAKETOL": {
    "default_value": "SHAKETOL = 10 − 5 {\\displaystyle 10^{-5}}",
    "description": "SHAKETOL specifies the tolerance for the SHAKE algorithm (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "Constrained molecular dynamics (\nMDALGO\n=1 | 2) are performed using a\nSHAKE algorithm\n.\n[1]\n\nSHAKETOL\nspecifies the tolerance for the SHAKE algorithm.\nIf the error for all geometric constraints does not decrease below this predefined tolerance within the allowed number of iterations (\nSHAKEMAXITER\n), VASP terminates with an error message.",
    "related_tags": [
      "SHAKEMAXITER",
      "MDALGO"
    ]
  },
  "SIGMA": {
    "default_value": "SIGMA = 0.2",
    "description": "SIGMA specifies the width of the smearing in eV.",
    "detailed_description": "",
    "related_tags": [
      "ISMEAR",
      "EFERMI",
      "K-point integration"
    ]
  },
  "SMASS": {
    "default_value": "SMASS = -3",
    "description": "SMASS controls the velocities during an ab-initio molecular-dynamics run.",
    "detailed_description": "SMASS\n=-3\n\nFor\nSMASS\n=-3 a microcanonical ensemble (\nNVE ensemble\n) is simulated (constant energy molecular dynamics). The calculated Hellmann-Feynman forces serve as an acceleration acting onto the ions. The total free energy (i.e. free electronic energy + Madelung energy of ions + kinetic energy of ions) is conserved.\n\nTip:\nTo calculate an\nNVE ensemble\nwe instead recommend to use\nMDALGO\n= 1\nand\nANDERSEN_PROB\n= 0.0\n.\n\nSMASS\n=-2\n\nFor\nSMASS\n=-2 the initial velocities are kept constant. This allows to calculate the energy for a set of different linear dependent positions (for instance frozen phonons, or dimers with varying bond lengths).\nMind\n: if\nSMASS\n=-2 the actual steps taken are\nPOTIM\n×(velocities-read-from-the-\nPOSCAR\n-file). To avoid ambiguities, set\nPOTIM\n=1.\n\nSMASS\n=-1\n\nIn this case the velocities are scaled each\nNBLOCK\nstep (starting at the first step i.e. MOD(NSTEP,\nNBLOCK\n)=1) to the temperature: T=\nTEBEG\n+(\nTEEND\n-\nTEBEG\n)×NSTEP/\nNSW\n,\nwhere NSTEP is the current step (starting from 1). This allows a continuous increase or decrease of the kinetic energy. In the intermediate period, a micro-canonical ensemble is simulated.\n\nSMASS\n≥0\n\nFor\nSMASS\n≥0, a canonical ensemble is simulated using the algorithm of Nosé. The Nosé mass controls the frequency of the temperature oscillations during the simulation.\n[1]\n[2]\n[3]\nFor\nSMASS\n=0, a Nosé-mass corresponding to period of 40 time steps will be chosen. The Nosé-mass should be set such that the induced temperature fluctuation show approximately the same frequencies as the typical 'phonon'-frequencies for the specific system. For liquids something like 'phonon'-frequencies might be obtained from the spectrum of the velocity auto-correlation function. If the ionic frequencies differ by an order of magnitude from the frequencies of the induced temperature fluctuations, Nosé thermostat and ionic movement might decouple leading to a non-canonical ensemble. The frequency of the approximate temperature fluctuations induced by the Nosé-thermostat is written to the\nOUTCAR\nfile.",
    "related_tags": [
      "structure optimization",
      "IBRION",
      "POTIM",
      "NBLOCK",
      "TEBEG",
      "TEEND"
    ]
  },
  "SMBJ": {
    "default_value": "SMBJ = 2",
    "description": "sets the σ {\\displaystyle \\sigma} parameter (in Å {\\displaystyle \\AA} ) in the LMBJ potential.",
    "detailed_description": "See the description of the\nMETAGGA\ntag.",
    "related_tags": [
      "METAGGA",
      "CMBJ",
      "CMBJA",
      "CMBJB",
      "CMBJE",
      "RSMBJ",
      "LASPH",
      "LMAXTAU",
      "LMIXTAU"
    ]
  },
  "SMEARINGS": {
    "default_value": "SMEARINGS = not set",
    "description": "SMEARINGS defines the smearing parameters for ISMEAR = -3 in the calculation of the partial occupancies.",
    "detailed_description": "ISMEAR\n= -3\nperforms a loop over smearing-parameters supplied in the\nINCAR\nfile. With the tag\nSMEARINGS\n, you select which smearings are used\n\nSMEARINGS\n= ismear1 sigma1  ismear2 sigma2  ...\n\nMind:\nYou must set\nNSW\nto the number of different smearings.\n\nVASP will then read the provided smearings and conduct (\nNSW\n+ 1) calculations with the different smearings.\nFor the first calculation, VASP uses tetrahedron smearing\nISMEAR\n= -5\nto ensure that the tetrahedron information is present in case any of the selected smearings uses a tetrahedron method.\nSince VASP uses the relaxation engine to loop over the different smearings you cannot combine\nSMEARINGS\nwith other relaxation methods\nIBRION\n.",
    "related_tags": [
      "ISMEAR",
      "SIGMA",
      "NSW",
      "IBRION",
      "Smearing technique"
    ]
  },
  "SPRING": {
    "default_value": "SPRING = -5",
    "description": "SPRING gives the spring constant between the images as used in the elastic band method.",
    "detailed_description": "SPRING\nhas to be set together with\nIMAGES\nif the elastic band method is used to calculate energy barriers between two ionic configurations of a system.\n\nFor\nSPRING\n= 0, each image is only allowed\nto move into the direction perpendicular to the current\nhyper-tangent, which is calculated as the normal vector\nbetween two neighboring images.\nThis algorithm keeps the distance between the images\nconstant to\nfirst order\n. It is therefore possible to start\nwith a dense image spacing around the saddle point to obtain\na finer resolution around this point.\n\nThe nudged elastic band method\n[1]\n[2]\nis applied when\nSPRING\nis set to a negative value e.g.\n\nSPRING\n= -5\n\nThis is also the recommended setting.\nCompared to the previous case, additional tangential springs\nare introduced to keep the images equidistant\nduring the relaxation (remember the constraint is only\nconserved to first order otherwise). Do not use too large values,\nbecause this can slow down convergence. The default value\nusually works quite reliably.\n\nOne problem of the nudged elastic band method is\nthat the constraint (i.e movements only\nin the hyper-plane perpendicular to the current tangent) is\nnon linear. Therefore, the CG algorithm usually fails\nto converge, and  we recommended to use\nthe RMM-DIIS algorithm (\nIBRION\n=1) or the quick-min algorithm (\nIBRION\n=3).\nAdditionally,\nthe non-linear constraint (equidistant images) tends to be  violated\nsignificantly during the first few steps (it is only enforced to first order).\nIf this problem is\nencountered, a very low dimensionality parameter (\nIBRION\n=1,\nNFREE\n=2)\nshould be applied in the first few steps, or a steepest\ndescent minimization without line optimization (\nIBRION\n=3,\nSMASS\n=2).\nshould be used, to  pre-converge the images.",
    "related_tags": [
      "IMAGES",
      "IBRION",
      "NFREE",
      "SMASS"
    ]
  },
  "SPRING_K": {
    "default_value": "",
    "description": "Force constant for harmonic bias potential.",
    "detailed_description": "The parameter\nSPRING_K\ndefines force constants (\nκ\nμ\n{\\displaystyle \\kappa_{\\mu}}\n) for the harmonic bias of the following form:\n\nV\n~\n(\nξ\n1\n,\n…\n,\nξ\nM\n8\n)\n=\n∑\nμ\n=\n1\nM\n1\n2\nκ\nμ\n(\nξ\nμ\n(\nq\n)\n−\nξ\n0\nμ\n)\n2\n{\\displaystyle \n\\tilde{V}(\\xi_1,\\dots,\\xi_{M_8}) = \\sum_{\\mu=1}^{M}\\frac{1}{2}\\kappa_{\\mu} (\\xi_{\\mu}(q)-\\xi_{0\\mu})^2 \\;\n}\n\nwhere the sum runs over all (\nM\n8\n{\\displaystyle M_8}\n) coordinates the potential acts upon (\nξ\nμ\n(\nq\n)\n{\\displaystyle \\xi_{\\mu}(q)}\n), which are defined in the\nICONST\nfile by setting the\nstatus\nto 8.\nThe units of\nκ\nμ\n{\\displaystyle \\kappa_{\\mu}}\nare\ne\nV\n/\nu\nc\n{\\displaystyle eV/uc}\nwhere\nu\nc\n{\\displaystyle uc}\nunits of coordinate the potential acts upon (e.g.,\nÅ\n{\\displaystyle {\\AA}}\nfor coordinates with\nflag\nR,\nr\na\nd\n.\n{\\displaystyle rad.}\nfor coordinates with\nflag\nA, dimensionless for coordinates with\nflag\nW, etc...)\nThe number of items defined via\nSPRING_K\nmust be equal to\nM\n8\n{\\displaystyle M_8}\n, otherwise the calculation terminates with an error message.",
    "related_tags": [
      "SPRING_R0",
      "SPRING_V0",
      "ICONST",
      "Biased molecular dynamics"
    ]
  },
  "SPRING_R0": {
    "default_value": "",
    "description": "Position of the minimum for a harmonic bias potential.",
    "detailed_description": "The parameter\nSPRING_R0\ndefines the position of the minimum (\nξ\n0\nμ\n{\\displaystyle \\xi_{0\\mu}}\n) for the harmonic bias potential of the following form:\n\nV\n~\n(\nξ\n1\n,\n…\n,\nξ\nM\n8\n)\n=\n∑\nμ\n=\n1\nM\n1\n2\nκ\nμ\n(\nξ\nμ\n(\nq\n)\n−\nξ\n0\nμ\n)\n2\n,\n{\\displaystyle \n\\tilde{V}(\\xi_1,\\dots,\\xi_{M_8}) = \\sum_{\\mu=1}^{M}\\frac{1}{2}\\kappa_{\\mu} (\\xi_{\\mu}(q)-\\xi_{0\\mu})^2, \\;\n}\n\nwhere the sum runs over all (\nM\n8\n{\\displaystyle M_8}\n) coordinates  the potential acts upon (\nξ\nμ\n(\nq\n)\n{\\displaystyle \\xi_{\\mu}(q)}\n), which are defined in the\nICONST\nfile by setting the\nstatus=8\n.\nThe units of\nξ\n0\nμ\n{\\displaystyle \\xi_{0\\mu}}\ncorrespond to units of the coordinate the potential acts upon (e.g.,\nÅ\n{\\displaystyle {\\AA}}\nfor coordinates with\nflag\nR,\nr\na\nd\n.\n{\\displaystyle rad.}\nfor coordinates with\nflag\nA, dimensionless for coordinates with\nflag\nW, etc...).\nThe number of items defined via\nSPRING_R0\nmust be equal to\nM\n8\n{\\displaystyle M_8}\n, otherwise the calculation terminates with an error message.",
    "related_tags": [
      "SPRING_K",
      "SPRING_V0",
      "ICONST",
      "Biased molecular dynamics"
    ]
  },
  "SPRING_V0": {
    "default_value": "Default: SPRING_V0 = 0 for all coordinates with status=8 in ICONST .",
    "description": "Rate at which the bias potential is shifted in u c / f s {\\displaystyle uc/fs} .",
    "detailed_description": "Consider the bias potential for a\nmolecular-dynamics\n(MD) run of the form:\n\nV\n~\n(\nξ\n1\n,\n…\n,\nξ\nM\n8\n)\n=\n∑\nμ\n=\n1\nM\n8\n1\n2\nκ\nμ\n(\nξ\nμ\n(\nq\n)\n−\nξ\n0\nμ\n)\n2\n,\n{\\displaystyle \n\\tilde{V}(\\xi_1,\\dots,\\xi_{M_8}) = \\sum_{\\mu=1}^{M_8}\\frac{1}{2}\\kappa_{\\mu} (\\xi_{\\mu}(q)-\\xi_{0\\mu})^2, \\;\n}\n\nwhere the sum runs over all (\nM\n8\n{\\displaystyle M_8}\n) coordinates the potential acts upon (\nξ\nμ\n(\nq\n)\n{\\displaystyle \\xi_{\\mu}(q)}\n). The coordinates are defined in the\nICONST\nfile by setting the\nstatus=8\n.\nOptionally, the position of minimum (\nξ\n0\nμ\n{\\displaystyle \\xi_{0\\mu}}\n) can be shifted at a constant rate\nξ\n˙\nμ\n{\\displaystyle \\dot{\\xi}_{\\mu}}\nevery MD step, i.e.,\n\nξ\n0\nμ\n(\nt\n+\nΔ\nt\n)\n=\nξ\n0\nμ\n(\nt\n)\n+\nξ\n˙\nμ\n(\nq\n)\nΔ\nt\n,\n{\\displaystyle \n\\xi_{0\\mu}(t+\\Delta t) = \\xi_{0\\mu}(t) + \\dot{\\xi}_{\\mu}(q)\\Delta t, \\;\n}\n\nwhere\nΔ\nt\n{\\displaystyle \\Delta t}\nis the time step used in MD (\nPOTIM\n). \nThe rate\nξ\n˙\nμ\n{\\displaystyle \\dot{\\xi}_{\\mu}}\ncan be defined via the parameter\nSPRING_V0\nand its units are\nu\nc\n/\nf\ns\n{\\displaystyle uc/fs}\n, where\nu\nc\n{\\displaystyle uc}\ncorresponds to the units of the coordinate the potential acts upon (e.g.,\nÅ\n{\\displaystyle {\\AA}}\nfor coordinates with\nflag\nR,\nr\na\nd\n.\n{\\displaystyle rad.}\nfor coordinates with\nflag\nA, dimensionless for coordinates with\nflag\nW, etc...).\nThe number of items defined via\nSPRING_V0\nmust be equal to\nM\n8\n{\\displaystyle M_8}\n, otherwise the calculation terminates with an error message.",
    "related_tags": [
      "SPRING_K",
      "SPRING_R0",
      "ICONST",
      "Biased molecular dynamics"
    ]
  },
  "STEP_MAX": {
    "default_value": "STEP_MAX = 0.1",
    "description": "The flag STEP_MAX defines the trust radius (upper limit) for the optimization step (in Å {\\displaystyle \\AA} ) in the Improved Dimer Method .",
    "detailed_description": "",
    "related_tags": [
      "Improved Dimer Method"
    ]
  },
  "STEP_SIZE": {
    "default_value": "STEP_SIZE = 0.01",
    "description": "The flag STEP_SIZE defines the trial step size for the optimization step (in Å {\\displaystyle \\AA} ) in the Improved Dimer Method .",
    "detailed_description": "",
    "related_tags": [
      "Improved Dimer Method"
    ]
  },
  "STOP_ON": {
    "default_value": "STOP_ON = Error",
    "description": "STOP_ON defines if the code should stop on errors only or also on alerts.",
    "detailed_description": "There are two instances, why one might want a more conservative choice when running calculations.\n\nFirst, VASP will overwrite user provided input, if the input does not make sense. You may want to\nmake sure that VASP does not continue in this case by setting the stricter\nSTOP_ON\n= Alert\n\nSecondly, VASP will continue if it encounters issues during the calculation if there is a chance\nthat these disappear during the self consistency. However, if you are at a stage where you still\nexplore what parameters to use, being more conservative makes the calculation fail faster so\nthat you can try different parameters.",
    "related_tags": []
  },
  "STRUCTURE": {
    "default_value": "PLUGINS/STRUCTURE = .False.",
    "description": "PLUGINS/STRUCTURE calls the Python plugin for the structure interface for each ionic relaxation step",
    "detailed_description": "When\nPLUGINS/STRUCTURE\n=.TRUE., VASP calls the\nstructure\nPython function at the end of each ionic relaxation step. \nThe primary use-case of this tag is to modify the structure based on the computed energy, force and stress tensor.\n\nExpected inputs\n\nThe\nstructure\nPython function expects the following inputs,\n\ndef\nstructure\n(\nconstants\n,\nadditions\n):\n\nwhere\nconstants\nand\nadditions\nand\nPython dataclasses\n.\nThe\nconstants\ndataclass consists of the following inputs, listed here with their associated\ndatatypes\n\n@dataclass\n(\nfrozen\n=\nTrue\n)\nclass\nConstantsStructure\n:\nnumber_ions\n:\nint\nnumber_ion_types\n:\nint\nion_types\n:\nIndexArray\natomic_numbers\n:\nIntArray\nlattice_vectors\n:\nDoubleArray\npositions\n:\nDoubleArray\nPOMASS\n:\nDoubleArray\ntotal_energy\n:\nfloat\nforces\n:\nDoubleArray\nstress\n:\nDoubleArray\nshape_grid\n:\nIntArray\ncharge_density\n:\nDoubleArray\n\nNote that the\nINCAR\ntags are capitalized.\nnumber_ions\nis the total number of ions listed in the\nPOSCAR\nfile,\nnumber_ion_types\nis the number of ion corresponding to each ion type in the convention of the\nPOSCAR\nfile,\nion_types\nstores the total number of ion types,\natomic_numbers\ncontains the atomic number for each atom type,\nlattice_vectors\nand\npositions\ncontain the lattice vectors and positions of the current SCF step\nforces\nand\nstress\nare the computed forces and stress tensor and\ncharge_density\ncontains the charge density on the real space grid.\nshape_grid\nis a three dimensional integer array which stores the shape of the real space grid,\nNGXF\n,\nNGYF\nand\nNGZF\nand\ncharge_density\nis the charge density on this real space grid.\n\nThe\nadditions\ndataclass consists of the following modifiable outputs\n\n@dataclass\nclass\nAdditionsStructure\n:\nlattice_vectors\n:\nDoubleArray\npositions\n:\nDoubleArray\n\nModifying quantities\n\nModify the quantities listed in additions by adding to them.\n\ndef\nstructure\n(\nconstants\n,\nadditions\n)\nadditions\n.\npositions\n+=\nnp\n.\nones\n((\nconstants\n.\nnumber_ions\n,\n3\n))\n\nWarning:\nYou should not make modifications to quantities in\nconstants\n. We implemented some safeguards to prevent accidental modifications. Intentional changes will lead to erratic behavior because we may change the VASP code assuming these quantities are constant.",
    "related_tags": [
      "Plugins",
      "PLUGINS/FORCE_AND_STRESS",
      "PLUGINS/LOCAL_POTENTIAL",
      "PLUGINS/MACHINE_LEARNING"
    ]
  },
  "SYMPREC": {
    "default_value": "SYMPREC = 10 − 5 {\\displaystyle 10^{-5}}",
    "description": "SYMPREC determines to which accuracy the positions in the POSCAR file must be specified (as of VASP.4.4.4).",
    "detailed_description": "SYMPREC\ndetermines how accurately the positions in the\nPOSCAR\nfile must be specified.\nThe default,\nSYMPREC\n=10\n-5\n, is usually large enough, even if the\nPOSCAR\nfile has been generated with single precision accuracy.\nIncreasing\nSYMPREC\nmeans that the positions in the\nPOSCAR\nfile can be specified with less accuracy (increasing fuzziness). Please also have a look at\nthis section\n.",
    "related_tags": [
      "ISYM"
    ]
  },
  "SYSTEM": {
    "default_value": "SYSTEM = unknown system",
    "description": "The \"title string\" defined by SYSTEM is for the user only and should help the user to identify what he/she wants to do with this specific input file.",
    "detailed_description": "The\nSYSTEM\ntag is followed by a string that possibly contains blanks. The string is read in and written to the main output file\nOUTCAR\n.\n\nExamples that use this tag",
    "related_tags": []
  },
  "TEBEG": {
    "default_value": "TEBEG = 0",
    "description": "TEBEG sets the starting temperature (in K) for an ab-initio molecular dynamics run ( IBRION =0) and other routines (e.g. Electron-phonon interactions from Monte-Carlo sampling ).",
    "detailed_description": "If no initial velocities are supplied on the\nPOSCAR\nfile, the velocities are set randomly according to a Maxwell-Boltzmann distribution at the initial temperature\nTEBEG\n. Velocities are only used for molecular dynamics (\nIBRION\n=0).\n\nMind\n: If\nMDALGO\n>0 is used VASP defines the temperature as\n\nT\n=\n1\nk\nB\nT\n3\n(\nN\ni\no\nn\ns\n−\nN\nc\no\nn\ns\nt\nr\na\ni\nn\nt\ns\n)\n∑\nn\nN\ni\no\nn\ns\nM\nn\n|\nv\n→\nn\n|\n2\n.\n{\\displaystyle \nT= \\frac{1}{ k_B T 3 (N_{\\rm ions}-N_{\\rm constraints})} \\sum\\limits_{n}^{N_{\\rm ions}} M_n | \\vec v_n |^2.\n}\n\nThis temperature ist written to the\nOUTCAR\nfile. \nDepending on the type of thermostat this temperature has to be rescaled to obtain the real simulation temperature.\n\nNose-Hoover thermostat\n:\n\nIn this thermostat the number of degrees of freedom including constraines are already acounted for in the potential energy term. In this this method the center of mass is conserved. This lowers the degrees of freedom by one which is also taken into account in the\nOUTCAR\nfile.\n\nAndersen thermostat\n:\n\nSame as for\nNose-Hoover thermostat\n.\n\nLangevin thermostat\n:\n\nAs for the\nNose-Hoover thermostat\nand\nAndersen thermostat\nin this thermostat the number of degrees of freedom including constraines are already acounted for. The center of mass is not conserved in this method, hence this method has 3 degrees of freedom more than the\nNose-Hoover thermostat\nand\nAndersen thermostat\n.",
    "related_tags": [
      "TEEND",
      "IBRION",
      "SMASS"
    ]
  },
  "TEEND": {
    "default_value": "TEEND = TEBEG",
    "description": "TEEND sets the final temperature (in K) for an ab-initio molecular-dynamics run.",
    "detailed_description": "",
    "related_tags": [
      "TEBEG",
      "IBRION",
      "SMASS"
    ]
  },
  "TILAMBDA": {
    "default_value": "TILAMBDA = 0.0",
    "description": "TILAMBDA defines the coupling parameter λ {\\displaystyle \\lambda} used in Thermodynamic integration with harmonic reference . The value of λ {\\displaystyle \\lambda} must be from the inverval ⟨ 0 , 1 ⟩ {\\displaystyle \\langle 0, 1 \\rangle} .",
    "detailed_description": "How to run thermodynamic integration calculations is given\nhere\n.",
    "related_tags": [
      "HESSEMAT",
      "ICONST",
      "REPORT"
    ]
  },
  "TIME": {
    "default_value": "TIME = 0.4",
    "description": "TIME controls the time step for IALGO =5X and for the initial (steepest descent) phase of IALGO =4X.",
    "detailed_description": "",
    "related_tags": [
      "IALGO"
    ]
  },
  "TRANSPORT_NEDOS": {
    "default_value": "TRANSPORT_NEDOS = 501",
    "description": "Choose the number of points in the Gauss-Legendre integration grid for the computation of the Onsager coefficients, which in turn are used to compute the transport coefficients.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nBy a variable change in the integral of the transport function, it is possible to use Gauss-Legendre quadrature to evaluate the Onsager coefficients.\nBy increasing the number of points, one defines the energy window inside which we need to compute the electron group velocities and the electronic lifetimes due to electron-phonon coupling and the precision of the integral.\n\nA convergence study is recommended since having a very large number of integration points can greatly increase the number of states for which the electronic lifetimes need to be computed, sometimes without a significant change in the final transport coefficients. Lower values of the number of integration points can significantly speed up the calculation, specially for very dense grids.",
    "related_tags": [
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_TRANSPORT",
      "ELPH_TRANSPORT_DRIVER"
    ]
  },
  "TRANSPORT_RELAXATION_TIME": {
    "default_value": "TRANSPORT_RELAXATION_TIME = 1E-14",
    "description": "Value of the constant relaxation time in unit of seconds.",
    "detailed_description": "Mind:\nAvailable as of VASP 6.5.0\n\nThis value is only used when\nELPH_SCATTERING_APPROX\n= CRTA\n, so for the constant relaxation-time approximation.",
    "related_tags": [
      "Transport calculations",
      "ELPH_RUN",
      "ELPH_TRANSPORT",
      "ELPH_SCATTERING_APPROX"
    ]
  },
  "TSUBSYS": {
    "default_value": "",
    "description": "TSUBSYS sets the temperatures for the atomic subsystems in calculations with multiple Anderson thermostats (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "Up to three user-defined atomic subsystems may be coupled with independent Andersen thermostats\n[1]\n(\nMDALGO\n=13).\n\nThe simulation temperature for the atomic subsystems is set by means of the\nTSUBSYS\ntag (one has to specify one number for each subsystem).",
    "related_tags": [
      "NSUBSYS",
      "PSUBSYS",
      "MDALGO"
    ]
  },
  "VACPOTFLAT": {
    "default_value": "VACPOTFLAT = 0.1",
    "description": "Maximum permissible 2D-averaged electric field for a region considered to be field-free in eV/Å.",
    "detailed_description": "A region of space is considered to be field-free if the 2D-averaged electric field (\nLVACPOTAV\n=True) is smaller than\nVACPOTFLAT\n.\n\nTip:\nIncrease\nVACPOTFLAT\nfor a quick estimation of the vacuum potential and decrease for a precise value. If the cell is large and\nEDIFF\nsmall, the final result of\nLVACPOTAV\nshould be independent of\nVACPOTFLAT\n.",
    "related_tags": [
      "LVACPOTAV",
      "LVTOT",
      "LVHAR",
      "WRT_POTENTIAL",
      "DIPOL",
      "LDIPOL",
      "IDIPOL"
    ]
  },
  "VALUE_MAX": {
    "default_value": "",
    "description": "VALUE_MAX sets the upper limits for the monitoring of geometric parameters (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "For\nMDALGO\n=1 | 2, the geometric parameters defined in the\nICONST\nfile may be monitored without being subjected to a constraint or bias potential (\nSTATUS=7\nin the\nICONST\n-file).\n\nIf all values of monitored parameters defined in the\nICONST\nfile (\nSTATUS=7\n) are smaller than\nVALUE_MIN\nor larger than\nVALUE_MAX\n, the simulation terminates.\n\nUpper limits for monitored coordinates, must be supplied for each geometric parameter in the\nICONST\nfile with\nSTATUS=7\n.",
    "related_tags": [
      "VALUE_MIN",
      "MDALGO"
    ]
  },
  "VALUE_MIN": {
    "default_value": "",
    "description": "VALUE_MIN sets the lower limits for the monitoring of geometric parameters (in case VASP was compiled with -Dtbdyn ).",
    "detailed_description": "For\nMDALGO\n=1 | 2, the geometric parameters defined in the\nICONST\nfile may be monitored without being subjected to a constraint or bias potential (\nSTATUS=7\nin the\nICONST\nfile).\n\nIf all values of monitored parameters defined in the\nICONST\nfile (\nSTATUS=7\n) are smaller than\nVALUE_MIN\nor larger than\nVALUE_MAX\n, the simulation terminates.\n\nUpper limits for monitored coordinates, must be supplied for each geometric parameter in the\nICONST\nfile with\nSTATUS=7\n.",
    "related_tags": [
      "VALUE_MAX",
      "MDALGO"
    ]
  },
  "VCA": {
    "default_value": "VCA = read from the POTCAR file",
    "description": "VCA is short for the virtual crystal approximation; the tag allows to \"weight\" each species found in the POTCAR file.",
    "detailed_description": "The tag\nVCA\nmust be supplied for each atom type or species found in the\nPOTCAR\nand\nPOSCAR\nfile, respectively. \nIt weights the corresponding\nPOTCAR\nfiles according to the values given in the\nINCAR\nfile, with the default\nbeing 1. For instance, the formal valency found in the\nPOTCAR\nfiles is multiplied by the supplied values. Likewise, the local potential,\nthe augmentation charges, and the non-local pseudopotential strength parameters are scaled by the supplied values.\n\nIt is possible to use this flag to perform calculations in the framework of the virtual crystal approximation.\nSay you want to simulate Sn doping in a Ge lattice. This can be achieved using a\nPOTCAR\nfile with a Ge and Sn data set and the following\nPOSCAR\nfile:\n\ncd:\n  1.00000000000000\n    2.82173    2.82173    0.00000\n    0.00000    2.82173    2.82173\n    2.82173    0.00000    2.82173\n  Ge   Sn\n    2     2\nDirect\n 0.00  0.00  0.00\n 0.25  0.25  0.25\n 0.00  0.00  0.00\n 0.25  0.25  0.25\n\nIf\nVCA\nis set to\n\nVCA = 0.99 0.01\n\nthe Ge atoms are weighted with a weight of 0.99, whereas the Sn atoms are weighted by 0.01 (see\n[1]\nfor an example application).\nThe implementation in VASP closely follows the methodology suggested by Bellaiche and Vanderbilt\n[2]\n.\n\nCaveats: Unfortunately, results of this kind of VCA calculations are often not very reliable. The problems are even apparent in the original publications\n[2]\n. The\nkey point is that the used PAW potentials need to be constructed so that the pseudo atomic waves are very similar for the potentials that are \"mixed\" (in the example above, this would be the Ge and Sn potentials). This can be achieved by carefully optimizing the radial cutoffs. Furthermore, the local potentials of the two\nPOTCAR\nfiles need to be very similar. This means that results for many standard potentials are not accurate. For instance, Vegard's law is often not even approximately observed (instead, the volume is too large at 50 % mixing). The problem is particularly severe if semi-core states are treated as valence states. For instance, for the Ge and Sn alloy, the d electrons had to be treated as core electrons to obtain reasonable results. Any attempts to treat the d electrons as valence states lead to grossly incorrect results.\n\nMind:\nThis tag is currently not supported in combination with\nIBRION\n= 5-8 for computing second derivatives, Hessian matrices, and phonon frequencies.",
    "related_tags": [
      "LVCADER"
    ]
  },
  "VCAIMAGES": {
    "default_value": "VCAIMAGES = -1",
    "description": "The tag VCAIMAGES allows to perform thermodynamic coupling constant integrations. To achieve this, two molecular dynamics simulations are performed with e.g. different POTCAR or KPOINTS files or different exchange-correlation functionals, and force averaging between the two calculations is done [1] .",
    "detailed_description": "The tag\nVCAIMAGES\ninternally splits the available nodes into two groups, and each group\nthen performs an independent VASP calculation (this implies\nVCAIMAGES\nonly works in the MPI version). \nThis behavior is implemented in the same way as\nthe nudged elastic band method described under the tag\nIMAGES\n. As opposed to the nudged\nelastic band method, VASP creates always two images by setting the tag\nIMAGES\n=2 internally.\nThe two calculations are performed in subdirectories 01 and 02 (as opposed to the nudged elastic\nband method, subdirectories 00 and 03  are not required). A precise description of the file\nreading and writing is given below.\n\nThe two VASP calculations are essentially performed independently in subdirectories 01 and 02.\nThe forces, energies and the stress tensor of the two calculations are averaged according to the tag\nVCAIMAGES\n. \nSpecifically, the value supplied in the tag\nVCAIMAGES\ndetermines the weight of the calculations\nperformed in subdirectory 01. The weight of the second image is 1-\nVCAIMAGES\n. The averaging\nis performed after self-consistency has been reached and affects the final total energy as well as\nthe forces. Since the energies and forces are averaged, the trajectories generated by the two simulations \nwill be exactly identical. Make sure though, that the initial\nPOSCAR\nfiles in the two subdirectories\nare exactly identical. The averaged energies can be found in the\nOUTCAR\nfile after the lines\n\"ENERGY OF THE ELECTRON-ION-THERMOSTAT SYSTEM (eV)\", as well as in the file\nOSZICAR\n(in the lines writing the free energy  \"F=\"). This makes scanning the\nOSZICAR\nfile for the\nrequired energies of the individual calculations somewhat awkward.\n\nSpecial handling: In some cases it might be desirable to use a different number of cores for\nthe first image and the second image. For instance, this might be expedient for calculations\nwhere thermodynamic integration is performed from a coarse to a dense k-point grid, or from a cheap\nto an expensive exchange-correlation functional. \nTo set the number of cores in the first image the tag\nNCORE_IN_IMAGE1\nhas to be set. The second image then \ncontains the remaining cores.\n\nThe usage of this tag is also explained in the supplementary information of reference\n[1]\n.",
    "related_tags": [
      "NCORE_IN_IMAGE1",
      "SCALEE",
      "IMAGES"
    ]
  },
  "VCUTOFF": {
    "default_value": "VCUTOFF = 1.1 ENCUTGW",
    "description": "The parameter VCUTOFF sets the energy cutoff for bare Coulomb matrix elements and controls the basis set for the bare Coulomb interaction.",
    "detailed_description": "",
    "related_tags": [
      "ENCUTGW",
      "Constrained–random-phase–approximation_formalism"
    ]
  },
  "VDW_A1": {
    "default_value": "Default: VDW_A1 = 1.0 for DFT-D3 with the BJ damping function",
    "description": "VDW_A1 defines the damping function parameter a 1 {\\displaystyle a_{1}} .",
    "detailed_description": "VDW_A1\nsets the damping function parameter\na\n1\n{\\displaystyle a_{1}}\nfor the\nDFT-D3\n(BJ damping function) and\nDFT-D4\nmethods.",
    "related_tags": [
      "DFT-D3",
      "DFT-D4"
    ]
  },
  "VDW_A2": {
    "default_value": "",
    "description": "VDW_A2 defines the damping function parameter a 2 {\\displaystyle a_{2}} .",
    "detailed_description": "VDW_A2\ndefines the damping function parameter\na\n2\n{\\displaystyle a_{2}}\nfor the\nDFT-D3\n(BJ damping function) and\nDFT-D4\nmethods.",
    "related_tags": [
      "DFT-D3",
      "DFT-D4"
    ]
  },
  "VDW_ALPHA": {
    "default_value": "",
    "description": "VDW_ALPHA defines the polarizability α 0 {\\displaystyle \\alpha_{0}} (bohr 3 {\\displaystyle ^{3}} ) for each species defined in the POSCAR file.",
    "detailed_description": "VDW_ALPHA\nsets the polarizability\nα\n0\n{\\displaystyle \\alpha_{0}}\n(bohr\n3\n{\\displaystyle ^{3}}\n) for each species defined in the\nPOSCAR\nfile for the\nTkatchenko-Scheffler\nand\nMany-body dispersion energy\nmethods.",
    "related_tags": [
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "VDW_C6": {
    "default_value": "",
    "description": "VDW_C6 defines the C 6 {\\displaystyle C_6} parameters ( J n m 6 m o l − 1 {\\displaystyle \\mathrm{Jnm}^{6}\\mathrm{mol}^{-1}} ) for each species defined in the POSCAR file.",
    "detailed_description": "VDW_C6\nsets the\nC\n6\n{\\displaystyle C_6}\nparameters (\nJ\nn\nm\n6\nm\no\nl\n−\n1\n{\\displaystyle \\mathrm{Jnm}^{6}\\mathrm{mol}^{-1}}\n) for each species defined in the\nPOSCAR\nfile for the\nDFT-D2\n,\nDFT-ulg\n,\nTkatchenko-Scheffler\n, and\nMany-body dispersion energy\nmethods.",
    "related_tags": [
      "VDW_C6AU",
      "DFT-D2",
      "DFT-ulg",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "VDW_C6AU": {
    "default_value": "",
    "description": "VDW_C6AU defines the C 6 {\\displaystyle C_6} parameters ( H a r t r e e {\\displaystyle \\mathrm{Hartree}} b o h r 6 {\\displaystyle \\mathrm{bohr}^{6}} ) for each species defined in the POSCAR file.",
    "detailed_description": "VDW_C6AU\nsets the\nC\n6\n{\\displaystyle C_6}\nparameters (\nH\na\nr\nt\nr\ne\ne\n{\\displaystyle \\mathrm{Hartree}}\nb\no\nh\nr\n6\n{\\displaystyle \\mathrm{bohr}^{6}}\n) for each species defined in the\nPOSCAR\nfile for the\nTkatchenko-Scheffler\nand\nMany-body dispersion energy\nmethods.",
    "related_tags": [
      "VDW_C6",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "VDW_CNRADIUS": {
    "default_value": "VDW_CNRADIUS = 21.167",
    "description": "VDW_CNRADIUS defines the cutoff radius (in Å {\\displaystyle \\AA} ) for the calculation of the coordination numbers.",
    "detailed_description": "VDW_CNRADIUS\nsets the cutoff radius (in\nÅ\n{\\displaystyle \\AA}\n) for the calculation of the coordination numbers used for the\nDFT-D3\nmethod.",
    "related_tags": [
      "DFT-D3"
    ]
  },
  "VDW_D": {
    "default_value": "Default: VDW_D = 20 for DFT-D2 and Tkatchenko-Scheffler | = 0.6966 for DFT-ulg | = 6 for Many-body dispersion energy",
    "description": "VDW_D defines the damping parameter d {\\displaystyle d} .",
    "detailed_description": "VDW_D\nsets the damping parameter\nd\n{\\displaystyle d}\nfor the\nDFT-D2\n,\nDFT-ulg\n,\nTkatchenko-Scheffler\n, and\nMany-body dispersion energy\nmethods.",
    "related_tags": [
      "DFT-D2",
      "DFT-ulg",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "VDW_R0": {
    "default_value": "",
    "description": "VDW_R0 defines the R 0 {\\displaystyle R_0} parameters ( Å {\\displaystyle \\AA} ) for each species defined in the POSCAR file.",
    "detailed_description": "VDW_R0\nsets the\nR\n0\n{\\displaystyle R_0}\nparameters (\nÅ\n{\\displaystyle \\AA}\n) for each species defined in the\nPOSCAR\nfile for the\nDFT-D2\n,\nDFT-ulg\n,\nTkatchenko-Scheffler\n, and\nMany-body dispersion energy\nmethods.",
    "related_tags": [
      "VDW_R0AU",
      "DFT-D2",
      "DFT-ulg",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "VDW_R0AU": {
    "default_value": "",
    "description": "VDW_R0AU defines the R 0 {\\displaystyle R_0} parameters (bohr) for each species defined in the POSCAR file.",
    "detailed_description": "VDW_R0AU\nsets the\nR\n0\n{\\displaystyle R_0}\nparameters (bohr) for each species defined in the\nPOSCAR\nfile for the\nTkatchenko-Scheffler\nand\nMany-body dispersion energy\nmethods.",
    "related_tags": [
      "VDW_R0",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "VDW_RADIUS": {
    "default_value": "VDW_RADIUS = 50",
    "description": "Defines the cutoff radius (in Å {\\displaystyle \\AA} ) for the van der Waals pair interactions.",
    "detailed_description": "VDW_RADIUS\nsets the cutoff radius for the van der Waals pair interactions in\nÅ\n{\\displaystyle \\AA}\nfor the\nDFT-D2\n,\nDFT-D3\n,\nDFT-ulg\n,\nDDsC\n, and\nTkatchenko-Scheffler\nmethods.",
    "related_tags": [
      "DFT-D2",
      "DFT-D3",
      "DFT-ulg",
      "DDsC",
      "Tkatchenko-Scheffler method"
    ]
  },
  "VDW_S6": {
    "default_value": "",
    "description": "VDW_S6 defines the global scaling factor s 6 {\\displaystyle s_{6}} .",
    "detailed_description": "VDW_S6\nsets the global scaling factor\ns\n6\n{\\displaystyle s_{6}}\nfor the\nDFT-D2\n,\nDFT-D4\n,\nDFT-ulg\n, and\nTkatchenko-Scheffler\nmethods.",
    "related_tags": [
      "DFT-D2",
      "DFT-D4",
      "DFT-ulg",
      "Tkatchenko-Scheffler method"
    ]
  },
  "VDW_S8": {
    "default_value": "Default: VDW_S8 = 1.0 for DFT-D3",
    "description": "VDW_S8 defines the damping function parameter s 8 {\\displaystyle s_{8}} .",
    "detailed_description": "VDW_S8\nsets the damping function parameter\ns\n8\n{\\displaystyle s_{8}}\nin the\nDFT-D3\nand\nDFT-D4\nmethods.",
    "related_tags": [
      "DFT-D3",
      "DFT-D4"
    ]
  },
  "VDW_SR": {
    "default_value": "",
    "description": "VDW_SR defines the damping function parameter s R {\\displaystyle s_{R}} (or scaling factor).",
    "detailed_description": "VDW_SR\nsets the damping function parameter\ns\nR\n{\\displaystyle s_{R}}\n(or scaling factor) for the\nDFT-D2\n,\nDFT-D3\n,\nDDsC\n,\nTkatchenko-Scheffler\nand\nMany-body dispersion energy\nmethods.",
    "related_tags": [
      "DFT-D2",
      "DFT-D3",
      "DDsC",
      "Tkatchenko-Scheffler method",
      "Many-body dispersion energy"
    ]
  },
  "VOSKOWN": {
    "default_value": "VOSKOWN = 0",
    "description": "Determines whether Vosko-Wilk-Nusair interpolation is used or not.",
    "detailed_description": "This flag is not relevant for most \"modern\" gradient corrected functionals, such as PBE or PBEsol.\n\nFor the LDA and some \"older\" gradient corrected functionals such as PW91, VASP interpolates the correlation energy from the non-spinpolarized to the fully spinpolarized case in the same way as the exchange energy (Barth-Hedin spin interpolation\n[1]\n. If\nVOSKOWN\nis set to 1, the interpolation formula according to Vosko, Wilk and Nusair\n[2]\nis used (this interpolation is based on the RPA correlation energy of partially spin polarized systems). The  Vosko, Wilk and Nusair interpolation usually enhances the magnetic moments and the magnetic energies. Because the Vosko-Wilk-Nusair interpolation is the interpolation usually applied in the context of gradient corrected functionals, it is desirable to use this interpolation whenever the PW91 functional is applied. Setting this tag is not required for most modern functions, such as the PBE or PBEsol functional, since these functional strictly follow the original publications and disregard the setting of this flag entirely (this implicitly implies that the correlation energy is interpolated according to Vosko, Wilk and Nusair).\n\nReferences\n\n↑\nU. V. Barth and L. Hedin, J. Phys. C\n5\n, 1629 (1972).\n↑\nS. H. Vosko, L. Wilk, and M. Nusair, Can. J. Phys.\n58\n, 1200 (1980).\n\nExamples that use this tag",
    "related_tags": []
  },
  "WANNIER90_WIN": {
    "default_value": "Default: WANNIER90_WIN = None",
    "description": "WANNIER90_WIN sets the content of the wannier90.win file.",
    "detailed_description": "The\nWANNIER90_WIN\ntag is a multiline string, where the content of the\nwannier90.win\nfile can be specified. For instance,\n\nWANNIER90_WIN = \"\nexclude_bands 17-64\n\nBegin Projections\nSi:sp3\nEnd Projections\n\n# Disentanglement\ndis_win_min = -7\ndis_win_max = 16\ndis_num_iter = 100\n\nguiding_centres = true\n\"\n\nAdditionally, the value of some\nWannier90 tags\nis set automatically based on the VASP calculation, e.g.,\nkpoints\n,\natoms\n,\nunit_cell\n,\nmp_grid\n,\nspinors\n,\nnum_bands\n,\nnum_wann\n.\n\nAvailable as of VASP 6.2.0.",
    "related_tags": [
      "NUM_WANN",
      "LWANNIER90",
      "LWANNIER90_RUN"
    ]
  },
  "WC": {
    "default_value": "WC = 1000.",
    "description": "WC specifies the weight factor for each step in Broyden mixing scheme ( IMIX =4).",
    "detailed_description": "WC\n>0\n\nSet all weights identical to\nWC\n(resulting in Pulay's mixing method), up to now Pulay's scheme was always superior to Broyden's 2\nnd\nmethod.\n\nWC\n=0\n\nSwitch to Broyden's 2\nnd\nmethod, i.e., set the weight for the last step equal to 1000 and all other weights equal to 0.\n\nWC\n<0 (implemented for test purposes:\nnot\nrecommended)\n\nTry some automatic setting of the weights according to:\nW\ni\nt\ne\nr\n=\n0.01\n|\nW\nC\n|\n/\n|\n|\nρ\no\nu\nt\n−\nρ\ni\nn\n|\n|\np\nr\ne\nc\no\nn\nd\n.\n{\\displaystyle W_{\\rm iter}=0.01 |{\\rm WC}|/||\\rho_{\\rm out}-\\rho_{\\rm in}||_{\\rm precond.}\\,}\n\nin order to set small weights for the first steps and increase weights for the last steps.\n\nRelated tags and sections\n\nIMIX\n,\nINIMIX\n,\nMAXMIX\n,\nAMIX\n,\nBMIX\n,\nAMIX_MAG\n,\nBMIX_MAG\n,\nAMIN\n,\nMIXPRE\n\nExamples that use this tag",
    "related_tags": []
  },
  "WEIMIN": {
    "default_value": "Default: WEIMIN = 0.001 for IBRION ≥0 | = 0 for IBRION =−1",
    "description": "WEIMIN specifies the maximum weight for a band to be considered empty.",
    "detailed_description": "The tags\nWEIMIN\n,\nEBREAK\n, and\nDEPER\nallow fine-tuning of the iterative matrix diagonalization and are best not changed. They are optimized for a large variety of systems, and changing one of the parameters usually decreases performance or can even screw up the iterative matrix diagonalization totally.\nIn general, these tags control when the optimization of a single band is stopped within the iterative matrix diagonalization schemes:\n\nWithin all implemented iterative schemes a distinction between empty and occupied bands is made to speed up calculations. Unoccupied bands are optimized only twice, whereas occupied bands are optimized up to four times till another break criterion is met. Eigenvalue/eigenvector pairs for which the partial occupancies are smaller than\nWEIMIN\nare treated as unoccupied states (and are thus only optimized twice).",
    "related_tags": [
      "EBREAK",
      "DEPER",
      "IBRION"
    ]
  },
  "WRT_NMRCUR": {
    "default_value": "WRT_NMRCUR = 0",
    "description": "Allows to write the NMR current response in atomic units to file.",
    "detailed_description": "Warning: Not yet released!\nThis page contains information about a feature that will be available in a future \nrelease of VASP. In other words, currently you cannot use it even with the latest version of VASP. The information may change significantly until it is released.\n\nIn conjunction with\nLCHIMAG\n= True\n,\nWRT_NMRCUR\nallows to write the current response on the fine grid\nNGXF\nx\nNGYF\nx\nNGZF\nin atomic units (hartree bohr\n−\n2\n{\\displaystyle ^{-2}}\n) to an external magnetic field within\nlinear response NMR\n. The output is written to\nNMRCURBX\n,\nNMRCURBY\n, and/or\nNMRCURBZ\ndepending on the selected direction of the perturbing\nB\n{\\displaystyle \\mathbf{B}}\nfield:\n\nWRT_NMRCUR\n= 0\n: no current response written to file (default)\nWRT_NMRCUR\n= 1\n:\nB\nx\n{\\displaystyle B_x}\nWRT_NMRCUR\n= 2\n:\nB\ny\n{\\displaystyle B_y}\nWRT_NMRCUR\n= 3\n:\nB\nz\n{\\displaystyle B_z}\nWRT_NMRCUR\n= 4\n: all three directions of\nB\n=\n(\nB\nx\n,\nB\ny\n,\nB\nz\n)\nT\n{\\displaystyle \\mathbf{B}=(B_x,B_y,B_z)^T}\n\nIt is also written to\nvaspout.h5\n, if compiled with\nHDF5 support\n. You can find the data groups\n\n/results/nmrcurbx        Group\n /results/nmrcurbx/grid   Dataset {3}\n /results/nmrcurbx/structure Group\n /results/nmrcurbx/structure/position Group\n /results/nmrcurbx/structure/position/direct_coordinates Dataset {SCALAR} \n /results/nmrcurbx/structure/position/ion_sha256 Dataset {1}\n /results/nmrcurbx/structure/position/ion_types Dataset {1}\n /results/nmrcurbx/structure/position/lattice_vectors Dataset {3, 3}\n /results/nmrcurbx/structure/position/number_ion_types Dataset {1}\n /results/nmrcurbx/structure/position/position_ions Dataset {2, 3}\n /results/nmrcurbx/structure/position/scale Dataset {SCALAR}\n /results/nmrcurbx/structure/position/system Dataset {SCALAR}\n /results/nmrcurbx/values Dataset {3, 24, 24, 24}\n\nand use\npy4vasp\nto access these, e.g., using\n\nimport\npy4vasp\nas\npv\ncalc\n=\npv\n.\nCalculation\n.\nfrom_path\n(\n\".\"\n)\ncalc\n.\ncurrent_density\n.\nto_contour\n(\n\"NMR(x)\"\n,\na\n=\n0.5\n)\n+\ncalc\n.\ncurrent_density\n.\nto_quiver\n(\n\"NMR(x)\"\n,\na\n=\n0.5\n)\n\nto select the current response triggered by\nB\nx\n{\\displaystyle B_x}\n. It will result in a contour plot showing the magnitude of the current density and a quiver plot with the projected current in the selected plane. The plane is selected as a fraction\nx\n{\\displaystyle x}\nof the lattice vector. Here,\nx=0.5\nalong\na\n{\\displaystyle \\mathbf{a}}\n. For the other lattice vectors use\nb=x\nor\nc=x\n.\n\nWarning:\nFor bulk calculations you must switch off the use of symmetry. In other words, set\nISYM\n<= 0\nif there is more than a single k point at zero (the Γ point).\n\nTip:\nConsider switching on current augmentation (\nLLRAUG\n= True\n).",
    "related_tags": [
      "LCHIMAG",
      "LLRAUG",
      "NMRCURBX"
    ]
  },
  "WRT_POTENTIAL": {
    "default_value": "WRT_POTENTIAL = None",
    "description": "Select which component of the local potential to be written as a post-processing step.",
    "detailed_description": "WRT_POTENTIAL\ncan select one or multiple local potentials on the real-space grid in the unit cell to be written, e.g.,\n\nWRT_POTENTIAL\n= total\n\nor\n\nWRT_POTENTIAL\n= hartree ionic\n\nThe output is written to\nvaspout.h5\nand can be accessed either by\npy4vasp\nor HDF5 command-line tools (h5ls, h5dump).\n\nimport\npy4vasp\nas\npv\ncalc\n=\npv\n.\nCalculation\n.\nfrom_path\n(\n\".\"\n)\npot_dict\n=\ncalc\n.\npotential\n.\nread\n(\n\"total\"\n)\n\nThe above allows the creation of a Python dictionary with the potential data.\n\nh5ls -r vaspout.h5\n\nThe above shows the table of contents of\nvaspout.h5\n. Depending on the keywords specified with\nWRT_POTENTIAL\nand the system it yields\n\n/results/potential       Group\n /results/potential/grid  Dataset {3}\n /results/potential/hartree Dataset {1, 24, 24, 24}\n /results/potential/ionic Dataset {1, 24, 24, 24}\n /results/potential/total Dataset {4, 24, 24, 24}\n /results/potential/xc    Dataset {4, 24, 24, 24}\n\nThe grid density can be increased by choosing a higher value for\nENCUT\nor explicitly by\nNGX\n,\nNGY\n,\nNGZ\n.\n\nThe first dimension of the datasets in /results/potential is 1 for nonmagnetic calculation, 2 for spin-polarized calculation, and 4 for noncollinear calculations. In case the potential is scalar, i.e., has no B-field-like contribution that couples to the magnetization, only the 1st component exists. Hence, for\nhartree\nand\nionic\n, the first dimension is 1. The components for the magnetic calculations correspond to the spinor representation with the scalar potential in the first component and the B-field in the second (\nISPIN\n=2) or\nB\n1\n{\\displaystyle B_1}\n,\nB\n2\n{\\displaystyle B_2}\nand\nB\n3\n{\\displaystyle B_3}\nin the 2nd, 3rd and 4th component (\nLNONCOLLINEAR\n=T) in the basis of Pauli matrices\n{\nσ\n1\n{\\displaystyle \\{\\sigma_1}\n,\nσ\n2\n{\\displaystyle \\sigma_2}\n,\nσ\n3\n}\n{\\displaystyle \\mathbf{\\sigma}_3\\}}\ngiven by\nSAXIS\n.\n\nMind:\nAs a convention, the\nG\n=\n0\n{\\displaystyle \\mathbf{G}{{=}}0}\ncomponent in reciprocal-space representations of both, the Hartree and ionic, potentials are set to zero. This implies that considering the sum of the Hartree and ionic potentials is more meaningful to visualize than either potential individually.\n\nWRT_POTENTIAL\ncan be run as a post-processing step by restarting from a converged\nCHGCAR\nand setting\nALGO\n=None. It is available for VASP >= 6.4.3.\n\nOptions to select\n\ntotal\n\nV\ntotal\n(\nr\n)\n+\nB\ntotal\n(\nr\n)\n=\nV\nionic\n(\nr\n)\n+\nV\nhartree\n(\nr\n)\n+\nV\nxc\n(\nr\n)\n+\nB\nxc\n(\nr\n)\n{\\displaystyle \nV_{\\text{total}}(\\mathbf{r}) + B_{\\text{total}}(\\mathbf{r}) = \nV_{\\text{ionic}}(\\mathbf{r}) + V_{\\text{hartree}}(\\mathbf{r})+\nV_{\\text{xc}}(\\mathbf{r}) + B_{\\text{xc}}(\\mathbf{r})\n}\n\nThe output is written to\n/results/potential/total\n, as well as\nLOCPOT\n.\n\nhartree\n\nV\nhartree\n(\nr\n)\n=\n∫\nn\n(\nr\n′\n)\n|\nr\n−\nr\n′\n|\nd\nr\n′\n{\\displaystyle \nV_{\\text{hartree}}(\\mathbf{r}) = \\int \\frac{n(\\mathbf{r'})}{|\\mathbf{r}-\\mathbf{r'}|}d\\mathbf{r'}\n}\n\nThe output is written to\n/results/potential/hartree\n.\n\nionic\n\nV\nionic\n(\nr\n)\n{\\displaystyle V_{\\text{ionic}}(\\mathbf{r})}\nas mimicked by the pseudopotentials of the\nPAW method\n. The output is written to\n/results/potential/ionic\n.\n\nxc\n\nV\nxc\n(\nr\n)\n+\nB\nxc\n(\nr\n)\n{\\displaystyle \nV_{\\text{xc}}(\\mathbf{r}) + B_{\\text{xc}}(\\mathbf{r})\n}\nas defined by the selected\nexchange-correlation functional\n. The output is written to\n/results/potential/xc\n.\n\nMind:\nThis only corresponds to the (semi-)local functionals, i.e., LDA, GGA, non-local vdW-DF functionals, and does not account for either the potential\nμ\n{\\displaystyle \\mu}\nassociated with the kinetic energy density in\nMETAGGA\nor the nonlocal Fock exchange considered in hybrid functionals.",
    "related_tags": [
      "LVACPOTAV",
      "LVTOT",
      "LVHAR",
      "WRT_POTENTIAL",
      "LDIPOL",
      "ENCUT",
      "NGX",
      "NGY",
      "NGZ"
    ]
  },
  "XC": {
    "default_value": "Default: XC = GGA if the GGA tag is used | = METAGGA if the METAGGA tag is used | = The functional specified by LEXCH in the POTCAR file if neither GGA nor METAGGA is used",
    "description": "Specifies a combination of exchange-correlation functionals.",
    "detailed_description": "A combination of semilocal (LDA, GGA, and METAGGA) functionals can be set with the\nXC\ntag, which provides much more flexibility in the choice of the functional compared to the\nGGA\nand\nMETAGGA\ntags. The functionals that can be combined are the functionals implemented in VASP (listed at\nGGA\nand\nMETAGGA\n) and the functionals implemented in Libxc\n[1]\n[2]\n[3]\n(listed on the Libxc website\n[4]\n). The combination can consist of up to 100 components; for each, a multiplication factor can be set with the\nXC_C\ntag.\n\nMind:\nThis tag is available since VASP.6.4.3.\n\nExamples of\nINCAR\n\n50% of PBE\n[5]\nand 50% of PBEsol\n[6]\n\nXC\n= PE PS\nXC_C\n= 0.5 0.5\n\nSCAN exchange\n[7]\ncombined with PBE correlation\n[5]\n\nXC\n= SCAN_X PBE_C\n\n70% of B88\n[8]\n(from Libxc) and 30% of PBE\n[5]\nfor exchange and 100% of LYP (from Libxc) for correlation\n[9]\n\nXC\n= GGA_X_B88 PBE_X GGA_C_LYP\nXC_C\n= 0.7 0.3 1.0\n\n15% of HF, 63.75% of PBE\n[5]\n, and 21.25% of B88\n[8]\n(from Libxc) for exchange and 75% of PBE\n[5]\nand 25% of LYP\n[9]\n(from Libxc) for correlation\n\nLHFCALC\n= .TRUE.\nXC\n= PE GGA_X_B88 GGA_C_LYP\nXC_C\n= 0.75 0.25 0.25\nAEXX\n= 0.15\nAGGAX\n= 0.85\n\nThe PBE exchange is multiplied by\n0.75\n×\n0.85\n=\n0.6375\n{\\displaystyle 0.75\\times0.85=0.6375}\nand the B88 exchange by\n0.25\n×\n0.85\n=\n0.2125\n{\\displaystyle 0.25\\times0.85=0.2125}\n.\n\n15% of HF, 63.75% of PBE\n[5]\n, and 21.25% of SCAN\n[7]\nfor exchange and 75% of PBE\n[5]\nand 25% of SCAN\n[7]\nfor correlation\n\nLHFCALC\n= .TRUE.\nXC\n= PE SCAN\nXC_C\n= 0.75 0.25\nAEXX\n= 0.15\nAGGAX\n= 0.85\nAMGGAX\n= 0.85\n\nThe PBE exchange is multiplied by\n0.75\n×\n0.85\n=\n0.6375\n{\\displaystyle 0.75\\times0.85=0.6375}\nand the SCAN exchange by\n0.25\n×\n0.85\n=\n0.2125\n{\\displaystyle 0.25\\times0.85=0.2125}\n.\nAGGAX\nand\nAMGGAX\nmultiply the exchange part of PBE and SCAN, respectively.",
    "related_tags": [
      "XC_C",
      "GGA",
      "METAGGA",
      "LIBXC1",
      "LIBXC2",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC"
    ]
  },
  "XC_C": {
    "default_value": "XC_C = 1.0*NXC",
    "description": "Multiplication factors for the components of the functional given by the XC tag.",
    "detailed_description": "XC_C\nsets the factors that multiply each component of the functional specified with the\nXC\ntag. The number of values specified with\nXC_C\nhas to be equal to the number of functional components set with\nXC\n(NXC). Examples of how to use\nXC_C\nare provided at\nXC\n.\n\nMind:\nXC_C\nis available since VASP.6.4.3.\nThe\nXC_C\ntag can be used together with the\nALDAX\n,\nALDAC\n,\nAGGAX\n,\nAGGAC\n,\nAMGGAX\n, and\nAMGGAC\ntags that can be used when\nLHFCALC\n=.TRUE.. Such examples are provided at\nXC\n.",
    "related_tags": [
      "XC",
      "GGA",
      "METAGGA",
      "ALDAX",
      "ALDAC",
      "AGGAX",
      "AGGAC",
      "AMGGAX",
      "AMGGAC"
    ]
  },
  "ZAB_VDW": {
    "default_value": "ZAB_VDW = -0.8491",
    "description": "The tag ZAB_VDW specifies the value of the parameter Z a b {\\displaystyle Z_{ab}} in the kernel of the nonlocal vdW-DF functional of Dion et al . [1]",
    "detailed_description": "In a revised version of the vdW correlation functional from Lee\net al\n.\n[2]\n,\nZ\na\nb\n=\n−\n1.8867\n{\\displaystyle Z_{ab}=-1.8867}\n.",
    "related_tags": [
      "Nonlocal vdW-DF functionals",
      "PARAM1",
      "PARAM2"
    ]
  }
}